Helm: пакетный менеджер для Kubernetes

Из этого урока вы узнаете:
  ➜ Что такое пакетный менеджер в контексте Kubernetes и для чего он нужен.
  ➜ Что такое шаблонизатор,
     какие популярные шаблонизаторы существуют,
     в чём отличие шаблонизатора от пакетного менеджера.
  ➜ Как создавать Helm-пакет и с помощью него управлять приложением в Kubernetes.

[source: https://helm.sh/ru/]

[Проблема №1. Автоматизация — наше всё]

[!] Необходимость автоматизации развёртывания приложений.

Чтобы стандартизировать и упростить процесс развёртывания приложений, используют абстракцию под названием пакет.

Пакет приложения — некий артефакт, который формируется в процессе развёртки.

Внутри пакета находятся не только код и исполняемые файлы приложения, но и:
  ● логика, по которой раскладываются эти исполняемые файлы в файловой системе по принятым стандартам;
  ● «технологическая оснастка» для корректной работы приложения в ОС
    (например, для запуска сервисов есть systemd-юниты)
  ● различные дополнительные артефакты, которые создают рабочее окружение приложения
    (например, утилиты и sql-скрипты для миграции баз данных)

Таким образом, с помощью пакета можно описать
  ➜ логику установки/обновления/удаление приложения,
  ➜ различные дополнительные скрипты (которые «настраивают» рабочее окружение приложения)
     + список зависимостей, без которых приложение не будет работать.


[Проблема №2. Пакеты, нам нужны пакеты!]

[!] Необходима абстракция для описания логики установки приложения в ОС, включая установку всех зависимостей.

Примеры пакетов приложения:
  Windows: пакеты .exe и .msi
  Ubuntu: пакеты .deb  (for apt)
  RHEL: пакеты .rpm    (for dnf)

(?) Что происходит при установке пакета (на примере Ansible)?
# (!) нужен специальный deb-пакет
  -> в ОС добавляются исполняемые файлы: они копируются из пакета в специальную директорию,
     которая по стандарту лежит в PATH (/usr/bin)
  -> Добавятся:
    ● /usr/bin/ansible
    ● /usr/bin/ansible-playbook
    ● /usr/bin/ansible-galaxy
    ● и другие

  -> также добавятся готовые к использованию конфигурационные файлы
     в «правильную директорию» — ту, в которой приложение ищет свои конфиги (/etc):
     ● /etc/ansible/ansible.cfg
     ● /etc/ansible/hosts

/*
  Для того чтобы удобнее было работать с пакетами, их собирают в специальные пакетные репозитории
  (чаще всего это обычная директория на HTTP сервере).
*/

Для установки и обновления пакета из какого-то репозитория используется пакетный менеджер (ПМ).
# ему указывают список репозиториев для поиска и скачивания пакетов.


[Проблема №3. Где хранить пакеты?]

Нужны репозитории пакетов и инструмент для работы с ними.

У ПМ есть:
  + список репозиториев;
  + база данных с состоянием устанавливаемых пакетов.
    (в БД содержится информация о файлах, которые устанавливают пакеты)
    -> чтобы избежать конфликтов (при одновременной попытке перезаписи одного исполняемого файла двумя пакетами)
    ++ есть логика транзакций
       = можно откатить состояние ОС, если установка набора пакетов не удалась.


[Проблема №4. Как понять, что пакет установился правильно и вообще установился?]

Нужно уметь отслеживать состояние установки пакетов
  ✓ для разрешения конфликтов
    и
  ✓ повышения надёжности работы ОС.

/*
  Создатели Helm воспринимают Kubernetes как операционную систему (ОС),
  ведь он предоставляет:
    ✓ среду для запуска программ 
    ✓ инструменты для
      ● управления,
      ● хранения 
      ● мониторинга
      программ,
  = так же как ОС.
  Только вместо программ в Kubernetes находятся контейнеры.
  А раз есть ОС => нужно подобрать удобный способ управления доставкой программ.
  Для этого и существуют менеджеры пакетов (ПМ).
*/

Пакет в ОС — это своего рода дистрибутив программы =
  = набор необходимых для работы программы файлов, упакованный в специальный формат.
Менеджер пакетов — система управления пакетами.

********************************************
* Helm === менеджер пакетов для Kubernetes *
********************************************

  ● Чарт = формат пакета в Helm.
  ● Пакет в Helm называется чарт упакованный в .tgz архив, у которого есть версия.
  ● Экземпляр чарта, который работает в кластере Kubernetes = релиз.
  ● Приложение для Kubernetes = это набор манифестов.
  ● Темплейт (шаблонизированный манифест) = это манифест, часть значений в котором заменена на переменные.

# По сути чарт — это директория определённой структуры с текстовыми файлами внутри.

Внутри чарта:
  - набор шаблонов,
  - файл с дефолтными значениями переменных
  - метаданные.

--<Chart.Example>--
<chart_name>/
    .helmignore
    Chart.yaml
    values.yaml   
    charts/         
    crds/ 
    templates/ 
        _helpers.tpl
####

  ● <chart_name>
    — имя чарта

  ● .helmignore
    — содержит шаблоны для файлов, которые следует игнорировать при cоздании чарта (аналог .gitignore)

  ● Chart.yaml
    — мета-информация о чарте:
      - список зависимостей,
      - мейнтейнеров,
      - описание чарта,
      - версия приложения
      и т.д.

  ● values.yaml
    — значение переменных по умолчанию

  ● charts/
    — директория для чартов, от которых зависит текущий чарт

  ● crds/
    — custom resource definitions (CRDs)
"""
  Kubernetes предоставляет механизм для объявления НОВЫХ ТИПОВ ОБЪЕКТОВ Kubernetes.
  Используя CustomResourceDefinitions (CRD), разработчики Kubernetes могут объявлять пользовательские типы ресурсов.
  В Helm 3 CRD рассматриваются как особый тип объектов.
  Они устанавливаются перед остальной частью чарта и имеют некоторые ограничения.
  Файлы CRD YAML должны быть помещены в каталог crds/ внутри чарта.
  В одном файле может быть размещено несколько CRD (разделенных маркерами начала и конца YAML).
  Helm попытается загрузить в Kubernetes все файлы из каталога CRD.

(!) Файлы CRD НЕ МОГУТ БЫТЬ ШАБЛОННЫМИ (cannot be templated).
Когда Helm устанавливает новый чарт, он
  1) загрузит CRD,
  2) сделает паузу, пока CRD не станут доступны на сервере API,
  3) а затем запустит шаблонизатор, отрендерит остальную часть чарта и загрузит ее в Kubernetes.

Благодаря такому упорядочиванию информация о CRD доступна в объекте .Capabilities в шаблонах Helm,
и шаблоны Helm могут создавать новые экземпляры объектов, которые были объявлены в CRD.
"""

  ● templates/
    — шаблоны, в которые подставляются значения из values.yaml для генерации валидных Kubernetes манифестов.
[!]   Есть соглашение, что имена файлов-шаблонов ВНУТРИ templates должны
      + отражать тип (kind) ресурса
      + и иметь расширение .yaml/.yml

  ● templates/_helpers.tpl
    — файл со вспомогательными шаблонами, которые могут быть переиспользованы в чарте.
      Подобные файлы (по соглашению) должны начинаться с нижнего подчёркивания и иметь расширение tpl.
      В них можно создавать свои «сложные» (динамически вычисляемые) переменные


Иными словами, в чарте хранятся:
  + набор шаблонизированных манифестов;
  + дефолтные значения для переменных;
  + информация о версии чарта, его имя.

**********************
* Каталог templates/ *
**********************

  Helm позволяет создавать темплейты.
  Темплейты помогают гибко настраивать приложение для разных окружений.
# Например:
## Prod: нужно 5 реплик приложения
## Tests: достаточно 1 реплики приложения

Чтобы не плодить манифесты-близнецы, можно
  1) вместо количества реплик указать переменную,
  2) а потом передавать темплейт и нужное количество реплик шаблонизатору,
  3) шаблонизатор сам «соберёт» правильный манифест.

# На всякий случай, Helm — это не инноватор, есть и отдельные шаблонизаторы для Kubernetes.
# С помощью шаблонизаторов можно параметризировать манифесты, а также задеплоить их в Kubernetes.

У всех шаблонизаторов есть несколько общих черт:
  + Набор шаблонизированных манифестов.
  + Специальный файл, в котором хранятся значения переменных по умолчанию.
  + Способ деплоя в Kubernetes кластер.
  + Все они kubectl based
    — им без разницы, что используется, ведь все отрендеренные манифесты можно будет деплоить с помощью kubectl.

// Шаблонизаторы в контексте Kubernetes используются для генерации манифестов.
// За основу берутся темплейты и заданные значения переменных

[Почему Helm предпочтительнее Ansible:]

  Ansible с плагином для Kubernetes = только шаблонизатор,
  а Helm — это, в первую очередь, менеджеров пакетов
  и возможность шаблонизации, это часть его функциональности, которая помогает создавать чарты более гибко.

[Другие преимущества Helm:]

  ✓ Репозитории
    — для хранения чартов можно использовать Helm-чарт репозитории и делиться пакетами внутри компании или с внешним миром.
    #Например, для установки MySQL достаточно добавить официальный Helm репозиторий и выполнить команду
-->
helm install bitnami/mysql
<--
    # НЕ скачивать бинарники

  ✓ Helm можно использовать как релиз-менеджер:
    = устанавливать, откатывать и обновлять релизы.
      Когда Helm деплоит приложение, он не просто отправляет манифесты,
      но ещё следит за тем, как этот релиз выкатывается:
      (?) всё ли накатилось,
      (?) всё ли запустилось
      (!) и говорит, получилось установить релиз в кластер или нет.

      К тому же, он умеет откатывать релизы до нужной версии:
        = если во время деплоя приложения что-то пошло не так,
          то у Helm есть возможность сделать rollback на нужную версию
            <или>
          автоматический откат на предыдущую рабочую версию.

  ✓ Он поддерживает механизм хуков.
      С помощью хуков можно вмешиваться в жизненный цикл релиза и выполнять какие-то действия до или после установки всех ресурсов в кластер.
      # Например:
        1) вначале создавать Configmaps и Secrets,
        2) а потом уже выкатывать Deployments.

  ✓ Helm предоставляет возможность писать и запускать ТЕСТЫ для чартов.
      Тесты могут проверять, что после установки чарт работает правильно.

[минусы:]

  — Сложное расширение:
      если чего-то не хватает в готовом чарте, скорее всего, придётся его форкнуть и доработать самостоятельно.

  — Потенциальная запутанность:
      результаты генерации релиза могут сильно отличаться от значений, которые мы передали на вход.

  — Если во время выкатки релиза что-то пошло не так, Helm ждёт установленное время и говорит «Не, не вышло».
      При этом ему неохота уточнять, что именно пошло не так.

  — Не умеет отслеживать ситуацию, когда несколько человек работает с одним и тем же релизом.
      # Например, если два человека запустят обновление одного и того же релиза,
      # Helm выполнит их команды параллельно и какое состояние будет в кластере -  НЕ ПОНЯТНО.

  — Поддержка секретов ТОЛЬКО через подключение сторонних плагинов:
      это усложняет установку Helm на новые хосты

  — Зависимость от go templates,
      которые уступают по своим возможностям jinja2(использовали в ansible)
      и есть необходимость в дополнительном изучении особенностей языка Golang.


*************************
* Установка и настройка *
*************************

1) # следовать инструкции: https://helm.sh/docs/intro/install/

#--<Install from script>--
$ curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3
$ chmod 700 get_helm.sh
$ ./get_helm.sh
##-END-##

(!) Одно из самых важных отличий между второй и третьей версиями Helm в том что,
  - во второй есть дополнительное серверное приложение Tiller,
    который должен быть установлен В KUBERNETES КЛАСТЕРЕ.
    Tiller обрабатывает запросы от Helm-клиента — подставляет нужные значения в шаблон и отправляет в Kubernetes.

  - в третьей версии эту функциональность зашили в сам клиент

2) -> Создать директорию с именем чарта и повторить в ней дерево каталогов:

<chart_name>/
    .helmignore
    Chart.yaml
    values.yaml   
    charts/         
    crds/ 
    templates/ 
        _helpers.tpl

  или

-> выполнить команду:
$ helm create <имя-чарта>

3) выделить в манифесте те кусочки, которые мы хотим шаблонизировать.

# Будем использовать для этого тестовый Deployment nginx.
--<nginx-deployment.yaml>--
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      name: nginx
        image: nginx:1.21.6
        imagePullPolicy: IfNotPresent
        ports:
          containerPort: 80
        resources:
          requests:
            memory: "64Mi"
            cpu: "100m"
          limits:
            memory: "128Mi"
            cpu: "200m"

-> поместить ПУСТОЙ файл deployments.yaml по пути:
<chart_name>/templates/deployments.yaml


4) Создаём и заполняем <chart_name>/Chart.yaml:

--<Chart.yaml>--
apiVersion: v1                                          # версия api чарта
appVersion: "1.0"                                       # версия приложения внутри чарта
description: A Helm chart for Kubernetes                # Описание приложения в одном предложении
name: nginx                                             # имя чарта
version: 0.0.1                                          # версия чарта, должна быть по SemVer2
##//##


5) Напишем values.yaml и сохраним в директорию <chart_name>, рядом с Chart.yaml

--<values.yaml>--
image:
  repository: nginx
  tag: 1.21.6
imagePullPolicy: IfNotPresent
replicas: 2
service:
  port: 80
resources:
  requests:
    memory: "64Mi"
    cpu: "100m"
  limits:
    memory: "128Mi"
    cpu: "200m"
##//##


[!] Для шаблонизации в Helm используются go templates,
    в котором, подобно jinja2, есть свои правила использования.

  Все инструкции шаблона заключаются в символы {{ и }}.
  Текст вне этих символов будет ПРОСТЫМ ТЕКСТОМ.
  Простой текст копируется из шаблона в вывод БЕЗ КАКОГО-ЛИБО ИЗМЕНЕНИЯ.

-->
простой текст  {{ выражение || функция || обращение_к_переменной }}  простой текст
<--

В {{ }} могут быть записаны выражение/функция/обращение к переменной. 

Часто можно встретить такие конструкции:

  {{ .Values.<имя переменной> }}  = значения берутся из файла с переменными values.yaml.

  {{ .Chart.<имя переменной> }}  = значения переменных ищутся в файле Chart.yaml.

  {{ .Release.Name }}  = имя, которое передаётся первым параметром команде helm install.


##> "Built-in Objects (Встроенные объекты)": https://helm.sh/docs/chart_template_guide/builtin_objects/
##> "template. Documentation": https://pkg.go.dev/text/template

'''
Значения для шаблонов предоставляются двумя способами:
  1) Разработчики чартов могут предоставить файл values.yaml внутри чарта.
     Этот файл может содержать значения по умолчанию.

  2) Пользователи чартов могут предоставить YAML-файл, содержащий значения.
     Его можно указать в командной строке в качестве опции для команды:
     helm install.

[!] пользовательские значения, указанные для команды helm install,
    будут переопределять значения в файле values.yaml чарта.
'''

6) Перенесём наш Deployment в deployments.yaml и добавим переменные, которые мы описали в values.yaml

--<deployments.yaml>--
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ .Release.Name }}
  labels:
    app: {{ .Chart.Name }}
spec:
  replicas: {{ .Values.replicas }}
  selector:
    matchLabels:
      app: {{ .Chart.Name }}
  template:
    metadata:
      labels:
        app: {{ .Chart.Name }}
    spec:
      containers:
        - name: nginx
          image: "{{ .Values.image.repository }}:{{.Values.image.tag }}"
          imagePullPolicy: {{ .Values.imagePullPolicy }}
          ports:
            - containerPort: {{.Values.service.port }}
          resources:
{{ toYaml .Values.resources | indent 10 }}

# В Helm есть несколько едва документированных функций, и одна из них - toYaml.
# Она принимает произвольный объект и записывает его в формате YAML БЕЗ ОТСТУПОВ.
# В нашем случае мы добиваемся желаемого, объединив toYaml и indent:

#--<В официальной документации:>--
#(https://helm.sh/docs/howto/charts_tips_and_tricks/#using-the-include-function)

********************************
* Using the 'include' Function *
********************************
  Go предоставляет возможность включить один шаблон в другой с помощью встроенной директивы template.
  Однако встроенная функция не может быть использована в Go template pipelines.
  Чтобы сделать возможным включение шаблона и последующее выполнение операции над его выходом,
  в Helm есть специальная функция include:
{{ include "toYaml" $value | indent 2 }}

# Приведенный выше пример
# 1) включает шаблон toYaml,
# 2) передает ему $value,
# 3) а затем передает вывод этого шаблона функции indent.

# Поскольку YAML присваивает значение уровням отступа и пробельным символам,
# это один из отличных способов включить фрагменты кода, НО ОБРАБОТАТЬ ОТСТУП в соответствующем контексте.

## Деплоим!

Готовый чарт можно передать Kubernetes тремя способами:
  ✓ Указать папку с шаблонами.
  ✓ Создать пакет — упаковывать чарт в .tgz архив и указать на него.
  ✓ Положить пакет в Helm репозиторий и добавить ссылку на репозиторий в Helm клиент.

7) Прежде чем мы отправим чарт в кластер, надо убедиться, что чарт валидный.
(!) Для этого прогоним линтер:
-->
helm lint ./<chart_name> 
<--


#> При желании можем посмотреть, как выглядит манифест с подставленными переменными:

helm template ./<chart_name>
````
```bash
$ helm template ./nginx-test    

---
# Source: nginx/templates/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: RELEASE-NAME
  labels:
    app: nginx
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      ‐ name: nginx
        image: "nginx:1.21.6"
        imagePullPolicy: IfNotPresent
        ports:
          ‐ containerPort: 80
        resources:
          limits:
            cpu: 200m
            memory: 128Mi
          requests:
            cpu: 100m
            memory: 64Mi

8) [!] Чтобы передать чарт в кластер в виде .tgz, нужно сначала упаковать его в архив — создать пакет:

--[CMD]--
# соберёт чарт с именем:
Chart.Name-Chart.Version.tgz            # генерируется автоматически в результате выполнения команды

***********************************************
* package-name = Chart.Name-Chart.Version.tgz *
***********************************************

$ helm package ./<chart_name>

#(формируем пакет)-->
$ helm package ./nginx-test

##_OUTPUT_##
Successfully packaged chart and saved it to: /tmp/helm/nginx-0.0.1.tgz
<--

#> Деплоим в Kubernetes, указав папочку — чарт:

--[CMD]--
helm install <name> ./<chart_name>

# This command installs a chart archive.
# The install argument must be:
#   -> a chart reference,
#   -> a path to a packaged chart,
#   -> путь к распакованному каталогу чартов или URL.
####

# Команда `helm install` устанавливает приложение в кластер Kubernetes.
# Она принимает два аргумента: name и chart_name.
# name — это имя приложения, которое вы хотите установить.
# chart_name — это файл, который содержит информацию о приложении.
# Этот файл называется чартом (chart).

/*
[!]
Существует шесть различных способов выражения чарта, который вы хотите установить:
  1. By chart reference:
helm install mymaria example/mariadb

  2. By path to a PACKAGED chart:
helm install mynginx ./nginx-1.2.3.tgz

  3. By path to an UNPACKED chart directory:
helm install mynginx ./nginx

  4. By absolute URL:
helm install mynginx https://example.com/charts/nginx-1.2.3.tgz

  5. By chart reference and repo url:
helm install --repo https://example.com/charts/ mynginx nginx

  6. By OCI registries:
helm install mynginx --version 1.2.3 oci://example.com/charts/nginx
*/

# Чтобы переопределить значение переменной, используется ключ
--set <имя переменной>=<значение переменной>.

#Например:
  задать другую версию образа в нашем чарте можно так:

$ helm install --set image.tag=1.21.5 nginx ./nginx-test

#> установим чарт с дефолтными значениями:
--[CMD]--
$ helm install nginx ./nginx-test

NAME: nginx
LAST DEPLOYED: <date>
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None


#--<My-deploy>--
helm install nginx ./nginx-test
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/student/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/student/.kube/config
W1206 07:44:16.603827   65652 warnings.go:70] unknown field "spec.template.spec.containers[0].limits"
W1206 07:44:16.603876   65652 warnings.go:70] unknown field "spec.template.spec.containers[0].requests"
NAME: nginx
LAST DEPLOYED: Fri Dec  6 07:44:16 2024
NAMESPACE: default
STATUS: deployed
REVISION: 1
TEST SUITE: None
---


## Видим, что
## ✓ появились все нужные абстракции в Kubernetes:
-->
$ kubectl get all

pod/nginx-d474cb644-rncsb
pod/nginx-d474cb644-9cwqw
deployment.apps/nginx
replicaset.apps/nginx-d474cb644
<--

#> можно посмотреть информацию о шаблонах и значениях переменных, которые отправил Helm:
# $ helm get all <name>
$ helm get all nginx


[!] Чтобы выпустить новый релиз, нам нужно сделать хотя бы одну из 2 вещей, но можно и обе:
  * Поменять в Chart.yaml значение у version.
  * Внести какие-то изменения в шаблоны/значения.

А после отправить новую версию чарта в кластер:
-->
helm upgrade <name> ./<chart_name>
<--

##_OUTPUT_##
```
```bash
$ helm upgrade  nginx ./nginx-test

Release "nginx" has been upgraded. Happy Helming!
NAME: nginx
LAST DEPLOYED: <date>
NAMESPACE: default
STATUS: deployed
REVISION: 2
TEST SUITE: None

/*
##MY-Upgrade##
WARNING: Kubernetes configuration file is group-readable. This is insecure. Location: /home/student/.kube/config
WARNING: Kubernetes configuration file is world-readable. This is insecure. Location: /home/student/.kube/config
Error: UPGRADE FAILED: failed to create patch: unable to find api field in struct Container for the json field "requests"
*/


/*
  Новой назовём условно,
  потому что версия чарта может не измениться, но, к примеру, изменится
    -> образ внутри чарта
    -> или версия приложения.
  В идеальном мире при любых изменениях в чарте будет изменена версия чарта,
  но это не всегда происходит так
*/

****************************************************
* Немного полезностей, которые помогут при работе: *
****************************************************
  ● Ключи --wait и --timeout 600 могут быть очень полезны при работе;
    # они в паре говорят Helm подождать ответа от Kubernetes
    # 10 минут (600 секунд) вместо 5 минут по умолчанию.
    # Время ожидания может зависеть от специфики кластера или пайплайна развёртки вашего приложения,
    # можно изменять.

  ● Взять текущие переменные, которые использовались в чарте ->
    -> поменять значения переменных (если нужно) ->
    -> обновить релиз с новыми значениями из файла:
--[CMD]--
$ helm get values nginx > my.values
$ helm upgrade nginx ./nginx-test --values my.values
##--##

******************
* --reuse-values *
******************

  Ключ --reuse-values говорит Helm использовать при обновлении значения переменных из последнего релиза.


<Задание 6>
Как проверить в Kubernetes, что установился новый релиз?

  ✓ Выполнить $ helm list , посмотреть список установленных релизов и время их жизни
## Да, Helm показывает информацию о релизах, их версию, время обновления и другое.

  - Kubernetes нет дела до Helm релизов и при установке нового релиза в кластере ничего не изменится
  # Нет-нет-нет, Helm отправляет новый манифест в Kubernetes API,
  # и Kubernetes применяет изменения согласно описанным правилам
  # (если манифест не будет отличаться от того, что уже был установлен — ничего в кластере не изменится).

  ✓ Выполнить $ kubectl descibe <resource> <resource_name>
    # = для того ресурса, который изменяли,
    # и убедиться, что стоят новые значения
## И правда, в чарте описали изменение и скормили чарт Kubernetes API,
##=> поэтому должны быть новые изменённые значения у ресурсов.

(!) На самом деле, если ничего не изменить в чарте и сделать upgrade,
  => в Helm появится новый релиз,
  при этом в кластере Kubernetes ничего не произойдёт с абстракциями из манифеста.


#> Откатиться на предыдущий релиз:
Чтобы показать rollback более наглядно, создадим три релиза:
  1) Собственно, тот, что мы создали раньше.
  2) Изменим service.port в values.yaml с 80 на 8080 и сделаем helm upgrade.
  3) Изменим версию чарта в <chart_name>/Chart.yaml на 0.0.2 (переменная version),
     тоже задеплоим в кластер с помощью helm upgrade

# Посмотреть инфрмацию о релизах:
$ helm history <name> 

--[CMD]--
$ helm history nginx

REVISION    UPDATED     STATUS          CHART            APP VERSION    DESCRIPTION
1           <date>      superseded      nginx-0.0.1      1.0            Install complete
2           <date>        superseded      nginx-0.0.1      1.0            Upgrade complete
3           <date>        deployed        nginx-0.0.2      1.0            Upgrade complete

##//##

# Откатимся на 1 релиз:
****************************************
* helm rollback <name> revision_number *
****************************************

--[CMD]--
$ helm rollback nginx 1

Rollback was a success! Happy Helming!

##END##


# Для уничтожения релиза используем:

$ helm uninstall <name>

'''
This command takes a release name and uninstalls the release.
It removes all of the resources associated with the last release of the chart as well as the release history,
freeing it up for future use.

Use the '--dry-run' flag to see which releases will be uninstalled without actually uninstalling them.
'''

# Если дописать ключ --keep-history, то история релизов останется и можно будет применить rollback,
иначе удалится вся информация о релизе.

--[CMD]--
$ helm uninstall nginx --keep-history

##_OUTPUT_##_##
release "nginx" uninstalled

##END##


<Задание 7>
Как можно откатить изменения в Kubernetes кластере без сторонних средств?


Правильный ответ
  ✓ Использовать kubectl rollout undo
    # Да, можно откатить изменения, но только для Deployment.

  ✓ Создавать копию шаблонизированных манифестов и значений перед изменениями

********************
* Helm-репозиторий *
********************

Helm репозиторий
  — это обычный HTTP сервер с index.yaml,
    который содержит метаданные о запакованных чартах в репозитории, и набор пакетов.

******************************************************************
* В Nexus есть возможность создавать Helm-репозитории из коробки *
* буквально в несколько кликов мышью:                            *
******************************************************************

[!] Как создать Helm-репозиторий в Nexus:
-->
  Repositories -> Create repository -> helm(hosted) ->
    name: "<repo_name>" , 
    Deployment policy: "Allow redeploy"
<--

#> Положим архив-чарт в Helm-репозиторий в Nexus:
-->
$ curl -u <username>:<password> http://<host>:<port>/repository/<repository_name>/ --upload-file <package_name> 
<--

[!] Есть несколько правил для Helm-репозиториев:
    * Все чарты должны быть упакованы с помощью helm package <chart-name> и иметь корректную версию (по SemVer2).
    * index.yaml должен быть обновлён при каждом добавлении/обновлении/удалении чарта (Nexus сам следит за актуальностью index файла).
    * Если в репозиторий положить чарт с версией, которая там уже есть, чарт в репозитории ПЕРЕЗАПИШЕТСЯ на тот, что мы пушим.

****************************************************
* Установка Helm-пакетов из удалённого репозитория *
****************************************************

1) Подключим Helm-репозиторий:
$ helm repo add <helm_repository_name> http://<host>:<port>/repository/<nexus_repository_name>/ --username <username> --password <password>

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
* Ссылка  на репозиторий ОБЯЗАТЕЛЬНО ЗАКАНЧИВАЕТСЯ /

2) Просмотр подключенных Helm-репозиториев:
$ helm repo list

##_OUTPUT_##
NAME            URL
nginx-stable    https://helm.nginx.com/stable
nexus-helm      https://nexus.praktikum-services.tech/repository/test-helm/
##END##


[!ВАЖНО!]
This helm hosted repository is not directly browseable at this URL.
Please use the browse or HTML index views to inspect the contents of this repository.
---
Внимание: ваш репозиторий может не отобразиться в интерфейсе Nexus.
После загрузки вашего чарта интерфейс преобразится, и вы почувствуете разницу.
####

3) update в Helm-репо:
# без <helm_repository_name> обновить информацию для всех репозиториев

$ helm repo update <helm_repository_name>

# update заберёт информацию о репозитории — какие в нём есть чарты, какой версии
# (по сути, скачаем самый свежий файл index.yaml),
# после чего закэширует эту информацию.

4) Чтобы посмотреть список последних версий пакетов или поискать нужный:

# Для поиска использует кэш, который создал helm repo update
# Если не указать <helm_repository_name>, то поиск будет идти по всем подключённым репозиториям

#  --version для поиска конкретной версии
helm search repo <helm_repository_name>

5) Установка/обновление делается очень похоже на работу с локальным чартом,
   только нужно указать имя удалённого репозитория,
   а имя чарта можем получить из имени пакета,


имя чарта = "имя пакета" <минус> "версия" <минус> ".tgz":

--[CMD]--
$ helm install <helm_repository_name> <chart_name> --version <chart_version>

# обновление
$ helm upgrade <chart_name> <helm_repository_name>/<chart_name> 

# <chart_name> = задаём (произвольное) имя релиза

<Задание 7:>
Helm-пакеты (чарт в tgz) будем хранить в Helm-репозитории
(?) — а куда складывать сами чарты (директорию с метаданными, шаблонами и значениями по умолчанию)? 

  ✓ Можно положить в отдельную директорию, рядом с кодом проекта

  ✓ Создать ещё одну директорию в проекте, который используется для настройки инфраструктуры

# И так тоже можно.
# Создаём отдельный репозиторий, в который скидываем все «исходники» чартов, для всех приложений.
# Это второй подход — мы знаем, что все чарты живут в одной репе
# и если надо что-то поменять — идём в этот репозиторий.


*********
* Релиз *
*********

Релиз — это экземпляр чарта, запущенный в Kubernetes.

Для хранения информации о релизе Helm использует Kubernetes Secret типа helm.sh/release.v1.
Во второй версии Helm вместо secret использует configmap, но в остальном идея похожая.

По умолчанию Helm отслеживает до 10 релизов.
Когда их станет больше 10, самые старые записи о релизах будут удалены (секреты удалятся).

Каждый релиз содержит информацию, которой достаточно для повторного создания объектов Kubernetes в этой конкретной ревизии.

Вся интересная для нас информация хранится в секрете, в разделе data.release:
  * имя релиза
  * информация о релизе: статус и его словесное описание, время создания и обновления
  * чарт:
      метаданные (Chart.yaml),
      шаблоны (в исходном виде)
      и значения переменных для этого релиза
      (не только дефолтные, но и те, которые мы перееопределили)

  * манифест (отрендеренные шаблоны)
  * версия приложения
  * namespace, куда задеплоен чарт

#(!) Все эти данные зашифрованы в base64.

Релизы помогают:
  -> понять, какая версия релиза установлена в кластер
  -> посмотреть, какое состояние у последнего релиза
  -> узнать значения переменных, с которыми был задеплоен чарт


[Установка релиза:]

Когда мы выполняем: 
$ helm install <name> <chart_name>

Helm идёт по шагам: (см. изображения)
# Если релиз уже существует, произойдёт ошибка

[Обновление релиза:]

Чтобы в случае ошибки upgrade Helm автоматически откатил релиз на последний успешный,
используем ключ --atomic


[Откат релиза:]
# Для отката выполним

helm rollback <name> <release_number>

#Тогда Helm:
# Если релиз не существует: -> Ошибка
# Если не существует релиза, на который откатываемся: -> Ошибка

Также актуально --atomic

(!) Helm НЕ ЗАПРЕЩАЕТ откатываться на релиз со статусом failed.
Он просто создаст новый релиз со статусом failed, при этом манифест в Kubernetes отправлен не будет.
На самом же деле, вообще не стоит откатываться на failed.

[Удаление релиза:]
В процессе утилизации релиза helm uninstall <name> Helm:
...

откатиться на удалённый релиз МОЖНО, если удаляли с ключом --keep-history


# "Использование Helm": https://helm.sh/ru/docs/intro/using_helm/

Ключевые мысли урока
Шаблонизатор — инструмент для шаблонизации манифестов (темлейт + значение переменных) и скармливания отрендеренного манифеста Kubernetes.
Шаблонизаторы бывают разные: kustomize, ansible+Kubernetes plugin, kapitan, helm, но все на основе kubectl.
Helm — пакетный менеджер, шаблонизатор, релиз-менеджер.
Для работы с Helm используется утилита, которая ставится локально, а для подключения к кластеру он использует тот же конфиг, что и kubectl.
Чтобы Helm прибрался за собой, если что-то пошло не так, используем ключ --atomic.
--keep-history при удалении релиза поможет не потерять историю и сделать rollback в крайнем случае.


Полезные материалы
Ansible модуль для Kubernetes.
Пример деплоя простого web приложения с помощью Kustomize.
Библиотека для темплейтов в Helm.
Документация по go темплейтам.
Best practices для написания чартов.
SemVer 2.
Репозиторий c популярными Helm-чартами.
Читы и хаки в Helm