KUBERNETES MANIFESTS


(1) kubeconfig
      = Конфиг содержит информацию, необходимую для СОЗДАНИЯ СОЕДИНЕНИЯ с удаленными кластерами kubernetes под определенным пользователем

#->  "kubeconfig (v1)": https://kubernetes.io/docs/reference/config-api/kubeconfig.v1/


#-[kubeconfig]-
---
apiVersion: v1
kind: Config

#(↓) имя текущего контекста 
current-context: kube-admin

# список контекстов
contexts:
  - name: kube-admin        # Кластер "kube" и пользователь "admin" объединены в контекст
    context: 
      cluster: kube
      user: admin
      #(↓) Пользователь admin имеет доступ к неймспейсу default
      namespace: default

# список кластеров
clusters:
  - name: kube # Кластер "kube" и его адрес
    cluster:
      server: https://192.168.49.2:8443

# Список пользователей
users:
  - name: admin
    token: 123456

#--_EOF_--#


Внутри kubeconfig используется КОНЦЕПЦИЯ КОНТЕКСТОВ:
= контекст работы с кластером компонуется из
  + описания подключения к кластеру   и
  + конфигурации пользователя.

Это позволяет, например, использовать одного пользователя
  -> для работы с несколькими кластерами
    <или>
  -> для работы разными неймспейсами внутри одного кластера.


---<_Namespace_>---
Namespace – это логическая сущность для РАЗДЕЛЕНИЯ ДОСТУПА в Kubernetes.
Для получения какого-либо ресурса внутри определённого неймспейса пользователь должен иметь доступ в неймспейс,
а в командой строке можно указать соответствующий параметр:
kubectl <command> <TYPE> --namespace <имя неймспейса>.
---

В kubeconfig можно встретить различные варианты настройки аутентификации:
  * токены,
  * сертификаты
  и др.

  Сертификаты
    -> чаще всего используются для аутентификации компонентов самого кластера
    (они тоже могут использовать kubeconfig),

  Токены
    -> используются обычными пользователями.


(2) K8s manifests. Примеры определения сущностей Kubernetes

[!] Манифест — это YAML или JSON файл, описывающий объекты, которые нужно запустить в Kubernetes.

[>] Если мы хотим ЗАПУСТИТЬ наше ПРИЛОЖЕНИЕ (Docker-контейнеры) в Pod'е Kubernetes,
    то нужно написать манифест для сущности Pod.
    
[!] `---` = разделитель, который отделяет НАЧАЛО YAML документа;
    -> нужен, чтобы описать несколько разных сущностей в одном манифесте.

  => внутри ОДНОГО YAML файла может быть НЕСКОЛЬКО YAML документов

[1] Манифест для Pod, в котором запускают Nginx:

---
apiVersion: v1
kind: Pod
metadata:
  name: nginx
spec:
  containers:
    - name: nginx
      image: nginx:1.21.6
      imagePullPolicy: IfNotPresent


***********************
* Структура манифеста *
***********************

● kind
  = тип объекта, который мы хотим создать
    - Pod,
    - Service,
    - Namespace,
    - Persistent Volume
    и т. д.
## (см. $(kubectl api-resources).NAME );

● apiVersion
  — версия API, которая используется для взаимодействия с ресурсом
  (v1alpha1 - alpha, v1beta1 - beta, v1 - stable).
  (!) Для разных ресурсов могут быть разные apiVersion.
      Чем ближе к v1, тем больше вероятности, что API сущности (== синтаксис ) не будет меняться.

  (!) с развитием Kubernetes версии v1beta1 ПЕРЕСТАЮТ ПОДДЕРЖИВАТЬСЯ
    -> стоит за этим поглядывать;

● metadata
  — различная мета-информация,
    например, в этом разделе указывается
      -> имя ресурса,
      -> его namespace
      и прочее.

  (!) ОБЯЗАТЕЛЬНЫМ является только имя.

● блок spec:
  в блоке spec указывают СПЕЦИФИЧНЫЕ для конкретной сущности АТРИБУТЫ:
  [атрибуты для Pod'а:]
    - containers (контейнеры)
        (которые мы хотим запустить в нём)
    - images (образы)
        (на основе которых будут создаваться эти контейнеры)

    - imagePullPolicy
      ─ определяет для kubelet ПОЛИТИКУ СКАЧИВАНИЯ ОБРАЗА контейнера:
        = IfNotPresent
            ─ скачивать образ контейнера, если отсутствует на Node.
        = Always
            ─ скачивать образ каждый раз, когда kubelet запускает контейнер.
        = Never
            ─ использовать только те образы, которые присутствуют на Node;
              если образа нет — контейнер не запустится.
          #(!) Чтобы контейнеры появились на Node, их нужно туда «скачать» самостоятельно.

    - resources
       = можно ограничивать ресурсы, которые выделяются для Pod'а.
         это нужно для того, чтобы Pod «знал», на каких Node он сможет запуститься.
         # В этом ему активно помогает kube-scheduler.
         => Т.о., на Node не будет запущено Pod'ов больше,
            чем суммарно ресурсов им всем требуется.

      -- ephemeral-storage
         ─ для ограничения Pod по ресурсам HDD

---<Указание_Requests>---
resources:
  requests:
    memory: "64Mi"
    cpu: "100m"
---<END>---

---<Указание_Limits>---
resources:
  limits:
    memory: "128Mi"
    cpu: "200m"
---<END>---

spec.containers.resources.requests
  = ограничить ресурсы, необходимые для старта Pod

spec.containers.resources.limits
  = ограничить максимальное количество ресурсов, которые может использовать Pod.

## cpu: "100m" == 0,1 CPU
## m == мили, 1/1000 часть


[Что произойдёт в случае превышения процессом контейнера resources.limits]

  1) процесс "съел" столько памяти, сколько указано в resources.limits
  2) его Pod будет «убит» oom_killer'ом
     и снова запущен kubelet'ом


[2] Манифест для Pod Nginx, дополненный ограничениями на ресурсы:
---
apiVersion: v1
kind: Pod
metadata:
  name: nginx
  labels:
    app: nginx
spec:
  containers:
   - name: nginx
     image: nginx:1.21.6
     imagePullPolicy: IfNotPresent  
     resources:
      requests:
        memory: "64Mi"
        cpu: "100m"
      limits:
        memory: "128Mi"
        cpu: "200m"
---<END>---


[!] Манифесты:
    -> сохраняются в файл с расширением yml
    -> деплоятся на кластер Kubernetes с помощью того же kubectl
       через атрибут create или apply:
       ● create — создаёт ресурс, НО не может изменить уже созданный;
       ● apply — изменяет ресурс и создаёт его, если не был создан ранее.