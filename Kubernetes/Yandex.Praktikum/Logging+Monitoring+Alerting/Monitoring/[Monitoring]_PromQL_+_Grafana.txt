Мониторинг: PromQL и Grafana


Из этого урока вы узнаете:
  ● Тонкости хранения метрик в Prometheus
  ● Полезные функции языка запросов PromQL
  ● О визуализации и отслеживании метрик в реальном времени
  ● О настройке дашбордов в Grafana


Графики можно конструировать в веб-интерфейсе Prometheus в разделе Graph.

Достаточно ввести имя метрики jvm_buffer_memory_used_bytes в поле Expression и нажать на вкладку Graph,
-> и мы увидим графики изменения значений этой метрики во времени.

Также прямо под графиком отображаются три уникальных временных ряда для имени метрики jvm_buffer_memory_used_bytes с разными лейблами:

jvm_buffer_memory_used_bytes{container="backend", endpoint="backend", id="direct", instance="172.16.131.88:8080", job="backend", namespace="my_namespace", pod="backend-6cf48bb766-cwm9f"}
jvm_buffer_memory_used_bytes{container="backend", endpoint="backend", id="mapped", instance="172.16.131.88:8080", job="backend", namespace="my_namespace", pod="backend-6cf48bb766-cwm9f"}
jvm_buffer_memory_used_bytes{container="backend", endpoint="backend", id="mapped - 'non-volatile memory'", instance="172.16.131.88:8080", job="backend", namespace="my_namespace", pod="backend-6cf48bb766-cwm9f"}

[*] Временной ряд (англ. time series)
  = численные значения измеряемой характеристики, хранящиеся вместе с временной меткой каждого такого измерения.

#(!) Временных рядов много, поэтому для поиска нужного следует указывать две вещи:
  1) имя метрики
<и>
  2) набор лейбов.

Каждый уникальный временной ряд идентифицируется по имени метрики и набору лейблов.
Лейблы содержат информацию о ПРОИСХОЖДЕНИИ ДАННЫХ:
  ➜ имя исходного сервера || Pod'а,
  ➜ имя процесса приложения
  ➜ и детали измерения внутри приложения.


# В нашем примере метрика с именем jvm_buffer_memory_used_bytes приходит с одного Pod'а бэкенда,
# но измерения выполняются для различных типов памяти, обозначенных лейблом id.

Для того чтобы вывести график ЛИШЬ ДЛЯ ОДНОГО из временных рядов,
нужно в поле Expression задать выражение с УНИКАЛЬНЫМ набором лейблов:
-->
jvm_buffer_memory_used_bytes{<label_name>="<label_value>"}
<--

#[Аналогия с SQL:]
# Эквивалентное выражение на старом добром SQL могло бы выглядеть так:
-->
SELCT jvm_buffer_memory_used_bytes FROM table_name WHERE label_name = “label_value”;
<--

#[!] выражение запроса PromQL имеет куда более компактный вид и не требует выбора таблицы

(?) Выберите наиболее компактный PromQL-запрос для вывода одного временного ряда метрики
jvm_buffer_memory_used_bytes:

(>)
---
jvm_buffer_memory_used_bytes{id="direct"}
---
# Выбрали только УНИКАЛЬНЫЙ лейбл!


##########################
# Типы метрик Prometheus #
##########################

Сервер Prometheus
  => НЕ РАЗЛИЧАЕТ поступающие данные
  => сохраняет все временные ряды одинаково.

[!] клиенты работают через API сервера с четырьмя основными типами:
  
***********
* Counter *
***********
  — это кумулятивная метрика, которая может
    ТОЛЬКО ВОЗРАСТАТЬ
      <или>
    СБРАСЫВАТЬСЯ К НУЛЮ при рестарте сервера или процесса.

[!] Такой счётчик обычно используется для хранения КОЛИЧЕСТВА
    + обработанных запросов
      <или>
    + возникающих ошибок.

  Некоторые функции языка запросов PromQL работают ТОЛЬКО с типом Counter. 
# Пример счётчика для нашей сосисочной — sausage_orders_total.
# Общее количество заказов для каждого типа сосисок может только расти или сбрасываться к нулю при перезапуске Pod'а:

--[Prometheus.Metrics.Counter]--
# HELP sausage_orders_total  
# TYPE sausage_orders_total counter
sausage_orders_total{type="Сливочная",} 2.0
sausage_orders_total{type="Молочная",} 0.0
sausage_orders_total{type="Особая",} 0.0
sausage_orders_total{type="Русская",} 1.0
sausage_orders_total{type="Мюнхенская",} 0.0
sausage_orders_total{type="Нюренбергская",} 0.0

--<<--

*********
* Gauge *
*********
  — представляет собой ПРОИЗВОЛЬНОЕ ИЗМЕРЕНИЕ, которое может как увеличиваться, так и уменьшаться со временем.
  Это может быть:
    > количество запущенных процессов
        или
    > текущее использование памяти.

[Пример метрики типа Gauge:]
  количество АКТИВНЫХ СОЕДИНЕНИЙ с базой данных, которое может уменьшаться при снижении нагрузки на приложение:

--[Prometheus.Metrics.Gauge]--
# HELP jdbc_connections_active Current number of active connections that have been allocated from the data source.
# TYPE jdbc_connections_active gauge
jdbc_connections_active{name="dataSource",} 0.0
-<<-

# Или уже рассмотренная нами метрика использования памяти:

--[Prometheus.Metrics.Gauge]--
# HELP jvm_buffer_memory_used_bytes An estimate of the memory that the Java virtual machine is using for this buffer pool
# TYPE jvm_buffer_memory_used_bytes gauge
jvm_buffer_memory_used_bytes{id="mapped - 'non-volatile memory'",} 0.0
jvm_buffer_memory_used_bytes{id="mapped",} 0.0
jvm_buffer_memory_used_bytes{id="direct",} 89454.0

--<<--


*************
* Histogram *
*************
  — гистограмма, полезная комбинированная метрика,
    которая разбивает (англ. samples, сэмплирует) измерения по количеству измеренных значений.
    Каждое такое разбиение экспортируется как отдельная метрика (каждая с приставкой _bucket),
    что позволяет оценивать значения ПЕРЦЕНТИЛЕЙ метрики с помощью соответствующих функций PromQL.

[!] Чаще всего гистограммы используются для экспорта одного из четырёх ЗОЛОТЫХ СИГНАЛОВ, а именно — ЗАДЕРЖКИ.

/* Четыре золотых сигнала:
     ● задержка
     ● трафик
     ● ошибки 
     ● насыщение
*/

# Пример гистограммы можно посмотреть для ВРЕМЕНИ ОБРАБОТКИ ЗАКАЗОВ на странице:
http://localhost:8080/actuator/prometheus

#! (не забудьте запустить port-forward, как в прошлом уроке):

--[Prometheus.Metrics.Histogram]--
# HELP prometheus_http_request_duration_seconds Histogram of latencies for HTTP requests.
# TYPE prometheus_http_request_duration_seconds histogram
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.001",} 0.0
<...>
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.039146836",} 1.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.044739241",} 33.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.050331646",} 85.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.055924051",} 149.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.061516456",} 176.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.067108864",} 199.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.089478485",} 235.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.111848106",} 245.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.134217727",} 247.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.156587348",} 249.0
<...>
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.805306366",} 249.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="0.894784851",} 250.0
<...>
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="28.633115306",} 250.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="30.0",} 250.0
http_server_requests_seconds_bucket{method="POST",status="201",uri="/api/orders",le="+Inf",} 250.0
http_server_requests_seconds_count{method="POST",status="201",uri="/api/orders",} 250.0
http_server_requests_seconds_sum{method="POST",status="201",uri="/api/orders",} 15.340843123

--<<--
# Здесь le означает «меньше или равно».
# Из 250 запросов к URL /api/orders:
  * 85 запросов      наш бэкенд обработал за 50 миллисекунд или меньше,
  * 235 запросов     обработалось меньше чем за 100 миллисекунд.
  * Был ОДИН запрос, который работал дольше 800 миллисекунд,
  !НО ВСЕ запросы    обрабатывались меньше 900 миллисекунд. 

В метрике гистограммы также экспортируются два счётчика:
  * сумма всех измерений (sum)   и
  * общее количество измерений (count)

#=> что позволяет посчитать простое среднее.


***********
* Summary *
***********
  — или по-русски «сводка».
  Аналогичная гистограмме комбинированная метрика, НО расчёт распределения выполняется НА КЛИЕНТЕ.
  Для клиента такой расчёт будет дорогостоящим, поэтому дешевле экспортировать гистограмму.
  Так что СВОДКИ в метриках можно встретить не всегда.

# Пример сводки можно также посмотреть в метриках самого Prometheus по ссылке:

https://<your namespace>-monitoring.k8s.praktikum-services.tech/metrics
#= https://std-017-033-monitoring.k8s.praktikum-services.tech/metrics


# (имя сервера такое же, как для веб-интерфейса Prometheus):
--[Prometheus.Metrics.Summary]--
# HELP prometheus_target_interval_length_seconds Actual intervals between scrapes.
# TYPE prometheus_target_interval_length_seconds summary
prometheus_target_interval_length_seconds{interval="10s",quantile="0.01"} 9.999061507
prometheus_target_interval_length_seconds{interval="10s",quantile="0.05"} 9.999117538
prometheus_target_interval_length_seconds{interval="10s",quantile="0.5"} 10.000008905
prometheus_target_interval_length_seconds{interval="10s",quantile="0.9"} 10.000665665
prometheus_target_interval_length_seconds{interval="10s",quantile="0.99"} 10.000897368
prometheus_target_interval_length_seconds_sum{interval="10s"} 3180.004061973001
prometheus_target_interval_length_seconds_count{interval="10s"} 318
--<<--

[!] Распределение в СВОДКЕ разбивается на квантили.
    Квантиль — это родственная перцентилю характеристика измерений и 0.99 квантиль соответствует 99-му перцентилю.

  Наш Prometheus сервер сделал 318 опросов экспортёров и, в основном, через каждые 10.000897368 секунды.

[!]
"""
  КВАНТИЛЬ или в документации Prometheus — φ-quantil (читается «фи-квантиль»),
  в математической статистике — значение, которое заданная случайная величина не превышает с фиксированной вероятностью.
  А если вероятность задана в процентах, то квантиль называется ПЕРЦЕНТИЛЕМ.
"""

<?> чем перцентиль отличается от простого среднего значения? <?>

  Значение перцентиля разделит измерения на две части:
    1) ниже перцентиля
и
    2) выше перцентиля
  Это даст возможность оценить худшее значение характеристики.

  Среднее значение искажает реальную картину, если небольшая часть измерений сильно отличается от всех остальных
  #по этой причине и используют перцентиль.


##################
# Функции PromQL #
##################

С выражениями и функциями PromQL можно экспериментировать в веб-интерфейсе Prometheus в разделе Graph.
Напишите выражение в текстовом поле и нажмите Execute.

[Расчёт среднего:]
  Простое среднее значение можно посчитать, разделив счётчик суммы результатов измерений на общее количество измерений.

# Например, из гистограммы значений задержки обработки заказов http_server_requests_seconds можно взять следующие счётчики:

--[]--
# HELP http_server_requests_seconds  
# TYPE http_server_requests_seconds histogram
http_server_requests_seconds_count{method="POST",uri="/api/orders"} 3.0
http_server_requests_seconds_sum{method="POST",uri="/api/orders"} 2.330063731

--<<--

#-> И получить среднее значение с помощью выражения деления:

--[PromQL-query]--
http_server_requests_seconds_sum{method="POST",uri="/api/orders"} / http_server_requests_seconds_count{method="POST",uri="/api/orders"}
--<<--

# Это будет значение «в моменте»
  — Prometheus возьмёт последние измеренные значения метрик из временных рядов.

  Если убрать лейблы и запустить расчёт средних значений задержки для всех HTTP-методов и URI,
  то мы получим набор значений в моменте:

--[PromQL-query]--
http_server_requests_seconds_sum / http_server_requests_seconds_count 
--<<--

В терминологии PromQL этот набор значений называется «МГНОВЕННЫЙ ВЕКТОР» или «instant vector».


[!] В общем случае выражения PromQL работают с двумя типами аргументов:
  "instant vector"
   # мгновенное значение
<и>
  "range vector"
   #( = набор значений для некоторого ПРОМЕЖУТКА ВРЕМЕНИ):


<?> Подберите подходящие типы для метрик <?>

Counter
  Количество обработанных запросов
  Количество выполненных задач

Gauge
  Использование CPU
  Свободное место на диске

Histogram
  Размер поступающих данных в одном запросе
  Время обработки одного запроса


****************
* Функция rate *
****************

  Временной ряд для промежутка времени (range vector) можно получить,
  указав временной интервал в квадратных скобках:

--[Временной ряд для промежутка времени]--
http_server_requests_seconds_count{method="GET",uri="/actuator/prometheus"}[5m] 
--<<--

# Здесь [5m] — это 5 минут

[!] Но куда интереснее получить не набор таких значений,
    а единую метрику ТРАФИКА на наш сервис (второй сигнал из золотой четвёрки).


[!] PromQL позволяет посчитать СКОРОСТЬ ВОЗРАСТАНИЯ СЧЁТЧИКА во временном промежутке с помощью функции rate:
# https://prometheus.io/docs/prometheus/latest/querying/functions/#rate

--[PromQL: скорость возрастания счётчика]--
rate(http_server_requests_seconds_count{method="GET",uri="/actuator/prometheus"}[5m])
--<<--

# В нашей конфигурации мы получим значение 0.1 == одна десятая запроса в секунду.
# Это значит, что один целый запрос выполнялся каждые десять секунд,
# что совпадает с настройками scrape_interval в конфиге Prometheus.


Рассчитаем часто используемое в мониторинге СРЕДНЕЕ ЗНАЧЕНИЕ ВРЕМЕНИ ОБРАБОТКИ ЗАКАЗОВ сосисочной,
НО не для последнего одного измерения, а ЗА ИНТЕРВАЛ ВРЕМЕНИ — последние 5 минут.

Это будет нетривиальная для понимания формула,
но мы докажем её с помощью институтской техники проверки результата по единицам измерения:

--< среднее значение времени обработки заказов за интервал времени = последние 5 минут>--
rate(http_server_requests_seconds_sum{method="POST",uri="/api/orders"}[5m]) / 
rate(http_server_requests_seconds_count{method="POST",uri="/api/orders"}[5m])
<--

[Делимое:]
  измеряется в сумме времён задержек в секунду (з/с)
  = скорость изменения времени обработки заказов,

[делитель:]
  в штуках в секунду (ш/с)
  = скорость поступления заказов.

# (з/c) / (ш/с) = (з/с * c) / ш = з/ш.

Деление СУММЫ ВРЕМЕН ЗАДЕРЖЕК /на/ КОЛИЧЕСТВО ИЗМЕРЕНИЙ  == даст нам ==  СРЕДНЕЕ ЗНАЧЕНИЕ ЗАДЕРЖКИ ЗА ИНТЕРВАЛ,
указанный в квадратных скобках в формуле.


<?> Как вы думаете, почему функция rate работает только с типом Counter? </?>
'''
  + rate вычисляет скорость, которая не может быть отрицательной
    #(!) Функция rate вычисляет скорость возрастания значений в заданном промежутке времени,
    # учитывая сбросы к 0 при рестарте сервера или приложения.

  + Для Gauge не приходится говорить о скорости возрастания значений в заданном промежутке времени
    # Gauge может произвольно меняться с течением времени.
'''

**************************************
* Агрегация и агрегирующие операторы *
**************************************

  Ещё одна популярная в PromQL функциональность — это агрегирующие операторы.
  Анализируя трафик, мы указывали значение лейбла uri для корректного расчёта.

  Можно рассчитать общую нагрузку на сервер ПО ВСЕМ эндпоинтам и HTTP-методам,
  лишь просуммировав скорости:

--<общая нагрузка на сервер по всем эндпоинтам и HTTP-методам>--
sum(
  rate(http_server_requests_seconds_count[5m])
)
<--

# Такая сумма выдаст одно единственное значение,
# но на графиках удобнее смотреть распределение по эндпоинтам
# и такие суммы можно вывести с помощью группировки по соответствующему лейблу за один запрос:

--[]--
sum by (uri) (
  rate(http_server_requests_seconds_count[5m])
)
--<<--

Можно сравнить вывод такого запроса с простым запросом получения трафика
(rate(http_server_requests_seconds_count[5m]))

  Во втором случае будут выведены значения
    - для КАЖДОГО uri
    - и для КАЖДОГО HTTP-метода к этому uri,

(!) а в первом случае с sum мы собрали или агрегировали трафик
    - для ВСЕХ HTTP-методов ОДНОГО uri в ОДНОЙ метрике.


**********************
* Расчёт ПЕРЦЕНТИЛЕЙ *
**********************

  В Prometheus для вычисления перцентлей из метрики гистограммы предназначена функция:

histogram_quantile

  которая принимает на вход:
    = значение интересующего нас квантиля
    = и имя временных рядов разбиений гистограммы.
  
  Следующее выражение выдаст набор значений
    99-го перцентиля задержки
    за последние 5 минут
    для различных эндпоинтов нашего бэкенда:
--[]--
histogram_quantile(0.99, 
rate(http_server_requests_seconds_bucket[5m])
)
--<<--

(!) для получения ОБЩЕГО ЗНАЧЕНИЯ задержки ДЛЯ ВСЕГО СЕРВЕРА
мы можем воспользоваться агрегирующим оператором:

--<общее значение задержки для всего сервера>--
histogram_quantile(0.99, 
  sum without (uri)(
    rate(http_server_requests_seconds_bucket[5m])
  )
)
<--

# Здесь ключевое слово without в операторе sum
# позволит посчитать сумму значений скоростей изменения задержки ко всем эндпойнтам.


Задание 5
'''
  У гипотетического приложения есть метрика-гистограмма http_response_size_bytes для каждого HTTP-эндпоинта.
  Нам нужно найти значение МАКСИМАЛЬНОЙ СКОРОСТИ РОСТА размера HTTP-ответа за последние 5 минут.
  Напишите PromQL запрос в текстовом поле ниже.
'''
--<значение max СКОРОСТИ РОСТА размера HTTP-ответа за последние 5 минут>--
max(rate(http_response_size_bytes_count[5m]))
--<<--


Задание 6
'''
  А теперь нам нужно вывести разбивку скоростей роста размера HTTP-ответа за последние 5 минут по эндпоинтам (лейбл endpoint).
  Напишите PromQL запрос в текстовом поле ниже.
'''
--<>--
sum by (endpoint)(rate(http_response_size_bytes_count[5m]))
<--
# Обязательно ставь пробел между `by` и (endpoint)

  ✓ Интерфейс Prometheus позволяет отобразить один график для одного PromQL запроса за раз

  ✓ В Grafana можно воспользоваться дополнительной функциональностью, например, алертами

  ✓ Grafana может получать значения метрик не только из Prometheus
    # Верно, могут быть и другие источники данных, например, другая система мониторинга.

  ✓ В Grafana можно параметризовать PromQL запрос и переключать графики по одной кнопке.
      Например, между test и prod окружениями
      # Верно, это одна из киллер-фич.


Для построения ПРОСТЫХ ГРАФИКОВ с использованием языка запросов PromQL может быть и достаточно Prometheus UI,
НО красивые дашборды для обзора измерений метрик одновременно и на нескольких графиках потребуют большего!

В Prometheus UI не обойтись без РУЧНОГО ИЗМЕНЕНИЯ выражения PromQL для каждого графика,
+ а вот Grafana позволяет сделать это динамически, используя переменные.
+ Кроме того, в Графане есть множество удобных плюшек типа импорта/экспорта дашбордов
#  — это бывает очень полезно, чтобы каждый раз не заниматься строительством своего дашборда с нуля,
#  а использовать готовые наработки других инженеров

********************
* Дашборды Grafana *
********************

Prometheus Datasource:
  В качестве URL можно использовать адрес Kubernetes-сервиса: http://prometheus:9090.

Сначала раздобудем примеры готовых дашбордов:
"официальный сайт Графаны": https://grafana.com/grafana/dashboards/

#[!] наш бэкенд использует библиотеку Spring Boot Actuator для экспорта метрик в формате Прометея.

Пытаемся найти дашборд по слову actuator, выбираем один из понравившихся
#! чаще всего наиболее информативными дашбордами являются дашборды
#  + с наиболее высоким рейтингом
#  + и с наибольшим количеством скачиваний.

Напрашивается JVM (Actuator) — push на него.

Там мы должны увидеть ID дашборда, который пригодится чуть позже.

Для импорта дашборда в нашу Grafana заходим в меню Import и вставляем идентификатор (ID) дашборда
в поле с заголовком: "import via grafana.com."
-> Нажимаем кнопку Load

Каждый график и визуализация являются результатом запроса на языке PromQL.
Чтобы увидеть эти запросы, навести мышкой на одну из панелей и нажать кнопку E

V = View
E = Edit
p s = Share
x = Explore
i = Inspect

Итак, в выбранной нами панели мы видим выражение:
--[]--
sum(rate(http_server_requests_seconds_count{instance="$instance"}[1m]))
--//--

В целом оно нам знакомо, но значение лейбла instance параметризовано.
[!] Оно задаётся с помощью переменной $instance,

# для понимания, откуда берётся значение этой переменной, нужно перейти в настройки дашборда:

Здесь мы видим, как происходит извлечение значения переменной:
Type: Query
  — говорит нам о том, что для извлечения значения используется запрос,
  # а какой запрос и откуда извлекаем значение — мы можем видеть в полях: Data source и Query.

Data source: Prometheus
  — это понятно, так как никакого другого источника данных у нас пока нет.

Query: label_values(jvm_memory_used_bytes, instance)
  — это встроенная функция Grafana,
    которая позволяет извлекать из Прометея значения лейбла instance метрики jvm_memory_used_bytes.

Построим дашборды по принципу уровней мониторинга:
  - бизнес
  - 
  - 


1) Бизнес-дашборд

 выведем график трафика заказов.
 Интересующая нас метрика: sausage_orders_total
   = счётчик общего количества заказов, разбитый на типы сосисок.

# Бизнесу будет интересно анализировать тренды заказов в течение дня в разбивке по типу сосисок.

Создадим новый дашборд с именем Sausage Store Business
и добавим на него график Sausages Trends.

Для создания нового дашборда нажмите на «плюс» в левом меню Grafana, далее Create и выберите Dashboard.
Нажмите на Add new panel для создания графика:

В настройках панели справа укажите имя Sausages Trends и приступайте к конфигурации графика.
Мы будем оценивать тренды
-> по трафику в течение дня
  и нам для этого понадобится следующий запрос:
rate(sausage_orders_total{type="$sausage_type"}[5m])

Сохраните панель кнопкой Apply и добавьте переменную $sausage_type в настройках дашборда
#(шестерёнка Dahsboard settings справа вверху).

Запрос на получение значений этой переменной (Query в интерфейсе создания переменной) будет выглядеть следующим образом:
--<$sausage_type>--
label_values(sausage_orders_total, type)
<--


########################
# Ключевые мысли урока #
########################
  Основные типы метрик Prometheus — Counter, Gauge, Histogram и Summary.
  PromQL работает с двумя типами аргументов — диапазон значений за промежуток времени и набор значений в момент времени (range vector и instant vector соответственно).
  Grafana — необходимый и гибкий инструмент визуализации метрик в реальном времени.
  Множество графиков собираются в дашборд Grafana. Существует библиотека готовых дашбородов Grafana.


######################
# Полезные материалы #
######################

Prometheus Metric Types (eng):
  https://prometheus.io/docs/tutorials/understanding_metric_types/

Prometheus Histograms and Summaries (eng):
  https://prometheus.io/docs/practices/histograms/

Детали расчёта гистограмм в Prometheus (eng)
  https://grafana.com/blog/2022/03/01/how-summary-metrics-work-in-prometheus/

Как на самом деле PromQL рассчитывает частоту (rate) (eng)
  https://promlabs.com/blog/2021/01/29/how-exactly-does-promql-calculate-rates

*****************************************************
* Раздичные способы визуализации графиков в Grafana *
*****************************************************
  https://play.grafana.org/d/bdnahipisghdsa/getting-started-with-grafana-play?orgId=1&from=now-1h&to=now&timezone=browser