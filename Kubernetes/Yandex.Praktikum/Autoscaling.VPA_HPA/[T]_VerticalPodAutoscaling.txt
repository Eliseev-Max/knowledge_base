Вертикальное автомасштабирование pod'ов в Kubernetes. VPA

[sources:]
1) "Вертикальное автомасштабирование pod'ов в Kubernetes: полное руководство": https://habr.com/ru/companies/flant/articles/541642/
2) "Vertical Pod Autoscaler": https://github.com/kubernetes/autoscaler/tree/master/vertical-pod-autoscaler#installation
3) "Kubernetes VPA": https://www.kubecost.com/kubernetes-autoscaling/kubernetes-vpa/


*****************
* Зачем нам VPA *
*****************

При развертывании приложения в Kubernetes необходимо указывать его ресурсные запросы.
Обычно инженеры начинают с некоторого случайного числа, взятого с потолка.
Дальнейшая работа над приложениями и их деплой в кластер будут приводить к росту этих «взятых с потолка» заявок на ресурсы.
И разница между заявленным и реальным потреблением ресурсов будет только расти.

Разработчикам сложно
  - оценить, сколько требуется приложению для оптимальной работы,
  - установить правильную комбинацию:
    * CPU-мощностей,
    * памяти
    * числа параллельно работающих реплик.

Со временем модель использования приложения может меняться:
  -> некоторым приложениям потребуется больше CPU и memory.
  -> у других, менее популярных, требования к ресурсам, наоборот, снизятся

Горизонтальное масштабирование
  => пределяет оптимальное число реплик для приложения.
  ## (Например, может быть завышено количество pod'ов => ненужное расходование ресурсов)

Вертикальное масштабирование
  => определяет оптимальные требования к CPU и памяти.


******************************************
* Модель ресурсных требований Kubernetes *
******************************************

Kubernetes требует от пользователей указывать заявки на ресурсы с помощью
  -> resource requests (запросов на ресурсы)
    <и>
  -> resource limits (лимитов на ресурсы)

Запросы на ресурсы (resource requests)
  => резервируют некоторое количество ресурсов за приложением

# Запросы ~ некоторый минимальный объем ресурсов, который требуется pod'у для нормальной работы.

-[resources.requests]>...(нормальное функционирование приложения)...<[resources.limits]| убийство Pod'а OOM-Killer-ом || троттлинг

Лимиты (resource limits)
  => фактически выступают "предохранительным клапаном".
  ✓ они препятствуют потреблению приложением неограниченного объема памяти, если в нем имеется ее утечка.
  ✓ они спасают вас от приложений, стремящихся «захватить» процессор целиком.

# Представьте, что кто-то развернул биткоин-майнеры:
# => это вызовет процессорный «голод» для всех остальных приложений в кластере.

(!) гарантия для запрашиваемых ресурсов обеспечивается только в случае их фактического наличия.

[!] если не определить запросы (resources.requests),
    Kubernetes автоматически приравняет их к лимитам pod'а.

[!] ограничиваться лишь заданием запросов на ресурсы (resources.requests) - это распространенная ошибка!

Могут быть и другие вычислительные ресурсы:
  * эфемерное хранилище,
  * GPU,
  * huge pages в Linux.

Vertical Pod Autoscaler работает только с cpu и memory.

******************************************************
* Что такое вертикальное автомасштабирование pod'ов? *
******************************************************

  VPA позволяет автоматически устанавливать запросы на ресурсы и лимиты для контейнеров.
  Решения принимаются на основе прошлых данных об использовании CPU и памяти.

[Основная цель VPA]
   ✓ уменьшить потери ресурсов 
   ✓ минимизировать риск снижения производительности из-за троттлинга CPU или ошибок, 
     вызванных «убийством» pod'ов из-за Out Of Memory.

# Поддержкой VPA занимаются инженеры Google.
# Система называется Autopilot


*************************
* Как использовать VPA? *
*************************

--<VerticalPodAutoscaler.yaml>--
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: prometheus-vpa
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: StatefulSet
    name: prometheus
  updatePolicy:                                     # (1)
    updateMode: "Recreate"
  resourcePolicy:                                   # (2)
    containerPolicies:
      - containerName: "*"
        minAllowed:
          cpu: 0m
          memory: 0Mi
        maxAllowed:
          cpu: 1
          memory: 500Mi
        controlledResources: ["cpu", "memory"]      # (3)
        controlledValues: RequestsAndLimits         # (4)
##//##
# мы автомасштабируем StatefulSet с именем prometheus.


targetRef:
  = указывает на некий контроллер-объект Kubernetes, отвечающий за управление pod'ами.

VPA поддерживает все распространенные типы контроллеров:
  ✓ Deployment,
  ✓ StatefulSet,
  ✓ DaemonSet,
  ✓ CronJobs.

Он также должен работать с любыми кастомными типами, реализующими подресурс scale:
# https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#scale-subresource

/*
  Когда подресурс scale включен, для пользовательского ресурса открывается подресурс /scale.
  В качестве полезной нагрузки для /scale отправляется объект autoscaling/v1.Scale.
  Чтобы включить подресурс scale, в CustomResourceDefinition определяются следующие поля:
    specReplicasPath
    statusReplicasPath
    labelSelectorPath
*/

VPA получает набор pod'ов с помощью метода контроллера ScaleStatus.

(1): Поле updateMode позволяет выбрать режим работы контроллера.
    updateMode:
      ● Off
        – VPA не будет автоматически изменять ресурсные требования.
          Autoscaler подсчитывает рекомендации и хранит их в поле status объекта VPA;

      ● Initial
        – VPA устанавливает запросы на ресурсы ТОЛЬКО ПРИ СОЗДАНИИ pod'а
          и НЕ МЕНЯЕТ их потом;

      ● Recreate
        – VPA устанавливает запросы на ресурсы при создании pod'ов
          и обновляет их для существующих pod'ов, «вытесняя» (evict) в случаях,
          когда запрашиваемые ресурсы значительно отличаются от новой рекомендации;

      ● Auto
        — в настоящее время делает то же самое, что и Recreate.
          В будущем возможно использование обновлений без перезапуска (restart-free updates),
          когда этот механизм станет доступен
      ## (подробнее о нем рассказывается, например, в этом видео: https://www.youtube.com/watch?t=1320&v=Y4vnYaqhS74&feature=youtu.be).


(2): Далее для КАЖДОГО КОНТЕЙНЕРА в pod'е нужно определить resourcePolicy.
     Эти политики позволяют выбрать контейнеры, для которых будут приводиться рекомендации по ресурсам,
     и задать способ, которым это будет осуществляться.

     Вы определяете список resource policies, которые фильтруются по containerName.

[О сопоставлении contaners <=> resource policies:]
  -> можно выбрать конкретный контейнер в pod'е и сопоставить его с некой resource policy.
  -> можно указать * в качестве значения containerName
     = этим вы определите resource policy по умолчанию
    (на случай, если ни одна другая resource policy не соответствует containerName).

     Resource policies позволяют ограничить ресурсные рекомендации диапазоном,
     лежащем между minAllowed и maxAllowed.
     если minAllowed и maxAllowed не заданы => ресурсы не ограничены.


(3): controlledResources
       = можно выбрать ресурсы для рекомендаций.
       # пока поддерживаются только CPU и память.

       Если типы ресурсов не указаны:
         -> VPA будет давать рекомендации как по использованию процессора, так и по использованию памяти.


(4): controlledValues
     = позволяет выбрать, какие параметры будут контролироваться:
       * RequestsOnly
         = только запросы на ресурсы
         <или>
       * RequestsAndLimits (by default)
         = запросы на ресурсы и лимиты

"""
  лимиты будут вычисляться на основе ТЕКУЩЕГО СООТНОШЕНИЯ между запросами и лимитами pod'а.
  Например:
    если pod изначально запрашивает 1 CPU,
    а его лимит установлен на 2 CPU,
    => то VPA будет устанавливать лимит таким образом, чтобы тот всегда в два раза превышал запрос.

  Аналогичный способ расчета применяется и к памяти.

[!]  Поэтому в режиме RequestsAndLimits рассматривайте
     изначально заданные для приложения запросы на ресурсы и лимиты как некий шаблон.
"""

--<VPA-Auto>--
---
apiVersion: autoscaling.k8s.io/v1
kind: VerticalPodAutoscaler
metadata:
  name: vpa-recommender
spec:
  targetRef:
    apiVersion: "apps/v1"
    kind: Deployment
    name: vpa-recommender
  updatePolicy: 
    updateMode: "Auto"
  resourcePolicy:
    containerPolicies:
      - containerName: "*"
        controlledResources: ["cpu", "memory"]

# посмотрим на рекомендации, которые VPA записывает в поле status соответствующего CRD.

***************************
* Работа с рекомендациями *
***************************

/*
  Как только вы примените (apply) объект VeritcalPodAutoscaler,
  VPA начнет собирать данные об использовании ресурсов и вычислять рекомендации по ним.
...
  Спустя некоторое время в поле status объекта VerticalPodAutoscaler должны появиться рекомендации.
*/

(!) рекомендации в поле status объекта VeritcalPodAutoscaler можно посмотреть так:
-->
kubectl describe vpa <Object-name>
<--

--<Пример вывода>--
Status: 
  Conditions:
    Last Transition Time:  2020-12-23T08:03:07Z
    Status:                True
    Type:                  RecommendationProvided
  Recommendation:
      Container Recommendations:
      Container Name:  prometheus
      Lower Bound:
          Cpu:     25m
          Memory:  380220488
      Target:
          Cpu:     410m
          Memory:  380258472
      Uncapped Target:
          Cpu:     410m
          Memory:  380258472
      Upper Bound:
          Cpu:     704m
          Memory:  464927423
##//##

Для контейнера prometheus предлагаются четыре различные оценки.
-> оценки объема памяти приводятся В БАЙТАХ.
-> Оценки CPU — в миллиядрах (m, millicores).

# Describe scores:
  * Lower bound (нижняя граница)
    = минимальная оценка для контейнера.
    Это значение не гарантирует, что приложение сможет стабильно работать. Такие минимальные запросы на CPU и память, скорее всего, окажут значительное влияние на производительность и доступность.

  * Upper bound (верхняя граница)
    = это максимальный рекомендованный объем ресурсов для контейнера. Запросы выше этих значений, скорее всего, будут приводить к тому, что ресурсы будут расходоваться впустую.

  * Target (цель)
    = эту оцкенку мы будем использовать для задания запросов на ресурсы.

[!] Все эти оценки ограничены значениями minAllowed / maxAllowed в containerPolicies.

  * Uncapped target (неограниченная цель)
    = это целевая оценка, которая получилась бы, если бы ограничения minAllowed и maxAllowed не были заданы.

(?) Зачем нам четыре оценки?

  Vertical Pod Autoscaler использует Lower и Upper bound для вытеснения (eviction) pod'ов.
  Если текущий resource request:
    -> ниже, чем lower bound,
    -> или выше, чем upper bound,
    + и происходит 10%-ное изменение ресурсных запросов по сравнению с target-оценкой,
  => то может произойти вытеснение.

"+" VPA добавляет аннотации к pod'у при изменении требований к ресурсам.
    Если сделать describe pod'а, контролируемого VPA,
    то можно увидеть аннотации вроде:
    vpaObservedContainers (перечисление отслеживаемых контейнеров)
      <или>
    vpaUpdates (описание предпринятых действий).

  Также здесь можно увидеть, ограничена ли рекомендация
  -> параметрами minAllowed/maxAllowed
    <или>
  -> Kubernetes-объектом LimitRange.

[пример аннотаций pod'а:]
-->
apiVersion: v1
kind: Pod
metadata:
  annotations:
    vpaObservedContainers: recommender
    vpaUpdates: 'Pod resources updated by vpa-recommender: container 0: cpu request, memory request, cpu limit, memory limit' 
<--


***************************
* Когда использовать VPA? *
***************************

