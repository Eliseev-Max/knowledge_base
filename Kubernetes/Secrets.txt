Kubernetes. Secrets

[sources:]
[1] "Secrets": https://kubernetes.io/docs/concepts/configuration/secret/
[2] "Знакомство с Kubernetes. Часть 14: Секреты": 
##  https://ealebed.github.io/posts/2018/%D0%B7%D0%BD%D0%B0%D0%BA%D0%BE%D0%BC%D1%81%D1%82%D0%B2%D0%BE-%D1%81-kubernetes-%D1%87%D0%B0%D1%81%D1%82%D1%8C-14-%D1%81%D0%B5%D0%BA%D1%80%D0%B5%D1%82%D1%8B-secrets/

[3] "Managing Secrets using Configuration File":
[4] "Distribute Credentials Securely Using Secrets": https://kubernetes.io/docs/tasks/inject-data-application/distribute-credentials-secure/
[5] "Good practices for Kubernetes Secrets": https://kubernetes.io/docs/concepts/security/secrets-good-practices/
[6] Marko Luksa "Kubernetes in Action": ConfigMaps and Secrets: configuring applications [с.191 (223)]


###########
# Secrets #
###########

  Secret - это объект, содержащий небольшое количество конфиденциальных данных, таких как
    ● пароль,
    ● токен   или
    ● ключ.
  В противном случае такая информация может быть помещена
  ➜ в спецификацию Pod
  <или>
  ➜ в образ контейнера.

  Использование секретов означает, что вам не нужно включать конфиденциальные данные в код приложения.
  Поскольку секреты могут создаваться НЕЗАВИСИМО от использующих их подсистем, риск того,
  что секрет (и его данные) будут раскрыты в процессе создания, просмотра и редактирования подсистем, меньше.

  Kubernetes и приложения, работающие в вашем кластере, также могут принимать дополнительные меры предосторожности при использовании секретов,
  например, избегать записи конфиденциальных данных в энергонезависимое хранилище.

  Secrets похожи на ConfigMaps,
  НО специально предназначены для хранения конфиденциальных данных.


[Внимание:]
  секреты Kubernetes по умолчанию хранятся В НЕЗАШИФРОВАННОМ ВИДЕ в базовом хранилище данных сервера API (etcd).
[!] Любой человек с доступом к API может получить или изменить секрет, как и любой человек с доступом к etcd.

  Кроме того, любой, кто имеет право создавать Pod в namespace, может использовать этот доступ для чтения любого Secret в этом namespace;
  это включает косвенный доступ, например возможность создавать Deployment.

[!] Для безопасного использования Secrets предпримите как минимум следующие шаги:
  1) включите шифрование в состоянии покоя (Encryption at Rest) для Secrets
     (https://kubernetes.io/docs/tasks/administer-cluster/encrypt-data/)

  2) Включите || настройте правила RBAC с наименьшими привилегиями для доступа к Secrets.
     (https://kubernetes.io/docs/reference/access-authn-authz/authorization/)

  3) Ограничьте доступ к секретам для определенных контейнеров.
  4) Рассмотрите возможность использования
     (https://secrets-store-csi-driver.sigs.k8s.io/concepts.html#provider-for-the-secrets-store-csi-driver)

[!] Дополнительные рекомендации по управлению и повышению безопасности ваших секретов см. в разделе:
    "Эффективные методы работы с секретами Kubernetes" (Good practices for Kubernetes Secrets) [4]

************************************
* Information security for Secrets *
************************************
(https://kubernetes.io/docs/concepts/configuration/secret/#information-security-for-secrets)

  Хотя ConfigMap и Secret работают одинаково, Kubernetes применяет ДОПОЛНИТЕЛЬНУЮ ЗАЩИТУ для объектов Secret.
  Секреты часто содержат значения, которые охватывают спектр важности, многие из которых могут вызвать эскалацию
  ➜ внутри Kubernetes (например, токены учетных записей служб)
  ➜ и во внешних системах.

  Даже если отдельное приложение может рассуждать о силе Secrets, с которыми ему предстоит взаимодействовать,
  другие приложения в том же namespace могут сделать эти предположения недействительными.

  Секрет отправляется на Node только в том случае, если он требуется Pod'у на этом Node.
  Для монтирования секретов в Pod kubelet сохраняет копию данных в tmpfs,
  чтобы конфиденциальные данные не записывались в долговременное хранилище (durable storage).
  Когда Pod, зависящий от Secret, удаляется, kubelet удаляет свою локальную копию конфиденциальных данных из Secret.

  В Pod может быть несколько контейнеров.
  По умолчанию контейнеры, которые вы определяете, имеют доступ только к учетной записи ServiceAccount по умолчанию и связанному с ней Secret.

  Чтобы предоставить доступ к любому другому секрету, необходимо
    ✓ явно определить переменные окружения
    <или>
    ✓ сопоставить том (map a volume) контейнеру.

  На одном Node могут существовать Secrets для нескольких Pod'ов.
  Однако только те секреты, которые запрашивает Pod, потенциально видны в его контейнерах.
(!) Поэтому один Pod не имеет доступа к секретам другого Pod

[!] Любые контейнеры, запущенные с `privileged: true` на Node, могут получить доступ ко всем секретам, используемым на этом Node.


**************************
* Использование секретов *
**************************

Вы можете использовать Secrets для следующих целей:
  ✓ установка переменных окружения для контейнера;
  ✓ предоставление учетных данных (таких как SSH-ключи или пароли) для Pod'ов;
  ✓ разрешение kubelet извлекать образы контейнеров из private registries.

Kubernetes control plane (плоскость управления Kubernetes) также использует Secrets;

[например:]
  секреты bootstrap token - это механизм, помогающий автоматизировать регистрацию узлов.


*************************
* Примеры использования *
*************************

[dotfiles in a secret volume]
(https://kubernetes.io/docs/concepts/configuration/secret/#use-case-dotfiles-in-a-secret-volume)


[Секрет, видимый для одного контейнера в Pod'е]
(https://kubernetes.io/docs/concepts/configuration/secret/#use-case-secret-visible-to-one-container-in-a-pod)


****************
* Типы Secrets *
****************

  При создании Secret вы можете указать его тип с помощью поля type: ресурса Secret
  или некоторых эквивалентных флагов командной строки kubectl (если они доступны).

  Тип Secret используется для облегчения программной работы с данными Secret.

  Kubernetes предоставляет несколько встроенных типов для некоторых распространенных сценариев использования.
  Эти типы различаются по выполняемым проверкам и ограничениям, которые Kubernetes накладывает на них.

Built-in Type                               Usage
Opaque                                      произвольные данные, определяемые пользователем (user-defined data)
kubernetes.io/service-account-token     	Токен ServiceAccount
kubernetes.io/dockercfg                 	сериализованный файл ~/.dockercfg
kubernetes.io/dockerconfigjson          	сериализованный файл ~/.docker/config.json
kubernetes.io/basic-auth                	учетные данные для базовой аутентификации
kubernetes.io/ssh-auth                      учетные данные для аутентификации SSH
kubernetes.io/tls                           данные для клиента или сервера TLS
bootstrap.kubernetes.io/token               bootstrap данные токена


Вы можете определить и использовать свой собственный тип Secret,
назначив непустую строку в качестве значения type: для объекта Secret
(!) (пустая строка рассматривается как тип Opaque).

[!] Kubernetes НЕ НАКЛАДЫВАЕТ НИКАКИХ ОГРАНИЧЕНИЙ НА ИМЯ ТИПА.
  Однако если вы используете один из встроенных типов, вы должны соответствовать всем требованиям, определенным для этого типа.

  Если вы определяете тип Secret, предназначенный для публичного использования,
  следуйте соглашению и структурируйте тип Secret так, чтобы перед именем стояло имя вашего домена, разделенное символом /.

[Например:]
cloud-hosting.example.net/cloud-api-credentials


******************
* Opaque Secrets *
******************

  Opaque - это тип Secret по умолчанию, если вы явно не указали тип в манифесте Secret.

[создании Secret с помощью kubectl:]
(!) вы должны использовать подкоманду generic для указания типа Opaque Secret.

Например, следующая команда создает пустой Secret типа Opaque:
--[CMD]--
kubectl create secret generic empty-secret
kubectl get secret empty-secret
##[OUTPUT:]##
NAME           TYPE     DATA   AGE
empty-secret   Opaque   0      2m6s
--***--

# Столбец DATA показывает количество элементов данных, хранящихся в Секрете.
# В данном случае 0 означает, что вы создали пустой секрет.


*******************************
* Basic authentication Secret *
*******************************

Тип kubernetes.io/basic-auth предназначен для хранения учетных данных, необходимых для базовой аутентификации.
При использовании этого типа Secret поле данных Secret должно содержать один из следующих двух ключей:
  username: the user name for authentication
  password: the password or token for authentication

Оба значения для двух вышеуказанных ключей представляют собой строки в кодировке base64.

В качестве альтернативы вы можете предоставить содержимое открытого текста,
(!) используя поле stringData в манифесте Secret.
Следующий манифест является примером базового секрета аутентификации:

---
apiVersion: v1
kind: Secret
metadata:
  name: secret-basic-auth
type: kubernetes.io/basic-auth
stringData:
  username: admin           # обязательное поле для kubernetes.io/basic-auth
  password: t0p-Secret      # required field for kubernetes.io/basic-auth

####

[!] Поле stringData для Secret НЕ ОЧЕНЬ ХОРОШО работает с приложениями НА СТОРОНЕ СЕРВЕРА.

[!] Тип Secret для базовой аутентификации предоставляется ТОЛЬКО ДЛЯ УДОБСТВА!
  Вы можете создать тип Opaque для учетных данных, используемых для базовой аутентификации.
  Однако использование определенного и общедоступного типа Secret (kubernetes.io/basic-auth)
    + поможет другим людям понять назначение вашего Secret   и
    + установит соглашение о том, какие имена ключей следует ожидать.


#############################################
# Managing Secrets using Configuration File #
#############################################
(https://kubernetes.io/docs/tasks/configmap-secret/managing-secret-using-config-file/)

#= Создание объектов Secret с помощью файла конфигурации ресурсов.

Можно сначала определить объект Secret в манифесте, в формате JSON или YAML,
      а затем создать этот объект.

Ресурс Secret содержит две карты (maps):
  * data
    -> поле используется для хранения произвольных данных, закодированных с помощью base64.
    <и>
  * stringData
    -> поле создано для удобства,
       позволяет предоставлять те же данные в виде некодированных строк

[!] Ключи data и stringData должны состоять из
    > буквенно-цифровых символов,
      `-` (\\тире),
      `_` (\\нижнее подчёркивание)    или
      . (\\точки)

[пример:]
  две строки хранятся в Secret с помощью поля data.

1) Преобразуем строки в base64:

--[CMD]--
echo -n 'admin' | base64
echo -n '1f2d1e2e67df' | base64
>--<

Примечание: Сериализованные JSON и YAML значения данных Secret кодируются как строки base64. Новые строки в этих строках недопустимы и должны быть опущены. При использовании утилиты base64 на Darwin/macOS пользователям следует избегать использования опции -b для разделения длинных строк. И наоборот, пользователям Linux следует добавлять опцию -w 0 к командам base64 или использовать конвейер base64 | tr -d '\n', если опция -w недоступна.

The output is similar to:

YWRtaW4=
MWYyZDFlMmU2N2Rm

2) Создадим манифест:

--<Manifest>--
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: YWRtaW4=
  password: MWYyZDFlMmU2N2Rm