Kubernetes Cluster Networking

[sources:]
1) "Cluster Networking": https://kubernetes.io/docs/concepts/cluster-administration/networking/
2) "Services, Load Balancing, and Networking": https://kubernetes.io/docs/concepts/services-networking/
3) "Kubernetes Networking: сервисы, Ingress и Network Policies": https://habr.com/ru/companies/T1Holding/articles/767056/


Четыре сетевые проблемы, которые необходимо решить:
  1. Коммуникации container-to-container (=между контейнерами) с высокой степенью связности (highly-coupled):
    => эта проблема решается с помощью связей Pod'ов и localhost.

  2. Коммуникации Pod-to-Pod (=между Pod'ами):
    => этот вопрос является основным в данном документе.

  3. Коммуникации Pod-to-Service (между Pod'ами и Service'ами):
    => этот вопрос решается с помощью Service'ов.

  4. Коммуникации External-to-Service (между внешними пользователями и Service'ами):
    => этот вопрос также решается с помощью сервисов.

Kubernetes - это совместное использование машин приложениями.

  Как правило, для совместного использования машин требуется обеспечить,
  чтобы два приложения не пытались использовать одни и те же порты.

Координировать порты между несколькими разработчиками
  - очень сложно в масштабе 
  - подвергает пользователей риску возникновения проблем на уровне кластера, которые они не могут контролировать.

Динамическое распределение портов вносит в систему множество сложностей:
  * каждое приложение должно принимать порты как флаги,
  * серверы API должны знать, как вставлять динамические номера портов в конфигурационные блоки,
  * service'ы должны знать, как найти друг друга,
  ...и так далее.

Вместо того чтобы разбираться с этим, Kubernetes использует другой подход.

# О сетевой модели Kubernetes читайте здесь: [2]


********************************
* Kubernetes IP address ranges *
********************************

  Кластеры Kubernetes должны выделять непересекающиеся IP-адреса для
    ✓ Pod'ов,
    ✓ Service'ов    и
    ✓ Nodes
  из ряда доступных адресов,
  настроенных в следующих компонентах:
    ● Сетевой плагин (network plugin) настроен на назначение IP-адресов Pod'ам.
    ● kube-apiserver настроен на назначение IP-адресов SERVICE'ам.
    ● The kubelet || the cloud-controller-manager настроены на назначение IP-адресов Node'ам.

****************************
* Cluster networking types *
****************************

Кластеры Kubernetes, в зависимости от настроенных семейств IP-адресов, можно разделить на категории:
  ● IPv4 only:
    = Сетевой плагин, kube-apiserver и kubelet/cloud-controller-manager настроены на назначение только IPv4-адресов

  ● IPv6 only:
    = Сетевой плагин, kube-apiserver и kubelet/cloud-controller-manager настроены на назначение только IPv6-адресов.

  ● IPv4/IPv6 или IPv6/IPv4 dual-stack:
    ○ network plugin настроен на назначение IPv4 и IPv6 адресов.
    ○ kube-apiserver настроен на назначение IPv4 и IPv6 адресов.
    ○ kubelet или cloud-controller-manager настроены на назначение IPv4 и IPv6 адресов.
    ○ Все компоненты должны согласовать конфигурацию основного семейства IP-адресов.


Кластеры Kubernetes учитывают только семейства IP-адресов, присутствующие на объектах
  ✓ Pods,
  ✓ Services
  ✓ и Nodes,
  независимо от существующих IP-адресов представленных объектов.

[Например:]
  сервер или Pod может иметь несколько IP-адресов на своих интерфейсах,
(!) но ТОЛЬКО IP-адреса в

-> node.status.addresses <-
          <или>
->    pod.status.ips    <-

учитываются при реализации сетевой модели Kubernetes и определении типа кластера.


*********************************************
* Как реализовать сетевую модель Kubernetes *
*********************************************

  Сетевая модель реализуется container runtime на каждой Node.
  Наиболее распространенные container runtimes используют плагины Container Network Interface (CNI) для управления сетью и возможностями безопасности.

  Существует множество различных плагинов CNI от разных производителей.
  Некоторые из них предоставляют только БАЗОВЫЕ ВОЗМОЖНОСТИ добавления и удаления сетевых интерфейсов,
  в то время как другие предлагают более сложные решения, такие как
    ✓ интеграция с другими системами оркестрации контейнеров,
    ✓ запуск нескольких CNI-плагинов,
    ✓ расширенные функции IPAM
    и т. д.

# Неполный список сетевых аддонов, поддерживаемых Kubernetes, приведен на этой странице:
#-> https://kubernetes.io/docs/concepts/cluster-administration/addons/#networking-and-network-policy


#>[2]<#

********************************
* The Kubernetes network model *
********************************

Сетевая модель Kubernetes состоит из нескольких частей:

  ✔ КАЖДЫЙ POD в кластере получает свой уникальный IP-адрес в масштабах всего кластера.
      ● у pod'а есть собственное частное сетевое пространство имен (namespace),
        которое разделяется всеми контейнерами внутри pod'а.

     [!] Процессы, запущенные в разных контейнерах одного pod'а,
         могут взаимодействовать друг с другом через localhost.

  ✔ Pod network (также называемая кластерной сетью, cluster network) управляет взаимодействием между pod'ами.
     Она гарантирует, что (за исключением преднамеренной сегментации сети):
      ● Все pod'ы могут взаимодействовать со всеми другими pod'ами,
        независимо от того, находятся ли они на одном Node или на разных Node'ах.

      ● Pod'ы могут взаимодействовать друг с другом НАПРЯМУЮ,
        без использования прокси-серверов или трансляции адресов (NAT).
        # В Windows это правило не применяется к host-network pods.

      ● Агенты на Node (например, системные демоны или kubelet) могут взаимодействовать со всеми pod'ами на этом Node.

  ✔ API Service позволяет вам предоставить стабильный (долгоживущий) IP-адрес или имя хоста для сервиса,
      реализуемого одним или несколькими внутренними pod'ами,
      при этом отдельные pod'ы, составляющие Service, могут меняться со временем.
      
      ● Kubernetes автоматически управляет объектами EndpointSlice для предоставления информации о pod'ах,
        которые в данный момент поддерживают Service.

      ● Реализация сервисного прокси отслеживает набор объектов Service и EndpointSlice
        и программирует плоскость данных (data plane) для маршрутизации трафика service к своим бэкендам,
        используя API операционной системы или облачного провайдера для перехвата или переписывания пакетов.

  ✔ Gateway API (или его предшественник Ingress) позволяет сделать Service'ы доступными для клиентов,
     находящихся за пределами кластера.
      ● Более простой, но менее настраиваемый механизм проникновения в кластер доступен через тип Service API:
        type: LoadBalancer
        если используется поддерживаемый облачный провайдер.

  ✔ NetworkPolicy - это встроенный Kubernetes API,
       который позволяет контролировать трафик между pod'ами или между pod'ами и внешним миром.


В старых контейнерных системах не было автоматического соединения между контейнерами на разных хостах,
поэтому часто требовалось явно создавать связи между контейнерами или сопоставлять порты контейнеров с портами хостов,
чтобы контейнеры на других хостах могли к ним обращаться.

В Kubernetes в этом нет необходимости; модель Kubernetes заключается в том, что с pod'ами можно обращаться так же,
как с виртуальными машинами или физическими хостами, с точки зрения
  ✓ распределения портов,
  ✓ именования,
  ✓ обнаружения сервисов,
  ✓ балансировки нагрузки,
  ✓ настройки приложений
  ✓ и миграции.

Только некоторые части этой модели реализуются самой Kubernetes.
(!) Для остальных частей Kubernetes определяет API,
    НО соответствующая функциональность обеспечивается внешними компонентами,
    некоторые из которых являются необязательными:

Настройка namespace'а сети Pod'ов выполняется программным обеспечением системного уровня (system-level software),
реализующим интерфейс Container Runtime Interface.


Сама сеть pod'ов управляется реализацией сети pod'ов (pod network implementation).

В Linux большинство контейнерных программ используют интерфейс Container Networking Interface (CNI) для взаимодействия с реализацией pod-сети,
поэтому такие реализации часто называют CNI-плагинами.

Kubernetes предоставляет стандартную реализацию проксирования сервисов, называемую kube-proxy,
но некоторые реализации pod-сетей вместо этого используют собственный прокси-сервис, который более тесно интегрирован с остальной частью реализации.

NetworkPolicy обычно также реализуется pod network implementation'ом.

(Некоторые более простые реализации pod-сети не реализуют NetworkPolicy,
или администратор может выбрать конфигурацию pod-сети без поддержки NetworkPolicy.
В этих случаях API все равно будет присутствовать, но не будет иметь никакого эффекта.)

Существует множество реализаций Gateway API (API-шлюза), некоторые из которых предназначены для конкретных облачных сред,
другие - для "bare metal" сред, а третьи - более общие.


What's next

В учебном пособии «Подключение приложений с помощью служб» (Connecting Applications with Services)
#->
вы узнаете о службах и сетевом взаимодействии Kubernetes на практическом примере.

В разделе «Сеть кластера» ("Cluster Networking")
#-> 
объясняется, как настроить сеть для вашего кластера,
а также дается обзор соответствующих технологий.
