Пять "столпов" Android. Технологии, лежащие в основе ОС

Список технологий:
	• виртуальная машина Java
	• система многозадачности
	• сервисы Google
	• IPC-механизм Binder
	• ядро Linux

Виртуальная машина Java
Настольная Java:
	Приложение на Java → промежуточный байткод → виртуальная машина (среда исполнения)

Ранние версии ВМ: интерпретация байткода (медленный метод исполнения)
JIT-компилятор (Just In Time compiler): ВМ может на лету конвертировать байткод в машинные инструкции
	"+" - существенно повысилась скорость исполнения
	"-" - повысился расход оперативной памяти
	     (необходимо хранить в памяти не только байткод, но и полученные из него машинные инструкции + метаданные для оптимизации)

Дизайн виртуальной машины:
	♦ стековый (самый простой и универсальный, использовался изначально)
	♦ регистровый  (более эффективный в скорости исполнения байткода и потреблении оперативной памяти)

Регистровая ВМ Dalvik: 
	* нетребовательная к оперативной памяти
	* быстрое исполнение приложений
	* применялась в превых версиях Android

[Исходные коды на Java (.java)] →<компилятор Java (javac)>→[Java Byte code (.class)] →<компилятор DEX>→ [Dalvik Byte code (.dex)] → [ВМ Dalvik (DVM)]

Android 2.2: Google реализовал JIT-компилятор
Android 5.0 Dalvik заменён на AOT-компилятор (Ahead Of Time Compiler) ART
В теории:    AOT-компилятор позволяет избавиться от ВМ как сущности, и переводить приложение в машинные инструкции ещё на этапе его установки
На практике: не весь байткод можно одним махом сконвертировать в инструкции процессора.
			 результирующий код = машинные инструкции + байткод Dalvik → разбирает всё это ВМ
			"-" - нет достаточной информации о поведении приложения и особенностях его работы
			"-" - замедление установки приложения и первого запуска ОС

Android 7.X: гибридный JIT/AOT-компилятор

Зачем использовать Java с его ВМ вместо того, чтобы использовать компилируемый язык (как поступили Apple)?
  1. Портабельность
	 • любое приложение, написанное на Java, будет точно работать любой полноценной JVM
	 • приложения, написанные под Android, не зависят от ОС, архитектуры процессора и т.п.
	 • разработчику не нужно задумываться о поддержке более эффективных инструкций, появившихся в новых процессорах,
	   за него это сделает JIT/AOT-компилятор

  2. Надёжность
	 • Java имеет garbage collector + 
	        не позволяет адресовать память напрямую + 
			не требует самостоятельного освобождения выделенной памяти
		→ многие типы атак (buffer overflow, use after free) не могут быть осуществлены на Android
		== Android менее уязвим (чем Apple, написанный до появления Swift)
	 • Большая популярность ЯП Java

---
Многозадачность

Можно запустить множество различных приложений, и все они будут оставаться в памяти и смогут работать в фоновом режиме
* Механизм lowmemorykiller (убивает наиболее редко используемые приложения в первую очередь)

* Wakelock - запрос к системе службы для получения последней ресурсов (память, процессорное время,...)

Android 6.x и далее: механизм Doze (перевод смартфона в энергосберегающий режим после нек-рого времени неактивности)

Android 8.0 - Запрет на работу фоновых служб (с двумя исключениями)

Android 9 - App Standby Bucket (дополняет Doze; разделяет все установленные на смартфоне приложения на категории по частоте использования)
	Категории:
		► Active		- используется в данный момент или использовалось недавно;
		► Working set	- часто используемые
		► Frequent		- регулярно используемые, но не обязательно ежедневно
		► Rare			- редко используемые
		► Never			- приложение установлено, но ни разу не запускалось
	
Ограничения, применяемые системой в зависимости от группы:
	• Jobs = ограничения на запуск фоновых задач
	• Alarm = ограничения на срабатывание таймеров
	• Доступность сетевых функций
	• Firebase Cloud Messaging (FCM) - доступность push-уведомлений
	если приложение добавлено в список исключений системы энергосбережения
		или
	если телефон находится на зарядке
	Приложение не будет урезано в правах
	
---

Binder
