Операционные системы

[00:04:47]	Операционная система в первую очередь предоставляет среду для исполнения приложений.
			Делает она это через свои библиотеки и свои системные вызовы (интерфейс системных вызовов).
	* Утилита strace
{ Операционная система в понимании Роберта Лава ("Ядро Linux. Описание процесса разработки", 3 издание. 2013 г.)
[стр.29]  В понятие 'операционная система' (ОС) входят:
			• ядро ОС и драйверы устройств;
			• системный загрузчик (boot loader);
			• командная оболочка или любой другой интерфейс пользователя;
			• базовая файловая система;
			• системные утилиты.
}

[00:05:40]	Какие существуют операционные системы:
	
	• Microsoft Windows
	• GNU Linux
	• MacOS
	• BSD → MacOS, IOS
	• Solaris
	• HP UX
	• WebOS
	• OS2 (E-station?)
	• Plan9
	• React OS (~ядро NT)
	• Kalibrix
	• AIX
	• QNX
	• DOS, FreeDOS
	• Symbian
	• Minix
	• Blackberry OS
	• Minuet OS
	• NeXTSTEP (от компании NeXT)
	
[00:09:40]
	Сколько ОС в телефоне?
	Как минимум, две: одна - ОС смартфона, одна - на SIM-карте (с экзоядром).

[00:10:30]	UNIX®
	
	1969г. (AT&T/Bell Labs: Томпсон, Керниган, Ритчи)
	Распространялась свободно
	Стандарт де-факто и де-юре (POSIX)
	POSIX = Portable Operating System Interface [for UniX]
	POSIX мобильна.
	AIX, Solaris, MacOS X/FreeBSD/NetBSD/OpenBSD - генетически UNIX®
	Linux, Minix - реализации
	
	У Minix была проблема с лицензией: она была не достаточно свободной.
	Можно было делать свои модификации, но нельзя было распространять модифицированные версии.
	Сначала Линуса Торвальдса не устроил эмулятор терминала Minix,
	→ затем он внёс исправления, чтобы появилась возможность загружаться с дискеты;
	→ потом понадобилась файловая система, совместимая с Minix;
	... в конце концов (в 1991 году) он обнаружил, что у него получилась ОС
	
	Есть реализации POSIX для Windows (в Windows можно доустановить POSIX-систему)
	UNIX - зарегистрированный товарный знак (торговая марка), поэтому стали использовать обозначение: *nix
	
[00:17:00] Вкратце о том, какие стандарты описаны в POSIX
		   
	Для того, чтобы программа могла исполняться, должно сохраняться следование стандарту.
	  ◘ библиотечный стандарт для языков C/C++ (STL)
	  ◘ другой вариант написать переносимую программу: написать её для некой среды исполнения.
	► Runtime (термин возник в связи с идеей при загрузке машины загружать в память набор необходимых библиотек)
	
	Среды исполнения:
	  • Shell
	  • Java
	  • Perl/Python (любой интерпретируемый язык программирования)

[00:18:05] Какие функции должна выполнять ОС
	
	Чего программы хотят от ОС:
		• абстракцию оборудования;
		• координацию совместной работы с устройствами;
		• изоляцию сбойных приложений;
		• обмен между приложениями.

[00:21:10] Как устроена ОС
	
	   [Пользователь]
		    ▲ ▼
	    [Приложение]
		    ▲ ▼
	[Операционная система]
		    ▲ ▼
	   [Оборудование]

	Существуют ОС с экзоядром, которые не обеспечивают изоляцию программ от оборудования.
	Например ОС в SIM-картах
	
[00:22:05]	Какие сервисы предлагает ОС?
			♦ Процессы
			♦ Память
			♦ Содержимое файлов (возможность работы с файлами)
			♦ Каталоги и имена файлов
			♦ Безопасность
			♦ ...(пользователи, IPC, сеть, терминалы)
			  IPC - взаимодействие между процессами

[00:24:30]	Как приложения обращаются к системе?
			ABI - syscalls		# Системные вызовы
	# Параметры ниже передаются через регистры
	mov edx,len										# Загрузить в регистр edx [*1] (32-разрядный) длину сообщения
	mov ecx,msg										# Загрузить в регистр ecx [*2] адрес сообщения
	mov ebx,1		;file descriptor (stdout)		# ebx - Регистр, указывающий, в какой файл будет производиться запись [*3]
	mov eax,4		;system call number (sys_write)	# Загрузить в регистр eax [*4] номер системного вызова
	int    0x80		;call kernel					# команда процессора на программное прерывание
	mov    eax,1	;system call number				# Записать в регистр eax код завершения
	(sys_exit)
	int    0x80		;call kernel
	section  .data
	    'Hello, world!' ,0xa
	
	[*1] edx - регистр данных для вычисления
	[*2] ecx - регистр счётчика
	[*3] в системах UNIX 0 = стандартный вход (STDIN), 1 = стандартный выход (STDOUT)
		 ebx - база для смещения при адресации внутри, например, массива
	[*4] eax - расширенный (32-разрядный) регистр-аккумулятор, куда заносятся вычисления
	
	В рамках процессоров Intel и совместимых с ними системные вызововы - это, как правило, прерывания
	В ОС Windows это прерывание 2e (16x-запись)
	int = на время запретить другие прерывания и произвести вызов ОС
	nasm - команда ассемблирования
	После процедуры ассемблирования получается файл filename.o - это объектный файл, не годится для выполнения
	gdb - отладчик, под ним можно запускать программы
	
[00:31:50]	Что плохо в этом примере?
	
	▲ Так не пишут.
	
	Другой пример написания:
	
	int main(){
		__asm__(
			"movl $20, %eax	    \n"			# $20 = загрузить константу
			"call *%gs:0x10    \n"
			"movl %eax, pid    \n"
		);
		printf("pid is %d\n", pid);
		return 0;
	}
	Сейчас не используется прерывание int 80;
	Используют sysenter и sysexit
	
	Классический Linux использует для загрузки пакет initscripts
	В нём есть конфигурационный файл /etc/inittab
		→ id:5:initdefault (5 = уровень демона init, соответствующий запуску графической оболочки)
		Уровень демона init = 5 в Linux используется регистрационными процессами X Windows
	
[00:37:00]	Как понять, что происходит при работе программы?

	Утилита strace
	
	$ strace [опции] команда [аргументы]
	
	Она показывает каждый системный вызов, который делает программа
	$ strace ./program_name
	strace позволяет, не имея исходников, методом "чёроного ящика" посмотреть, в каком месте программа прекращает работу.
	strace -f		-f = follow_forks, следовать за потомками - отслеживать дочерние процессы.
	strace -e		[-e] позволяет фильтровать по искомому значению.
	
	$ strace -f -e open sh		найти все open в выводе утилиты
	
	Системные вызовы
		• fork - создание нового дочернего процесса;
		• read - попытка читать из файлового дескриптора;
		• write - попытка записи в файловый дескриптор;
		• open - открыть файл для чтения или записи;
		• close - закрыть файл после чтения или записи;
		• chdir - изменить текущую директорию;
		• execve - выполнить исполняемый файл;
		• stat - получить информацию о файле;
		• mknod - создать специальный файл, например, файл устройства или сокет;

	
	Утилита ltrace
		- посмотреть библиотечные вызовы
	
[00:44:22]	Shell: /bin/*sh (программная оболочка)
	* Интерпретатор команд *nix
	
	while (1) {						# вечный цикл
		write (1, "$", 2);			# запись на STDOUT (1)
		readcmd (cmd, args);	// parse user input
		if ((pid = fork()) == 0) {  // child?	# ключевой вызов в UNIX [*]
			exec (cmd, args, 0);				# дочерний процесс выполняет заданную команду (exec)
		} else if (pid > 0) {  // parent?
			wait (0);		   //wait for child to terminate	# родительский процесс должен ждать (если потомок создан и pid>0)
		} else {				# если не произошло ни того, ни другого, дать сообщение об ошибке.
			perror ("fork");	# стандартная функция, знает все коды ошибок, может их напечатать
		}
	}
	
	[*] процесс в памяти разделяется на два идентичных экземпляра, различающихся кодом возврата функции.
		у дочернего процесса код возврата = 0 (при успешном выполнении)
		у родительского процесса код возврата = 
			- код ошибки, если не был создан дочерний процесс;
			- PID дочернего процесса

[00:46:35] Что делает код:
	
	Системные вызовы:
		• read
		• write
		• fork
		• exec
		• wait
	Соглашения:
		- при ошибке код возврата -1
		- код ошибки заносится в errno						# переменная в библиотеке
		- функция perror выводит сообщение об ошибке errno
	
[00:46:57]  Вызов: fork
	(Клонирует процесс в памяти)
	Создаёт потомка, точную копию вызвавшего процесса, и возвращает управление родителю и потомку
	У родителя и потомка совпадают:
		- память процесса (код, данные, стек)
		- атрибуты процесса: владелец, права, контекст
	Отличаются:
		- PID
		- Код возврата при успешном fork
			♦ у потомка 0
			♦ у родителя PID потомка
	
	# В UNIX предполагалось, что каждый процесс - это единица исполнения.
	# Если нужно выполнить что-то параллельно, создаётся ещё один процесс.
	# Но в целях экономии ресурсов создают дополнительную нить (поток) - pthread;
	# у процесса может быть несколько нитей (потоков).
	# Если нитей было несколько, то дочерний процесс будет иметь только ОДНУ нить.
	Поэтому создали новый метод clone (похожий на fork)
	clone - функция-заглушка в библиотеке, делает системный вызов, который ведёт себя точно так же, как fork.
	clone в зависимости от заданных параметров может
		► сохранять для дочернего процесса все нити;
		► оставлять дочернему процессу только одну нить (как fork)
	(подробнее о функциях fork() и clone(): https://it.wikireading.ru/1736)
	
[00:49:00]	Вызов: exec

	После fork ОС, такая как Linux и UNIX, выполняет exec.
	exec замещает содержимое памяти вызвавшего процесса инструкциями и данными из файла на диске,
		то есть исполняет файл.
	Процесс остаётся тем же = сохраняет PID, UID, ...
	
[00:51:53]  Вызов: wait
	
	Ожидает завершения одного из потомков
	  Зачем? Что будет, если потомок заветшится раньше wait?
	  ▬ Получится процесс-"зомби".
	  "Зомби" - это процесс, память от которого освобождена, но осталась запись о нём в таблице процессов
				(памяти он не занимает, а запись в таблице есть)
	  В строчке в таблице процессов содержится код возврата
	  Если родительский процесс аварийно завершается, то 
	    • дочерний процесс "осиротеет",
		•• его унаследует первый процесс init
	  
[00:52:54]  Почему fork/exec разделены?
	
	1. Как ls узнает текущий каталог, (stdin, stdout)?
		- Наследует cwd и открытые файлы от родителя:
		т.к. она наследует открытые файлы, она наследует в т.ч. атрибут процесса: текущий каталог;
		текущий каталог получается таким же, как у родителя;
		♦ первым вызовом fork происходит наследование всего
		♦ вызовом exec замещается код процесса, который должен исполняться

	2. Технология UNIX/Linux Copy-on-write (копирование по записи) делает fork очень быстрым
	   Операция клонирования фактически не копирует память, 
	   а назначает одни и те же участки памяти двум процессам сразу через механизм виртуальной памяти.
	   fork - это очень быстрый вызов.
	*[Подробнее о технологии copy-on-write (COW):
		Суть: дубликаты ресурсов создаются только тогда, когда в эти ресурсы осуществляется запись,
		      а до того момента они используются совместно в режиме только для чтения (read-only).
		COW позволяет отложить или вообще предотвратить копирование данных.
		Попытка записи в отображённые страницы  →  исключение  →  передача управления в ядро
		
		• родительский и дочерний процессы могут совместно использовать одну и ту же копию адресного пространства;
		• при этом данные помечаются особым образом (read-only);
		• при попытке одним из процессов изменить данные создается дубликат данных → каждый процесс получает уникальную копию данных
		
		Пример: fork() → exec()
		  При вызове exec() сразу же после fork() в страницы памяти никогда не делается запись.
		  Эти страницы никогда не копируются. Поэтому вызов fork очень быстрый.
		  Единственные накладные расходы от вызова функции fork():
		    + копирование таблиц страниц родительского процесса,
			+ создание дескриптора дочернего процесса.
	]
	   
[00:54:17]  Вызоы: read/write
	
	Аргументы:
		- номер файла;
		- указатель на буфер;		# где строка, которую нужно прочитать/в которую нужно записать
		- число байтов
	Возвращает число байтов
	
[00:54:36]  Организация ОС: традиционный подход
	
	ОС производит абстракцию оборудования следующим образом:
	Виртуализуется часть ресурсов
		- ЦПУ			# процесс "думает", что он монопольно владеет всем процессорным временем
		- память		# процесс "думает", что вся память в его распоряжении
						# он делает всё, что хочет, по своим адресам памяти
	
	Каждое приложение "монопольно" ими распоряжается
	
	Зачем?
		- Так проще писать приложения
		*nix, Windows NT

[00:55:55]	Пример: виртуализация ЦПУ

	Цель: эмулировать отдельный ЦПУ для каждого процесса
		- Переключение ЦПУ прозрачно
		- Процессу не нужно беспокоиться о других процессах
		
	ОС выполняет процессы по очереди до прерывания по таймеру.
	Таймер позволяет процессу не беспокоиться о переключениях.
	
	# Как правило прерывания происходят по таймеру 
	(когда ОС должна остановить исполнение одного процесса и "отдать" процессор другому процессу)
	Периодически "просыпается" по аппаратному генератору сигналов в процессоре и принимает решение: нужно отобрать или нет
	За это отвечает специальная нить (поток) в ядре, которая называется Планировщик (Scheduler).

[00:56:20]  Как происходит переключение между процессами?
	
	- ОС сохраняет и восстанавливает состояние (контекст) ЦПУ при каждом переключении
	Что сохраняется (что входит в контекст приложения)?
		• Регистры (eax, ebx, ecx...),
		• флаги состояния,
		• указатели на таблицы виртуальной памяти
	
	Где сохраняется?
		- В таблице процессов
	
	Прерывание таймера приводит к переключению на другой процесс

[00:57:12]  Как можно посмотреть за происходящим?
	
	1. vmstat
		без аргументов выводит одну строку
		|cs| - переключение контекста в секунду (среднее значение)
		(см. man)
		Последние 2 строки:
		voluntary_ctxt_switches (добровольное переключение контекста): процесс совершил системный вызов и отдал ресурсы.
		nonvoluntary_ctxt_switches (недобровольное переключение контекста): прервано ОС
	
	2. ps [aux, -e]  - снимок состояния процессов
	
[01:02:05]  Виртуализация памяти
	
	Идея: для процессора доступно:
		- всё адресное пространство 2^32
		- оно ссылается на его "частную память"
	
	Физическая память одна. Но поскольку все процессы изолированы друг от друга
	(каждый процесс находится в своём адресном пространстве), каждый процесс считает, что он находится в оперативной памяти один.
		+ Удобно
		+ Безопасно
		
	В 32-битных ОС процесс получает в своё распоряжение не все 4 ГБ (из 4), а меньше,
	поскольку часть памяти выделяется ядру (для хранения структур).

[01:03:00]  Варианты виртуализации памяти
	
	► Вытеснение процесса на диск при переключении
		- медленно
		- имело смысл в 90-х
		
	► Использование сегментов x86
		- переключать сегменты CS, DS на разные адреса
		- фрагментация памяти
		
	► Применить страничный механизм ЦПУ
	  [Всё адресное пространство разбивается на блоки по 4К = страницы памяти]
		- таблица физических адресов каждого 4К блока - страницы памяти
		- это таблица страниц
		- страницы можно помечать недействительными и переносить в подкачку - на диск
		- при обращении к такой странице возникает прерывание, и страницу можно загрузить обратно
		- copy-on-write - избавить fork от копирования памяти
	
	Команды:
		$ swapon -s
		
		$ free
		
[01:05:12]  Подходы к построению систем

	♦ Монолитное ядро
	♦ Гибридное (модульное) ядро
	♦ Микроядро <Minix>
	♦ Экзоядро (программа имеет прямой доступ к оборудованию, часть функционала она реализует сама)
	
[01:05:55]  Планирование процессорного времени
	
	* Многозадачность:
		• Кооперативная (Windows 3.1, Mac OS 9, WOW16 = 16-разрядная)
		• Вытесняющая (preemptive)		# ОС умеет "силой" отбирать процессорное время
	
[01:06:24]  Планирование процессорного времени  (I)

	Долгосрочное
		• batch (при невысокой нагрузке на процессор; команды выполняются в порядке очереди)
	Среднесрочное
		- BSD: выгрузка в подкачку неактивных процессов
		- Android: завершение задач при нехватке памяти (процессу даётся шанс сохранить своё состояние)
	Краткосрочное
		- Планировщик ЦПУ в ядре
	
[01:07:20]  Алгоритмы планировщика ЦПУ
	
	• FIFO/FCFS
	• SJF (Shortest Job First)
	• Приоритетное планирование (OCPB)
	• Round-Robin
	• Многоуровневые очереди с обратной связью
		► CFQ
	
[01:07:37]  Управление памятью  (II)
	
	• Распределение
	• Защита
	• Разделение (sharing)		# = совместное использование памяти несколькими процессами (например СУБД: память+кэш)
	• Логическая организация (сегменты)
	• Физическая организация (подкачка)

[01:08:16]  Планирование ввода-вывода (III)
	
	Цели:
		- сократить время поиска диском
		- приоритезировать ввод-вывод
		- разделить полосу пропускания устройства между процессами
		- гарантировать исполнение запросов не позднее крайнего срока
	
	Сначала данные пишутся в буферный кэш HDD, далее принимается решение, какие данные должны быть записаны на HDD
	
	В Linux можно выбирать алгоритм планирования, который будет использоваться системой.
	Реализации:
		• случайное планирование (RSS)
		• FIFO/FCFS
		• LIFO
		• CFQ (* Completely Fair Queuing - "справедливый" планировщик)
		• SCAN (лифт)
		• Noop (FIFO с объединением) [для виртуальной машины] == отдать планирование VM
		• Anticipatory (упреждающий)
		• Deadline [для баз данных](отдаёт весь ввод-вывод конкретному процессу, затем отнимает у него и отдаёт следующему)
	
[01:10:06]  Управление памятью

	Кэш-буфер
	Промахи страниц (процесс обратился по адресу к памяти, а её там нет. ОС обрабатывает это как промах)
		- жёсткие (если данные уже на диске)
		- мягкие (если данные ещё в кэше)
	
	Алгоритмы виртуальной памяти
		- LRU
		- Опережающая подгрузка
		- ...
	
[01:10:45]  Производительность в числах
	(Когда это может быть важно?)
	(см. скриншот)
	Например, 
		обращение к кэшу L1 процессора занимает 0,5 нс
		обращение к кэшу L2 процессора занимает 7 нс
		обращение к основной памяти:  100 нс

[01:12:26]  Примеры
	
	Чем плох системный вызов int?
		► int занимает 			>> 400 нс
		► sysenter занимает 	400 нс
		
		* переключение контекста: 3000 нс
	
	Для вызова fork() [клонирование процессов памяти]:
		• statically-linked binary   -   70000 мс
		• dynamically-linked binary  -  160000 мс
	
	*statically-linked binary - процесс, который клонирует fork(), статически связан со всеми своими библиотеками, 
								и не нужно никакие библиотеки переинициализировать.
	
[01:14:11]  batch

	Если есть несколько задач, которые выполняются долго (условно поставили на ночь), для этого есть задачи планировщика.
	Команда batch
	atq - отобразить список задач (в момент, когда выполняется batch)
	Решение о выполнении задачи принимается РАЗ В МИНУТУ

	* Когда средняя загрузка системы [load average] падает ниже 1.5, задача выполняется
	Средняя загрузка считается исходя из количества процессов в состоянии R
	R (ready) - процесс готов к исполнению, готов потреблять процессорное время.
	Число load average = число процессов в очереди.
	Содержит 3 числа.
	Пример простейшей команды с бесконечным циклом:
		$ sh -c 'while true ; do true ; done'&	# & - исполнить в фоновом режиме
	равносильно:
		$ sh -c 'while : ; do : ; done'&
	
	kill - системный вызов в ядре; получает в качестве параметров [№ процесса] и [№ сигнала]
	
[01:30:00]  Про планирование процессорного времени

	Алгоритмы планирования:
		• FIFO/FCFS (First In First Out/First Come First Served)
		• SJF (Shortest Job First)
		• Приоритетное планирование (ОСРВ)
		• Round-Robin
		• Многоуровневые очереди с обратной связью
			•• CFQ

	FIFO/FCFS
	    тривиальный алгоритм.
		Планировщик просто ставит процессы в очередь. Когда очередной процесс вернул управление (или другой процесс отобрал управление),
		планировщик передаёт управление следующему.
		Может выделять время квантами, указывая, сколько максимально процесс может выполняться без прерывания.
		
	SJF (Shortest Job First)
		На тот случай, если планировщик может предсказать, сколько времени займёт исполнение процесса.
		На вскидку этого сделать не может, но оценивает по syscalls и др.
	
	Приоритетное планирование (ОСРВ [RTOS] - операционная система реального времени)
		Не обязательно ОСРВ.
		У процесса может быть жёстко указан приоритет, и если есть нить/процесс, имеющий больший приоритет,
		то он исполняется в первую очередь.
		
	Round-Robin ("Карусель")
		обслуживает (выполняет) процессы по очереди, пытаясь отдавать каждому из них одинаковое количество времени.
	
	Многоуровневые очереди с обратной связью
		
		- это то, что делает на самом деле современное ядро Linux или Windows
		Многоуровневость заключается в том, что процессы классифицируются (например, по времени исполнения между прерываниями).
		Планировщик распределяет процессы в разные очереди и каждую очередь обрабатывает отдельно.
		Процесс может иметь атрибуты (что это процесс не итнерактивный), значит его приоритет не очень высок.
	
[01:34:00]	Защита памяти
	
	Суть: не вся память должна быть доступна по записи.
	Не всегда нужно, чтобы запущенный процесс имел возможность писать в те адреса памяти, где у него находятся исполняемые инструкции
	(модифицировать свой код на ходу).
	Служебная файловая система proc (для каждого процесса в ней есть свой подкаталог)
	proc - не настоящая ФС. Файлов в подкаталогах proc/ на самом деле нет на диске.
		$ cat /proc/self/[первая буква в названии файлов]		# открыть для просмотра процесс cat (self = самого себя)
		В подкаталогах есть квази-файлы = представление в виде файлов информации о ядре, о том, как оно распорядилось памятью.
		В файле указана доступность памяти для чтения/записи, возможность использования памяти другими процессами.
		Пример:
			[адрес памяти]  r--s 00000000  08:03 5898326    /
			r - память по указанному адресу доступна для чтения
			- = не доступна для записи
			- = не доступна для выполнения
			s - (shared) память может быть использована другими процессами (адрес будет спроецирован в адресное пространство другого процесса)
	
[01:38:04]	Алгоритмы планировщика
	
	
	
[ ++
	Автоматизация задач:
	Команды:
		cron - используется для назначения повторяющихся задач
		at - используется для назначения одноразового задания на заданное время	
			# at time - назначить выполнение разового задания; time - время выполнения команды.
		batch - для назначения одноразовых задач, которые должны выполняться, когда средняя загрузка системы
		        падает ниже
				  0.8 (https://linux.die.net/man/1/batch) - RHEL
				  1.5 (http://manpages.ubuntu.com/manpages/bionic/man1/at.1.html) - Ubuntu
				или значения, указанного при вызове atd
		atq - посмотреть запланированные задания (для at и batch)
		
	Что необходимо, чтобы использовать at и batch:
		• должен быть установлени RPM-пакет at
		• должна быть запущена служба atd    (/sbin/service atd start)
		
	RPM Package Manager - формат пакетов программного обеспечения, а также программа, созданная для управления этими пакетами,
						  используемые в ряде Linux-дистрибутивов (изначально в Red Hat Linux)
]

{ Команда at
	- используется для назначения одноразового задания на заданное время;
	$ at <time>
	<time> - время выполнения команды
	Возможные значения параметра time:
		    формат ЧЧ:ММ — например, 04:00 обозначает четыре часа ночи. Если указанное время уже прошло, задание выполняется в это же время на следующий день.

			♦ midnight — полночь.
			♦ noon —  полдень.
			♦ teatime —  4 часа дня (время чаепития).
			формат «название-месяца день год» — например, строка «January 15 2002» обозначает 15 января 2002 года. Указывать год не обязательно.
			Форматы ММДДГГ, ММ/ДД/ГГ или ММ.ДД.ГГ — например, 011502 также обозначает 15 января 2002 г.

			now + время — время задаётся в минутах, часах, днях или неделях. Например, строка «now + 5 days» обозначает, что команда должна быть выполнена в это же время, но через пять дней.
		Сначала должно буть указано время, а за ним можно указать необязательную дату. За дополнительной информацией о формате времени, обратитесь к текстовому файлу /usr/share/doc/at-<version>/timespec
		
	После ввода команды at с аргументом, указывающим время, выводится приглашение:
	at>
	► Далее ввести команду(ы), которые планируется выполнить
	► Enter (перейти на пустую строку)
	► Ctrl + D		# выйти из > at
	
	$ atq - посмотреть запланированные задания
}