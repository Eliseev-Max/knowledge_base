ОС GNU/Linux
Устройство и функционирование

	- *nix, BSD и GNU
	- загрузка
	- состав
	- дистрибутивы

GNU появился раньше всех перечисленных выше систем
	Minix
	▼
	386BSD
	▼
	Linux
	
Линус Торвальдс не знал о появлении 386BSD
comp.os.minix

Каким был загрузчик первой версии Linux?
	Загрузчика не было.
	Команда file определяет по содержимому файла, что это за файл.
	/boot/(бинарные файлы ядра Linux)
	
	hexdump -C -n[количество байт]	- вывод в каноническом виде в шестнадцатеричной системе содержимого.
	Ядро Linux загружало само себя.
	Ядро записывалось на дискету (с нулевого смещения),
	содержало встроенный в себя загрузчик
	и загружало само себя
	
	Торвальдса не устраивал эхмулятор терминала Minix, поэтому он написал свой.
	Ядро стало больше и уже не влезало на дискету (1,44 Мб), загрузку с дискеты убрали.
	
	Самые популярные загрузчики:
		• GRUB v1/v2
		• LILO
		• syslinux /
		•• pxeLinux (Preboot Execution Environment) - загрузка по сети /
		•• ISOLinux - загрузчик с компакт-диска/DVD
		• uBoot
	
[00:21:43]  Существенное отличие GRUB и LILO (в пользу GRUB)
	
	Конфигурация загрузчика:
		/boot/grub/grub.cfg
		/boot/grub/menu.lst
		/etc/lilo.conf
		syslinux.cfg
	
	Если мы совершили ошибку и забыли запустить команду lilo перед перезагрузкой,
	когда внесли изменения в конфигурационный файл lilo.conf, то ничего не произойдёт:
	загрузка будет происходить со старыми параметрами. (если при этом удалить старое ядро,
	то старые параметры будут использоваться для загрузки нового ядра. Могут возникнуть сложности).
	У GRUB первые 2 файла (оба названия конфигурационного файла) на командном языке загрузчика исполняется каждый раз при старте.
	Нет опасности внести изменения и забыть "сказать об этом" загрузчику.
	
	GUID/UUID уникальный идентификатор файловой системы (он не повторяется).
	Команда uuidgen - генератор UUID
	
	Распечатать) содержимое суперблока:
	$ sudo tune2fs -l /dev/sda
	или
	$ sudo tune2fs -l /dev/sda2
	Возможный вариант вывода команды:
	  Bad magic number in super-block while trying to open /dev/sda2
	  Couldn't find valid filesystem superblock.
	действует аналогично утилите file (смотрит в начало файла и пытается определить, что это за файл, по структуре и содержимому первых строк)
	
[00:31:36]  Ядро Linux

{  Тезисы из книги Роберта Лава "Ядро Linux. Описание процесса разработки"...
	синонимы ядра ОС:
	  • супервизор (supervisor);
	  • основная часть ОС (core);
	  • внутренности ОС (internals)
	
	Типичные компоненты ядра ОС:
	  ♦ обработчики прерываний → обслуживают запросы на прерывания, поступающие от различных устройств;
	  ♦ планировщик  → распределяет процессорное время между многими процессами;
	  ♦ система управления памятью → управляет адресным пространством процессов;
	  ♦ системные службы (сетевая подсистема, подсистема межпроцессного взаимодействия)
	
	kernel-space (пространство ядра, привелегированный режим) = 
	  = системные переменные (system state) + область памяти, в которой находится ядро
}
	
	Гибридное: драйверы дисковых и фаловых подсистем загружаются модулями.
	Модули можно подгружать, когда они нужны, и выгружать, когда уже не нужны.
	Модули - файлы в директории /lib/modules/
	
	Разработчики Linux НЕ РЕКОМЕНДУЮТ пересобирать ядро.
	
	Команда lsmod
	Можно поискать в её выводе наличие определённой ФС:
		$ lsmod |grep ext
	
	Файловая система ext включена в некоторых дистрибутивах в состав ядра.
	
[00:36:55]  Как происходит загрузка ядра? (Как работает bootstrapping?)
	Загрузчик загрузил в память ядро и передал ему управление.
	Термин bootstrapping появился ещё до создания компьютеров.
	Означает примерно "компьютер сам себя загрузил"
	Ядро одно, а компьютеры разные. Необходимо сконфигурировать ядро перед его загрузкой.
	
	Как настроить ядро до его запуска?
	Параметрами!
	С точки зрения настройки ядро не сильно отличается от программных утилит, запускаемых через командную строку.
	Ядро получает командную строку (и даже в Windows)
	д
	Параметры:
		BOOT_IMAGE = (путь до архива ядра). Внесён загрузчиком.
		root=... - сообщает ядру, с какой файловой системой придётся иметь дело (указывает корневую файловую систему)
		root - очень важный параметр.
		# команда blkid
		crash_kernel - указывает место, куда помещается копия ядра. Дамп памяти ядра.
		quiet - не выводить информацию, кроме сообщений об ошибке
		splash - всплывающий графический экран при загрузке
	
	/var/log/dmesg - файл, содержащий сообщения, которые ядро должно выводить на консоль (но могло не выводить)
	
[00:45:50]  Как настроить ядро после запуска?
	
	У ядра есть переменные, влияющие на его поведение.
	Утилита sysctl
	Переменных у ядра больше 1000.
	Пример переменной: net.ipv4.ip_forward
	sysctl -w net.ipv4.ip_forward = 1
	Часто приводится в качестве примера при использовании виртуальных машин (настройка маршрутизации).
	
	Если не предполагается перезагружаться, изменить значение переменной можно с помощью файлового интерфейса /proc/
	$ echo 1 | sudo tee /proc/sys/net/ipv4/ip_forward
	? Почему используется такая синтаксическая конструкция, а не 
		$ sudo echo 1 > /proc/sys/net/ipv4/ip_forward
	Потому что в команде выше повышение привилегий происходит позже, чем перенаправление вывода в файл.
	Пеернаправление вывода в файл происходит от текущего пользователя, а команда echo выполняется от суперпользователя.
	В итоге имеем недостаток прав доступа.
	/etc/sysctl.conf
	Применить изменения в отредактированном конфигурационном файле (перепрочесть):
		$ sudo sysctl -p
	
	<Поиск в конфигурационном файле при помощи grep>:
	$ grep -v ^# /etc/sysctl.conf
	-v = пропустить строки, которые совпадают в шаблоне
	^# - (регулярные выражения) - начиная с #
	$ grep -v ^#.*ip_forward /etc/sysctl.conf
	
	Параметр kernel.panic  (ситуация, когда ядро не знает, что делать дальше)
	По умолчанию kernel.panic = 0 		# остановиться и ничего не предпринимать
	Документация ядра: Magic SRQ (возможность перезагрузиться)
	Если установить значение kernel.panic =[>0] (число больше 0), ПК перезагрузится через это число секунд.
	Если kernel.panic <0 → panic_blink() - мигание лампочками клавиатуры.
	
	4 значения kernel.panic:
		kernel.panic = 0
		kernel.panic_on_oops = 0
		kernel.panic_on_unrecovered_nmi = 0
		kernel.panic_on_io_nmi = 0
	
	Команда more в отличие от команды less не умеет читать назад в потоке (если вывод передан ей через пайп | )
	
[01:10:25]  Как появляются новые процессы
	
	Новые процессы появляются с помощью одной функции без параметров: функции fork()
	[Усовершенствование] → Заменена на clone
	[Усовершенствование] → Заменена на clone2
	
[01:11:15]  Откуда появляется init?
	Ядро создаёт служебные процессы (указаны в [] в выводе ps aux)
		init (/sbin/init); PID = 1 - первый процесс
		Значение памяти процессов, созданных ядром = 0 означает,
		что память в пользовательском режиме не потребляется этими процессами
		вся память = память ядра
	
	Linux: init/main.c
		
		if (execute_command) {							# Если переменная execute_command определена,
			run_init_process(execute_command);			# выполняется блок внутри if
			printk(KERN_WARNING "Failed to execute ls."
			"Attempting defaults...\n",
			execute_command);
		}												# Иначе выполняются ▼
		run_init_process("/sbin/init");					# 
		run_init_process("/etc/init");					# Если не был найден /sbin/init, выполняется ←
		run_init_process("/bin/init");					# Если не был найден /etc/init, (чего обычно не может быть), выполняется ←
		run_init_process("/bin/sh");					# Если не был найден исполняемый файл init, запустить командную оболочку
		
		panic("No init found.  Try passing init= option	# Если даже оболочки не нашлось.
		to kernel. "
		"See Linux Documentation/init.txt for guidance.");
	
	* Почему рекомендация "Try passing init= option to kernel" очень спорная?
		В нормальной корневой файловой системе (ФС) /bin/sh гарантированно должен находиться.
		Если в корневой ФС не обнаружено ни init, ни /bin/sh, значит это другая корневая ФС.
		Соответственно, поменять ФС можно параметром root= , но не init=.
	Рекомендацию придумали разработчики, главным образом для себя.
	Секция (execute_command) появляется, если ядро получило параметр init=...
	Ядро получает параметр, например, root= /dev/sda3 и, например, init=/bin/sh
	init=/bin/sh является угрозой безопасности, так как пользователь сразу же 
	получает командную строку с правами суперпользователя.
	!!! Особенность: если пользователь при этом сделает выход из shell, для ядра это будет нештатная ситуация.
	[Выход из /bin/sh при условии init=/bin/sh] → = попытка убить init → kernel panic, останов.
	Перезагрузиться можно с помощью команды: reboot -f (=принудительная перезагрузка)
	Команда reboot [без параметров] не поможет, т.к. она предполагает, что init есть.
	init при этом не задействуется, т.к. sh не закрывается.
	
	Посмотреть процесс init, а именно файлы, открытые у init:	
		$ sudo ls /proc/1/fd -l
	У "нового" init (from upstart) открыты сокеты + он следит за содержанием каталогов.
	Если в каталогах что-то появляется, то он это обработает.
	Есть более простые init, которые слушают не сокет, а пайп и файл устройства /dev/initctl
		
[01:18:18]  Что будет делать init?
	Это зависит от того, какой это init
	(слушать сокет || слушать пайп || имеет свои конфигурационные файлы)
	
	$ dpkg -S /sbin/init||rpm -qf /sbin/init		# проверяет, к какому пакету относится init
	- универсальная команда для реализации Linux Debian или RedHat

[01:19:40]  Варианты init
	BSD-стиль		# если это система не Linux или Linux, в котором реализован стиль BSD
		- /etc/rc&&/etc/rc.d&&/etc/rc.local
		# один сценарий rc		(# run command/run config)
		# rc.d создали, чтобы разбивать на части один большой сценарий, не исправлять каждый раз, а добавлять новые сценарии.
		# rc.local - файл, специфический для конкретной машины, в котором при загрузке выполняются некоторые дополнительные команды.
		# создан, чтобы избежать частых исправлений осн.файла и, как следствие, снизить вероятность ошибок
		# по сути rc.local - это shell-скрипт, по умолчанию завершающийся всегда с кодом 0
		# прочитать содержание файла: $ cat /etc/rc.local
			
	SysV-стиль		# используется большинством UNIX-систем (Linux-систем), 5-ая версия UNIX
		- sysvinit: /etc/inittab&&/etc/rc[0-9].d/&&/etc/rc.local
		- upstart: /etc/init/*.conf					  # мощный, но запутанный [§], чем initscripts
		- systemd: /etc/system.conf&&/etc/user.conf	  # реализации Fedora и, возможно, MacOS
	
	Если имеем дело с sysvinit: 
		• выполняется чтение конфигурационного файла inittab
		• в файле находится строка, которая управляет загрузкой
			id:5:initdefault → rc5.d	# 5 - регистрационные процессы X Windows (GUI)
	
[01:23:31]	[§] В чём "мощность" upstart?
	    Он постоянно следит за списком своих конфигурационных файлов, находящихся в каталоге /etc/init/
		Из списка .conf-файлов он отслеживает различные события (появление/завершение, появление link на сетевом интерфейсе)
		
	Рассмотрим один из конфигурационных файлов (ls /etc/init/), 
	а именно gdm.conf (поскольку у нас используется графический вход в систему)
	Основная строчка: exec gdm-binary SCONFIG_FILE		# выполнить exec без выполнения fork.
	# запустить процесс gdm-binary, который рисует графическое приглашение ко входу в систему.
	SCONFIG_FILE - переменная, вычисленная ранее, которая используется в качестве параметра команды.
		
		$ pgrep <имя_процесса>  → PID
	
	Существует 6 эмуляторов терминала, встроенных в ядро, которые сразу исполняются (по умолчанию)
	# в conf-файлах описаны правила запуска/перезапуска/выхода (например, start on stopped rc RUNLEVEL=[2345])
	Подробнее читать /etc/init/tty[1-6].conf
	
	systemd  - ещё одна реализация (Fedora)
	
[01:27:06]  Как монтируются другие файловые системы?
		
	В некоторых дистрибутивах (Ubuntu) ФС включена в состав ядра (не является подключаемым модулем)
	Но такое встречается далеко не всегда.	Чтобы подключить корневую ФС (указанную в параметре root),
	нужно подгрузить модули (модуль ФС || модуль дискового контроллера)
	Чтобы подключить корневую ФС ← подгрузить модули ← прочитать файл с диска → ФС должна быть смонтирована.
	Как вышли из ситуации:
		создали начальный RAM-диск (образ/архив ФС, который загружается в память вместе с ядром).
		(initial RAM filesystem, начальная файловая система)
		Называется initrd или initramfs.
		
	Документация называется Boot-протокол. Всё это описано в документации на ядро.
	Назначение initramfs — загрузить систему до состояния, в котором она может работать с корневой файловой системой.
	В initramfs должны быть только модули, необходимые для доступа к корневой файловой системе.
	В каталоге boot помимо ядра существует ещё один большой файл: initrd.img...-generic
	Сам этот файл является сжатым архивом gzip
	
	Команда zcat (в стандартный выход выдаёт распакованный архив).
	Команда cpio умеет тестировать то, что попало ему на вход.
	
	Первым файлом в initrd-архиве является файл init
	!!! Именно этот init будет выполнен ядром первым

[ более детально о первичном запуске ядра Linux и работе initramfs:
	1. ЗАГРУЗЧИК:
		♦ перемещает ядро и имеющиеся файлы initramfs в память;
		♦ запускает ядро.
	2. ЯДРО:
		• распаковывает архивы с initramfs в пока что пустующую rootfs (первоначальная корневая файловая система, чаще всего ramfs или tmpfs)
		•• сначала извлекается initramfs, которая была встроена в двоичный файл ядра в процессе сборки
		•• распаковываются внешние initramfs-файлы, если таковые имеются
		• файлы внешней initramfs перезаписывают одноименные файлы встроенной
	3. ЯДРО:
		• запуск /init в rootfs как первый процесс
		→ образуется раннее пространство пользователя (early userspace)
		• ... (загрузка необходимых модулей [напр., для устройств IDE, SCSI, SATA, USB/FW])...
		○ монтируется настоящий корневой каталог, замещающий начальную корневую ФС
		○ выполняется /sbin/init → заменяется процесс /init*
		** в некоторых ОС (Fedora, Arch,...) качестве init по умолчанию используется systemd

  встроенная initramfs (по умолчанию при сборке Linux) = пустой архив
  внешние образы initramfs можно сгенерировать с помощью
	• mkinitcpio
	• dracut
	• booster

(source: https://wiki.archlinux.org/title/Arch_boot_process_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#initramfs)
]
	
	► в качестве корневой может использоваться сетевая ФС (nfs) или система для слепых (Брайля → brltty)
	► может смонтировать ntfs-3g до монтирования корневой ФС (sbin/mount.ntfs-3g)
	
	Параметром из конфигурационного файла можно выбирать:
		• включить в ядро только специфичные для данного ПК модули 
		• все имеющиеся модули
	
	Команды пересоздания initrd и initramfs (если требуется добавить драйверы):
		mkinitrd и mkinitramfs
	
[01:34:40]  система dkms
	
	Есть сценарии, которые автоматически компилируют новые модули при установке новой версии ядра.
	Содержит файлы с исходными текстами, которые компилируются при сборке ядра.
	
	$ dpkg -l <шаблон_имени_пакета>  -  Показывает пакеты, соответствующие данному шаблону.
	Ctrl+S → перевести процесс в состояние Stopped (поставить на паузу)
	Ctrl+Q - Выйти из Stopped

	Файлы модулей для ядра имеют расширение .ko
	
	загрузчик помещает файл initrd в память;
	ядро по указанному ему заранее адресу находит файл initrd и распаковывает его.
	
	<? Из чего состоит и как работает grub ?>

	Другие файловые системы. man 5 fstab
	

[ конспект статьи: https://ubuntu.com/server/docs/kernel-crash-dump
Дамп сбоя ядра (Kernel Crash Dump) относится к части содержимого энергозависимой памяти (ОЗУ),
которая копируется на диск всякий раз, когда выполнение ядра прерывается.
Следующие события могут вызвать нарушение работы ядра:
	• Kernel Panic					[A]
	• Non Maskable Interrupts (NMI)	[A]	 {Немаскируемые прерывания}
	• Machine Check Exceptions (MCE) 	 {Исключения машинной проверки}
	• Аппаратный сбой (Hardware failure)
	• Ручное вмешательство (Manual intervention)

Для некоторых из этих событий (Kernel Panic, NMI) ядро отреагирует автоматически 
и запустит механизм аварийного дампа через kexec.
В других ситуациях требуется ручное вмешательство для захвата памяти.
Всякий раз, когда происходит одно из вышеперечисленных событий, 
важно выяснить основную причину, чтобы предотвратить его повторение.
Причину можно определить, проверив скопированное содержимое памяти.
Механизм Kernel Crash Dump
	[Kernel Panic] → запускается механизм kexec → быстрая перезагрузка нового экземпляра ядра 
												  в заранее зарезервированном разделе памяти,
												  который был выделен при загрузке системы
	* Это позволяет сохранить существующую область памяти нетронутой,
	  чтобы безопасно скопировать ее содержимое в хранилище
	Утилита kernel crash dump устанавливается командой:
	$ sudo apt install linux-crashdump
	Начиная с версии Ubuntu 16.04 механизм kernel crash dump доступен по умолчанию.
	Как активировать механизм вручную?
	1. Командами 
		dpkg-reconfigure kexec-tools 	и
		dpkg-reconfigure kdump-tools
	2. Отредактировать файл /etc/default/kexec:
		Установить значение параметра LOAD_KEXEC равным true
		# Load a kexec kernel (true/false)
		LOAD_KEXEC=true
	2.1 Также можно отредактировать /etc/default/kdump-tools: USE_KDUMP=1
Для более подробной информации читать статью.
]

