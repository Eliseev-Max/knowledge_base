1. Kernel module
[ https://wiki.archlinux.org/title/Kernel_module_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9)#%D0%92%D1%80%D1%83%D1%87%D0%BD%D1%83%D1%8E_%D0%BF%D1%80%D0%B8_%D0%B7%D0%B0%D0%B3%D1%80%D1%83%D0%B7%D0%BA%D0%B5_%D1%81_%D0%BF%D0%BE%D0%BC%D0%BE%D1%89%D1%8C%D1%8E_modprobe ]

2. modprobe.d(5) - Linux man page
	[ https://linux.die.net/man/5/modprobe.d ]

3. udev (Русский)
	[ https://wiki.archlinux.org/title/Udev_(%D0%A0%D1%83%D1%81%D1%81%D0%BA%D0%B8%D0%B9) ]

4. udev(8) - Linux man page
	[ https://linux.die.net/man/8/udev ]

Модули ядра — это отдельные кусочки кода, которые могут быть загружены и выгружены из ядра по мере необходимости. [1]
Они расширяют функциональность ядра без необходимости перезагрузки системы.

Варианты конфигурации модуля:
	• как вкомпилированный;
	• как загружаемый 
		- имеет возможность динамически загружаться | выгружаться в|из ядро(а)
		- для этого строка, относящаяся к модулю, должна быть отмечена буквой М

Где хранятся модули?
	/usr/lib/modules/<kernel_release>
	# узнать текущую версию ядра:    $ uname -r

	! Часто в названии модулей используются подчёркивания (_) или дефисы (-);
	  однако, эти символы взаимозаменяемы как при использовании команды modprobe, так и в конфигурационных файлах в /etc/modprobe.d/

Получение информации о состоянии модулей ядра
	
	► узнать, какие модули ядра загружены в настоящий момент:
		$ lsmod

	► вывести информацию о модуле:
		$ modinfo module_name

	► вывести список опций, с которыми загружен модуль:
		$ systool -v -m module_name

	► отобразить настройки для всех модулей:
		$ modprobe -c | less

	► отобразить настройки для отдельного модуля:
		$ modprobe -c | grep module_name

	► узнать зависимости модуля (или его псевдонима), включая сам модуль:
		$ modprobe --show-depends module_name

Автоматическая загрузка модулей
	Все необходимые модули загружаются автоматически.
	Помогает в этом udev(*)
	
	Случаи, когда нас не устраивает автоматическая загрузка модулей:
		• необходимо загрузить свой (custom) модуль в процессе загрузки;
		• не загружать какой-то стандартный модуль
	Чтобы дополнительные модули ядра загружались автоматически:
		→ создаются статические списки в конфигурационных файлах в директории /etc/modules-load.d/
	Общий вид:  /etc/modules-load.d/program.conf
		# Load virtio_net.ko at boot - это комментарий, который будет проигнорирован
		virtio_net
	
Управление модулями вручную
	- производится с помощью утилит, предоставляемых пакетом kmod
	Если обновить ядро и не перезагрузиться → путь /usr/bin/modules/$(uname -r) не существует → modprobe не сработает
	
	► загрузка модуля:
		# modprobe имя_модуля
	
	► загрузка модуля из другого места (для тех модулей, которых нет в /usr/lib/modules/$(uname -r)/):
		# insmod имя_файла [параметры]

	► выгрузка модуля:
		# modprobe -r имя_модуля

	► альтернативный вариант выгрузки модуля:
		# rmmod имя_модуля

Настройка параметров модуля
	Как передать параметры модулю ядра?
		1. прописать вручную для команды modprobe
			# modprobe <имя_модуля> <имя_параметра>=<значение_параметра>
			
		2. создать файл конфигурации modprobe (/etc/modprobe.d/)
			+ созданный файл будет гарантировать, что параметры будут применяться всегда
			файлы в /etc/modprobe.d/ → [_настройки_модуля_] → udev → [ управление загрузкой модулей во время загрузки ОС ]
			Синтаксис /etc/modprobe.d/moduleconfigfile.conf:
			# описание действия конфигурации
			options имя_модуля имя_параметра=значение_параметра
			
		3. использовать командную строку ядра
		+ можно передавать параметры вкомпилированному в ядро модулю
		Синтаксис:
			имя_модуля.имя_параметра=значение_параметра
		# Просто добавьте это в загрузчике в строку с ядром, как описано в статье Параметры ядра

Запрет загрузки модулей
	(в терминах модулей ядра) blacklisting = механизм, предотвращающий загрузку какого-то модуля.
	В каких случаях может понадобиться?
		1. если не нужна работа какого-то оборудования
		2. если загрузка данного модуля вызывает проблемы (напр.: 2 модуля ядра пытаются управлять одним оборудованием → совместная загрузка = конфликт)
	
	!! Некоторые модули загружаются как часть initramfs.
	#### Напечатать все автоматически обнаруженные модули:
	# mkinitcpio -M
	Предотвращение загрузки ненужных модулей из initramfs:
	* занести имена ненужных модулей в чёрный список в файле .conf (/etc/modprobe.d/) →
	→ modconf (=hook) добавит этот файл в образ initramfs при его генерации.
	!! Если используем modconf - не забыть добавить нужный *.conf файл в секцию FILES в /etc/mkinitcpio.conf !!
	#### отобразить все модули, которые необходимы некоторым хукам (например, filesystems hook, block hook и т.д.)
	# mkinitcpio -v
	** Пересобрать initramfs

	Запрет с помощью файлов в /etc/modprobe.d/
		1. Создать *.conf-файл в /etc/modprobe.d/
		2. Добавить в созданный файл строку для каждого модуля, который хотим запретить, используя "blacklist"
		Пример:
			/etc/modprobe.d/nobeep.conf

				# Do not load the 'pcspkr' module on boot.
				blacklist pcspkr
	‼ Команда blacklist запретит автоматическую загрузку модуля, НО 
	  этот модуль всё равно может загрузиться
		• если от него зависит какой-то не запрещённый модуль
		• если он загружен вручную
	Можно изменить такое поведение.
	Команда install заставляет modprobe запускать вашу собственную команду вместо вставки модуля в ядро как обычно.
	Поэтому вы можете насильно сделать так, чтобы модуль никогда не загружался:
	/etc/modprobe.d/blacklist.conf
	...
		install имя_модуля /bin/true		# Это запретит данный модуль и все модули, зависящие от него
	...

* [ udev
	udev — работающая в пространстве пользователя система, с помощью которой системный администратор может создавать обработчики событий.
	События, получаемые udev, обычно генерируются ядром Linux в ответ на физические события, происходящие с периферийными устройствами. [3]
	udev - настраиваемая поддержка динамического именования устройств в Linux. [4]
	udev предоставляет динамический каталог устройств, содержащий только файлы для реально присутствующих устройств.
	Что делает udev:
		• создает или удаляет файлы узлов устройств, обычно расположенные в каталоге /dev;
		• переименовывает сетевые интерфейсы.
	udev = часть подсистемы горячего подключения
	udev выполняется, если устройство ядра добавляется или удаляется из системы.
	СОЗДАНИЕ УСТРОЙСТВА:
		udev читает каталог sysfs подключенного (создаваемого) устройства для сбора атрибутов устройства, таких как:
			• метка,
			• серийный номер (или номер устройства шины).
		Эти атрибуты могут использоваться в качестве ключей для определения уникального имени устройства.
	udev поддерживает базу данных для устройств, присутствующих в системе.
	УДАЛЕНИЕ УСТРОЙСТВА:
		udev запрашивает в своей базе данных имя удаляемого файла устройства.
	Конфигурационные файлы udev
		== набор строк текста.
	Игнорируются: 
		• пустые строки
		• строки, начинающиеся с #
	Основной конфигурационный файл udev: /etc/udev/udev.conf
	Файл состоит из набора переменных и значений, позволяющих пользователю переопределять значения udev по умолчанию.
	В этом файле можно переопределить некоторые переменные: [4]
]

