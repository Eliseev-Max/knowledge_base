https://youtu.be/rJRLZfk3a8U

Механизмы ядра Namespace и Control Groups
	Namespace - механизм изоляции и группировки структур данных ядра
	Control groups - механизм изоляции ресурсов ядра
	
	Группе процессов/процессу можно назначить пространство имён, ограничив его  "знания" о структуре файловой системы
	chroot - указать, какую директорию процесс должен считать корневой
	
	Механизм CGroups позволяет определить (ограничить) ресурсы, которые использует тот или иной процесс
	Контейнеры = CGroups + утилиты
	
	С точки зрения планировщика разницы между процессом и потоком нет.
	Многопоточная программа (процесс) с точки зрения ядра - это множество процессов,
	имеющих одинаковый групповой идентификатор (tgid)
	tgid = tread group ID
	У главного процесса (мастер-процесса), создающего потоки, tgid совпадает с PID
	В каждом описании процесса есть строка nsproxy.
	Это табличка, отображающая существующее пространство имён, в котором процесс определён.
	struct nsproxy (
			atomic_t count;
			struct uts_namespace 'uts_ns';
			struct ipc_namespace 'ipc_ns';
			struct mnt_namespace 'mnt_ns';
			struct pid_namespace 'pid_ns_for_children';
			struct net			 'net_ns';
	)
	
	Для планировщика нет разницы, с потоком он взаимодействует или с процессом.
	
	Namespace API:
		• clone()
		• unshare()
		• setns()
	
	clone()
		При запуске ОС создаётся первый процесс init, который создаёт новые процессы, копируя самого себя.
		Для того, чтобы управлять клонированием процессов, у системного вызова clone() есть флажки,
		какие пространства имён нужно скопировать, а какие создать новыми.
	unshare()
		Системный вызов, работающий с уже созданными процессами.
		Процесс может создать с помощью unshare() новую копию своего пространства имён
	
	Namespaces (Пространства имён):
	• Mount(_NEWNS)		- пространство имён, описывающее иерархию файловой системы
	• UTS(_NEWUTS)		- имя компьютера/хоста (uname)
	• IPC(_NEWIPC)		- очереди ввода/вывода, буферы и др. ресурсы межпроцессного взаимодействия
	• PID(_NEWPID)		- пространство имён номеров процессов
	• user(_NEWUSER)	- позволяет пользователю стать root для создаваемого процесса.
	
	Mount namespace
		• mount namespace - копия дерева файловой системы, ассоциированная с процессом
			► Создание:
				clone(..., ..., CLONE_NEWNS, ...)
			► Опции:
				- распространение событий монтирования
				- запрет перемонтирования

[00:20:14]	Флаги mount
		(монтирование ФС = отображение ФС на какую-либо точку [к.-л. узел])
		
		--bind - смонтировать существующее дерево в другую точку (поддерево будет доступно в обоих местах)
		Распространение изменений:
			-make-shared
			-make-slave			# наследует изменения родителя
			-make-private		# родителю не распространяются изменения
			-make-unbindable

[00:24:15]	UTS namespace
	• Изоляция имени хоста и доменного имени
	• utsname
		struct utsname {
			char sysname[];		# имя системы
			char nodename[];	# имя хоста
			
			char release[];
			char version[];
			char machine[];
		#ifdef _GNU_SOURCE
			char domainname[];
		#endif
		};
	• Создание:
		clone(..., ..., CLONE_NEWUTS, ...)
	
	Docker НЕ ИСПОЛЬЗУЕТ UTS namespace	(используется hostname)
	
	ОС условно можно поделить на 2 части:
		• CurnelSpace
		• UserSpace
	В proc смонтирована файловая система. Она отвечает за взаимодействие пользователя с ядром ОС
	В каталоге proc находятся подкаталоги и файлы, названные наборами цифр.
	Каждый каталог соответствует PID процесса.
	Внутри каталогов файлы, соответствующие параметрам процесса.
	
[00:30:55]	Удержание пространства имён
	
	#touch ./uts
	#mount --bind/proc/6221/ns/uts ./uts
	
	см: namespaces/ns_exec.c
		fd = open("./uts", 0_RDONLY);
		if(fd == -1)
			errExit("open");
		
		if(setns(fd, 0) == -1)
			errExit("setns")
	
	#hostname
	- thinkpad
	#./ns_exec ./uts hostname
	- newhostname