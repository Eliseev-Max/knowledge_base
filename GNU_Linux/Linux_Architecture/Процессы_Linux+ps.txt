Процесс Linux - это экземпляр программы, запущенный в памяти. 
Процессы:
		• обычные
		• фоновые
		
Каждому процессу присваивается PID (Proccess Identificator).
Состояния (статусы) процессов:
    • Запуск (runnable) - процесс либо уже работает, либо готов к работе и ждет, когда ему будет дано процессорное время;
    • Ожидание (sleeping) - процессы в этом состоянии ожидают какого-либо события или освобождения системного ресурса.
	  Ядро делит такие процессы на два типа:
	    - процессы, ожидающие освобождения аппаратных средств;
		- процессы, приостановление с помощью сигнала.
    • Остановлено (stoped) - обычно, в этом состоянии находятся процессы, которые были остановлены с помощью сигнала;
    • Зомби (zombie) - это мертвые процессы, завершившиеся процессы, exit-статус котрых не был принят никаким родительским процессом
	  они были остановлены и больше не выполняются (память освобождена от процесса), но для них есть запись в таблице процессов;
	  возможно, из-за того, что у процесса остались дочерние процессы.

$ ps опции

$ ps опции | grep параметр			# Выборка процессов по определённому критерию

Опции утилиты:
			  с дефисом = Unix
			  без дефиса = BSD

    -A, -e, (a) - выбрать все процессы;
    -a - выбрать все процессы, кроме фоновых;
    -d, (g) - выбрать все процессы, даже фоновые, кроме процессов сессий;
    -N - выбрать все процессы кроме указанных;
    -С - выбирать процессы по имени команды;
    -G - выбрать процессы по ID группы;
    -p, (p) - выбрать процессы PID;
    --ppid - выбрать процессы по PID родительского процесса;
    -s - выбрать процессы по ID сессии;
    -t, (t) - выбрать процессы по tty;
    -u, (U) - выбрать процессы пользователя.

Опции форматирования:

    -с - отображать информацию планировщика;
    -f - вывести максимум доступных данных, например, количество потоков;
    -F - аналогично -f, только выводит ещё больше данных;
    -l - длинный формат вывода;
    -j, (j) - вывести процессы в стиле Jobs, минимум информации;
    -M, (Z) - добавить информацию о безопасности;
    -o, (o) - позволяет определить свой формат вывода;
    --sort, (k) - выполнять сортировку по указанной колонке;
    -L, (H)- отображать потоки процессов в колонках LWP и NLWP;
    -m, (m) - вывести потоки после процесса;
    -V, (V) - вывести информацию о версии;
    -H - отображать дерево процессов;

При использовании опции -f команда выдает такие колонки:

    UID - пользователь, от имени которого запущен процесс;
    PID - идентификатор процесса;
    PPID - идентификатор родительского процесса;
    C - процент времени CPU, используемого процессом;
    STIME - время запуска процесса;
    TTY - терминал, из которого запущен процесс;
    TIME - общее время процессора, затраченное на выполнение процесса;
    CMD - команда запуска процессора;
    LWP - показывает потоки процессора;
    PRI - приоритет процесса.

ps -Fe
	Эта опция добавляет такие колонки:

    SZ - это размер процесса в памяти;
    RSS - реальный размер процесса в памяти;
    PSR - ядро процессора, на котором выполняется процесс.

Вы можете выбрать такие колонки для отображения: pcpu, pmem, args, comm, cputime, pid, gid, lwp, rss, start, user, vsize, priority

* Просмотр процессов, которые используют больше всего памяти:
	$ ps -Fe --sort rss
* Сортировка процессов по процессу загрузки:
	$ ps -FA --sort pcpu
* Общее количество запущенных процессов:
	$  ps -e | wc
	

ps aux = Выводятся все процессы, выполняющиеся от имени всех пользователей
		 Выводит:
			• статистику;
			• время старта процесса;
			• команду, которая его стартовала
	
    USER — учетная запись пользователя, от которой запущен процесс.
    PID — идентификатор процесса.
    %CPU — потребление процессорного времени в процентном эквиваленте.
		# для многоядерных процессоров значение %CPU может быть более 100%
    %MEM — использование памяти в процентах.
    VSZ — Virtual Set Size. Виртуальный размер процесса (в килобайтах).
    RSS — Resident Set Size. Размер резидентного набора (количество 1K-страниц в памяти).
    TTY — терминал, из под которого был запущен процесс.
    STAT — текущее состояние процесса. Могут принимать значения:
        R — выполнимый процесс;
        S — спящий;
        D — в состоянии подкачки на диске;
        T — остановлен;
        Z — зомби.
        W — не имеет резидентных страниц;
        < — высоко-приоритетный;
        N — низко-приоритетный;
        L — имеет страницы, заблокированные в памяти.
    START — дата запуска процесса.
    TIME — время запуска процесса.
    COMMAND — команда, запустившая процесс.


Сортировка процессов по полям:
	прямой порядок:
		ps aux --sort=%mem
	обратный порядок
		ps aux --sort=-%mem
[Source] = https://www.dmosk.ru/miniinstruktions.php?mini=processes-linux

Что такое RSS и VSZ?
	RSS (Resident Set Size) используется для того, чтобы показать, сколько памяти выделено процессу
	и находится в оперативной памяти (RAM). Параметр не включает в себя память, которая выгружена
	(свапнутая память).
	Он включает память из разделяемых библиотек, если страницы из этих библиотек уже находятся в памяти.
	Он включает всю стековую и память кучи [*].
	
	VSZ (Virtual Memory Size), виртуальный размер памяти. Он включает всю память, к которой процесс имеет доступ,
		включая выгруженную (свапнутую) память, память, которая выделена, но не использована, и память из разделяемых библиотек.
	[**]
	Поскольку часть памяти является общей, ее могут использовать многие процессы, поэтому, если вы сложите все значения RSS,
	вы легко можете получить больше места, чем есть в вашей системе.
	Выделенная память также может не находиться в RSS, пока она не будет фактически использована программой.
	Итак, если ваша программа заранее выделила кучу памяти, а затем использует ее с течением времени, вы можете увидеть, что
		→ RSS растет, 
		→ VSZ остается прежним. 
		
lsof (List of Open Files) - утилита, используемая для вывода информации о том, какие файлы используются теми или иными процессами
Наиболее часто используются такие параметры команды:
	lsof <path/to/file>	- перечислить все процессы, которые открыли файл
	lsof -u <user_name>	- список всех файлов, открытых пользователем
	lsof -u user1, user2
	lsof -u user1 -u user2
	
	lsof +D <path/to/directory>	- список всех открытых файлов в каталоге
	lsof -p <PID>	- список всех файлов, открытых процессом
	lsof -p <PID1>, <PID2>, <PID3>
	lsof -c <command>	- список всех файлов, открытых командой
	
	Можно комбинировать параметры, такие как пользователь, команда и процесс, используя вариант 
	(аналогично действию оператора AND)
	
	lsof -a -u user_name -c command_name
	
	Перечислите сетевые соединения и порты с помощью команды lsof
	lsof -i
	lsof -i tcp
	lsof -i:<port_number>
	Исключение пользователя/процесса из вывода команды:
	lsof -u ^root		# использовали оператор отрицания ^

Столбец FD: файловый дескриптор или одна из буквенных комбинаций

    cwd - текущий рабочий каталог;
    ltx - текст разделяемой библиотеки;
    mxx - hex memory-mapped type number xx.
    m86 - DOS Merge mapped file;
    mem - файл, загруженный в память (memory-mapped file), чаще всего – библиотека,
    mmap - memory-mapped device;
    pd - родительский каталог;
    rtd - корневой каталог;
    txt – текст программы (код и данные);
    v86 - VP/ix mapped file. 

Номер файлового дескриптора сопровождается символом, указывающим режим, в котором файл был открыт:

    r - файл открыт для чтения;
    w – файл открыт для записи;
    u - файл открыт для чтения и для записи;
    пробел – режим доступа неизвестен и файл не блокирован;
    ‘-’ - режим доступа неизвестен, но на файл установлена блокировка.
	

[*]
Куча
		— название структуры данных, с помощью которой реализована динамически распределяемая память приложения
		— это раздел памяти, который содержит объекты и может также содержать ссылочные переменные. Переменные экземпляра создаются в куче
	При запуске процесса ОС выделяет память для размещения кучи. В дальнейшем память для кучи (под кучу) может выделяться динамически.

	Программа пользователя, используя функции, подобные malloc(), может получать указатели на области памяти, принадлежащие куче. Программы используют кучу для размещения динамически создаваемых структур данных. Программа может освободить память с помощью функций, подобных free().
[**]
Процесс А:
	двоичный (бинарный) файл: 							 500 кБ
	► загружено в память двоичного файла: 				 400 кБ
	разделяемые библиотеки (с которыми связан процесс): 2500 кБ
	► загружено в память разделяемых библиотек: 		1000 кБ
	распределение стека/кучи: 							 200 кБ
	из них 
		► фактически находится в памяти: 				 100 кБ
		свапнуто или не используется: 					 100 кБ
	RSS = 400 + 1000 + 100 = 1500 кБ
	VSZ = 500 + 2500 + 200 = 3200 кБ