Командная оболочка Bash. Bash-скрипты
(https://habr.com/ru/companies/ruvds/articles/325522/)


Какие оболочки существуют?
  - sh
  - bash
  - zsh
  - tcsh
  - ksh


Сценарии командной строки
  — это наборы тех же самых команд, которые можно вводить с клавиатуры, собранные в файлы и объединённые некоей общей целью.

Результаты работы команд могут
  -> представлять либо самостоятельную ценность,
  -> служить входными данными для других команд.

Сценарии — это мощный способ автоматизации часто выполняемых действий.

Командная строка (оболочка) позволяет выполнить несколько команд за один раз, введя их через точку с запятой.

Пример:
  $ pwd ; whoami


Существует ограничение на максимальное количество аргументов, которое можно передать программе.
Определить это ограничение можно с помощью такой команды:
---
getconf ARG_MAX
---

В первой строке sh-скрипта нужно указать, какую именно оболочку мы собираемся использовать.
  - для bash:
#!/bin/bash
-->
последовательность символов #! в начале скрипта называется "шебанг"
Когда скрипт с шебангом выполняется как программа в Unix-подобных операционных системах,
загрузчик программ рассматривает остаток строки после шебанга как имя файла программы-интерпретатора.
Загрузчик запускает эту программу и передаёт ей в качестве параметра имя файла скрипта с шебангом.
<--

В bash-скрипте тоже можно писать команды через ";"
Но с новой строки писать понятнее и читабельнее

[Быстро создать bash-скрипт:]
$ touch script
$ chmod +x /path/to/script
$ /path/to/script


[Переменные:]

  В bash-скриптах можно использовать:
    * переменные среды
    * пользовательские переменные

#>пример использования переменной среды:
---
#!/bin/bash
# display user home
echo "Home for the current user is: $HOME"
---
# переменные среды можно использовать внутри двойных кавычек

[!] если специальные символы используются в качестве части текста (не как спец.символ), \ЭКРАНИРУЕМ\

#> Пользовательские переменные, определённые внутри bash-скрипта, хранят свои значения (=существуют) до завершения скрипта.
#> Но всё меняется с использованием export


[Подстановка команд:]
  Одна из самых полезных возможностей bash-скриптов
    — это возможность извлекать информацию из вывода команд
      и назначать её переменным -> можно использовать эту информацию где угодно в файле сценария.

  Способы реализации:
    1) С помощью значка обратного апострофа «`» # считается устаревшим
    2) С помощью конструкции $()


[Математические операции:]

  Для выполнения математических операций в файле скрипта можно использовать конструкцию вида
  $((a+b)):

---< Математические операции в bash-скрипте >---
#!/bin/bash
var1=$(( 5 + 5 ))
echo $var1                  # 10
var2=$(( $var1 * 2 ))
echo $var2                  # 20
---


[Управляющая конструкция if-then:]
<https://habr.com/ru/companies/ruvds/articles/325522/>


[Сравнение чисел:]
  В скриптах можно сравнивать числовые значения.
>> Соответствующие команды:
---
n1 -eq n2  -> Возвращает истинное значение, если n1 равно n2.
n1 -ge n2  -> Возвращает истинное значение, если n1 больше или равно n2.
n1 -gt n2  -> Возвращает истинное значение, если n1 больше n2.
n1 -le n2  -> Возвращает истинное значение, если n1 меньше или равно n2.
n1 -lt n2  -> Возвращает истинное значение, если n1 меньше n2.
n1 -ne n2  -> Возвращает истинное значение, если n1 не равно n2.
---


[Сравнение строк:]

---
str1 = str2  -> Проверяет строки на равенство, возвращает истину, если строки идентичны.
str1 != str2 -> Возвращает истину, если строки не идентичны.
str1 < str2  -> Возвращает истину, если str1 меньше, чем str2.
str1 > str2  -> Возвращает истину, если str1 больше, чем str2.
-n str1      -> Возвращает истину, если длина str1 больше нуля.
-z str1      -> Возвращает истину, если длина str1 равна нулю.
---

[! Особенность сравнения строк !]

1)  Операторы «>» и «<» НЕОБХОДИМО ЭКРАНИРОВАТЬ с помощью обратной косой черты,
    иначе скрипт будет работать неправильно,
[!] хотя сообщений об ошибках и не появится.

## Скрипт интерпретирует знак «>» как команду перенаправления вывода.

  Вот как работа с этими операторами выглядит в коде:
---< Сравнение строк >---
```
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```

#! скрипт, хотя и выполняется, выдаёт предупреждение:
```
./myscript: line 5: [: too many arguments
```

  Для того, чтобы избавиться от этого предупреждения,
  заключим $val2, содержащее пробел, в двойные кавычки:
# ИНТЕРПОЛЯЦИЯ!

```
#!/bin/bash
val1=text
val2="another text"
if [ $val1 \> "$val2" ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
```
# Теперь всё работает как надо

2) Операторы ">" и "<"  работают с символами в верхнем и нижнем регистрах.

---<file.txt>---
Likegeeks
likegeeks
---

$ sort file.txt

---< Sorted file.txt >---
likegeeks
Likegeeks
---

С другой стороны
---
#!/bin/bash
val1=Likegeeks
val2=likegeeks
if [ $val1 \> $val2 ]
then
echo "$val1 is greater than $val2"
else
echo "$val1 is less than $val2"
fi
---
# Likegeeks is less than likegeeks
## так происходит, потому что сравнение строк здесь выполняется путём сравнения ASCII-кодов символов
## а команда sort, в свою очередь, использует порядок сортировки, заданный в настройках системного языка.