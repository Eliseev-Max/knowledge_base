Утилита sed
(версия 4.0.9)

[source:]
1) "Глава 3. man sed": https://emulek.github.io/sed/ch03.html
2) "sed(1) - Linux man page": https://linux.die.net/man/1/sed
3) "Команда SED в Linux/Unix с примерами": https://habr.com/ru/companies/ruvds/articles/667490/


[Синтаксис:]

sed [опции]... {только-скрипт-если-нет-других-скриптов} [файл(ы)]...
sed OPTIONS... [SCRIPT] [INPUTFILE...]

[Описание:]
Sed 
  - это потоковый редактор.
  #(Потоковый редактор для фильтрации и преобразования текста).

  Потоковый редактор используется для базовых изменений текста в виде входящего потока (из файла, или из входного pipe потока).
  Команды sed чуть менее чем полностью позаимствованные из древнего текстового редактора ed.
  Sed обрабатывает текстовые строки и сам текст исключительно ЗА ОДИН ПРОХОД.
  Sed может использоваться как фильтр:
    * для обработки текстов созданных другими текстовыми редакторами,
    * (+) для фильтрации и обработки текстовых данных выводимых другими утилитами.

[Опции CLI:]

  -n, --quiet, --silent
    = Подавление автоматического вывода буфера после обработки.

  -e script, --expression=script
    = Добавить sed-скрипт для обработки.

  -f script-file, --file=script-file
    = Добавить для обработки содержимое файла (файл будет обрабатываться как sed-скрипт).

  -i[suffix], --in-place[=suffix]
    = Редактирование файла на месте.
      (возможно создание резервной копии, если используется суффикс).

  -l <N>, --line-length=<N>
    = Задаёт значение для обрезки строк командой l.

  -r, --regexp-extended
    = Использование расширенных регулярных выражений в sed-скрипте.

  -s, --separate
    = Сепаратор.
      Разделение потока на отдельные файлы,
      по умолчанию sed считает все входящие файлы как один длинный поток,
      а с этой опцией файлы разделены (например, для каждого файла первая строка будет именно первой,
      а адрес $ будет совпадать с каждой последней строкой, а не только с последней строкой последнего файла).
    #= рассматривать файлы как отдельные, а не как один непрерывный длинный поток.

  -u, --unbuffered
    = Использование минимально возможного размера буферов.

  --help
    = показать краткую справку и выйти.

  -V, --version
    = показать номер версии и выйти.

# Если не применяются опции:
  -e (--expression)
  -f (--file)
  тогда первый аргумент, не являющийся опцией интерпретируется как sed-скрипт.

# Все остальные аргументы интерпретируются как входящие файлы.

[!] Если файл для обработки не задан, sed читает данные из входного потока.


[Безадресные команды:]
  : label
    = Эта команда задаёт метку, для перехода к ней командами b, t, и T.

  #comment
    = Комментарий, который продолжается до конца строки
      (или до конца фрагмента скрипта в опции -e).

  }
    = Завершение блока команд {...}.


[Команды которые используются с одним адресом или без адреса:]
  =
    - Вывод в выходной поток номера текущей строки.

  a text
    = Вывод в выходной поток text'а, после вывода обработанного буфера. Можно вывести несколько строк, если в конце каждой строки добавить обратный слеш '\'.

  i text
    = Так-же как a, но text выводится перед буфером.

  q
    = Выход из скрипта.
      При этом больше никаких данных не читается из входного потока.
      Если разрешён вывод буфера, то он выводится в выходной поток.

  Q
    = Так-же как q, но буфер не выводится.

  r file
    = Добавляет к выводу текст прочитанный из file.

  R file
    = Добавляет к выводу одну строку прочитанную из file.
      Команды, которые можно использовать с диапазоном адресов.

  {
    = Начала блока команд.
      (В конце блока ставится }).

  b label
    = Переход на метку label. Если такой метка не задана, то переход выполняется в конец скрипта.

  t label
    = Если команда s/// произвела успешный поиск и замену последней прочитанной строки,
      то эта команда передаёт управление на метку label.
      Если метка не задана, переход осуществляется в конец скрипта.

[!ЗАМЕЧАНИЕ!]
  Если перед t выполнилось несколько команд s///,
  то переход будет выполнятся в зависимости от результата работы ПЕРВОЙ КОМАНДЫ s///.
  Для сброса флага используйте ещё одну команду перехода, например:
---
# эта команда находит и заменяет всегда (т.к. у любой строки есть начало).
  s/^/BEGIN:/

# для сброса флага перехода, мы осуществляем переход на метку lb
  t lb
  :lb

# а эта команда не всегда меняет (т.к. не во всех строках есть буква Z)
  s/Z/z/

# сл. переход выполнится только для строчек, в которых была буква Z, которая поменялась на z.
  t is_z


  T label
    = Так-же как t, но переход выполняется если замены не было.

  c text
    = Так-же как a, но текст выводится вместо вывода буфера.

  d
    = Удаление буфера. Начало нового цикла.

[!ЗАМЕЧАНИЕ!]
  Тут не всё так просто:
  эта единственная команда (не считая D), которая осуществляет неявный переход к выполнению нового цикла -
  после обработки этой команды, все ПОСЛЕДУЮЩИЕ команды НЕ ВЫПОЛНЯЮТСЯ,
  а содержимое буфера никогда не выводится в выходной поток.

  D
    = Эта команда выполняется следующим образом:
      Сначала из буфера удаляются первые символы до символа '\n' включительно, если такой символ есть.
      (если нет - удаляются все символы)
      В случае, если в строке остались символы, работа скрипта прерывается, и выполняется переход к началу скрипта.
      При этом символы не читаются из входного потока, а остаются те, что остались после п1.

      Если в буфере нет символов (после удаления в п1), то выполнение скрипта так-же прерывается,
      но после этого происходит загрузка новой строки из входного потока в буфер.
      В этом случае, выполнение эквивалентно команде d.

  h H
    = Копирование/добавление буфера в/к области удержания.

  g G
    = Копирование/добавление области удержания в/к буферу.

#### подробнее: см. (1) ####

[!] s/<regexp>/<replacement>/
      = Попытка сопоставить regexp с пространством шаблона.
      В случае успеха заменить совпавшую часть на replacement.
      Замена может содержать специальный символ &
      => для ссылки на ту часть пространства шаблона, которая совпала,
      и специальные эскейпы \1 - \9
      => для ссылки на соответствующие совпадающие подвыражения в regexp.
  

[Адресация:]

  Sed команды могут использоваться без адреса,
  => в этом случае, команда проверяет все строки входящего текста.

  Так-же команда может использоваться с одним адресом,
  => тогда команда выполнится только для тех строк, которые совпадают с адресом.

  Кроме того, в качестве адреса можно использовать диапазон adr1,adr2.
  При этом команда будет обрабатывать все строки начиная с той, которая совпадает с adr1 и заканчивая той, с которой совпадает adr2.
  Если в качестве adr2 используется регулярное выражение, то оно не будет проверятся в первой строке диапазона (в первой строке совпадающей с adr1).

  После адреса (или адресного диапазона), и перед командой, можно поставить !,
  который приведёт к ИНВЕРТИРОВАНИЮ АДРЕСА (команда выполнится для всех строк кроме той, что совпадает с адресом или с адресным диапазоном).

Поддерживаемые типы адресных выражений:

number
  Совпадает только со строкой с номером number.

first~step
  Совпадает со строками начиная с first, с шагом step. Например

sed -n '1~2p'
  выведет только нечётные строки. Адресное выражение 2~5 совпадает с каждой пятой строкой начиная со второй (2,7,12,17...). (Это GNU расширение).

$
  Совпадает с последней строкой последнего файла (или с последней строкой каждого файла при использовании опции -s).

/regexp/
  Совпадает со строкой, в которой найдётся выражение regexp.

\cregexpc
  Совпадает со строкой, в которой найдётся выражение regexp.
  (c может быть любым символом.)

GNU sed поддерживает несколько специальных диапазонов адресов:

  0,adr2
    - Этот диапазон работает в точности так же как 1,adr2, в случае если самая первая строка не совпадает с adr2.
      Если ПЕРВАЯ СТРОКА СОВПАДАЕТ с adr2, то весь диапазон совпадает только с этой строкой
      (выражение 1,adr2 совпадает со строками начиная с первой, и далее для всех, до строки совпадающей с adr2,
      при этом проверяются строки начиная со второй, ПЕРВАЯ НЕ ПРОВЕРЯЕТСЯ
      ).

  adr1,+N
    - Совпадает со строкой adr1 и ещё с N строками после неё.

  adr1,~N
    - Совпадает со строками от adr1 и до строки, которая кратна N
      (включительно, кратность проверяется начиная со строки, которая следует за строкой adr1).
      К примеру, 4,~4 совпадает со строками 4,5,6,7, и 8.
      Восемь - ближайшее кратное к четырём начиная с пяти.


[Примеры:]

Есть тектовый файл:
---<geekfile.txt>---
unix is great os. unix is opensource. unix is free os.
learn operating system.
unix linux which one you choose.
unix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
---

  1) Замена заданного шаблона
  # заменим в целевом файле вхождения слова unix на linux:

---[cmd]---
$ sed 's/unix/linux' geekfile.txt
---

# Вывод:
---<geekfile.txt>---
linux is great os. unix is opensource. unix is free os.
learn operating system.
linux linux which one you choose.
linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
---

  s обозначает операцию замены,
  '/' (прямые слэши) выступают разделителями.
  [искомый шаблон:] = unix,
  [замена:] = linux

По умолчанию команда sed заменяет ПЕРВОЕ ВХОЖДЕНИЕ шаблона В КАЖДОЙ СТРОКЕ,
не затрагивая второе, третье и т.д.

  2) Замена n-ого вхождения шаблона в строке

# Вхождения, которые нужно заменить, обозначаются с помощью флагов /1, /2 и т.д.
  # заменим в каждой строке второе вхождение:

---[cmd]---
$ sed 's/unix/linux/2' geekfile.txt
---

# Вывод:
---
unix is great os. linux is opensource. unix is free os.
learn operating system.
unix linux which one you choose.
unix is easy to learn.linux is a multiuser os.Learn unix .unix is a powerful.
---

  3) Замена всех вхождений шаблона в файле

# Для замены ВСЕХ без исключения вхождений заданного шаблона используется глобальный флаг /g:

---[cmd]---
$ sed 's/unix/linux/g' geekfile.txt
---

# Вывод:
---
linux is great os. linux is opensource. linux is free os.
learn operating system.
linux linux which one you choose.
linux is easy to learn.linux is a multiuser os.Learn linux .linux is a powerful.
---

  4) Заключение первых символов слов в скобки

# Следующая команда заключит в скобки первый символ каждого слова:

---[cmd]---
$ echo "Welcome To The Geek Stuff" | sed 's/\(\b[A-Z]\)/\(\1\)/g'
---

# Вывод:
---
(W)elcome (T)o (T)he (G)eek (S)tuff
---


  5) Замена шаблона в конкретной строке

# Можно ограничить выполнение команды sed нужной строкой:

---
$sed '3 s/unix/linux/' geekfile.txt

#Вывод:
---
unix is great os. unix is opensource. unix is free os.
learn operating system.
linux linux which one you choose.
unix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
---
# команда заменяет заданное слово только в третьей строке

  6) Дублирование изменяемых строк
При добавлении флага /p команда выведет в терминал строки, где производится замена. Строки, в которых искомый шаблон отсутствует, не дублируются.

$sed 's/unix/linux/p' geekfile.txt

#Вывод:
---
linux is great os. unix is opensource. unix is free os.
linux is great os. unix is opensource. unix is free os.
learn operating system.
linux linux which one you choose.
linux linux which one you choose.
linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
---

  7) Вывод только строк с заменой

Если рядом с флагом /p добавить ключ -n, в терминале отобразятся только строки, где выполнялась замена. В данном случае -n отключает дублирующее поведение флага /p, поэтому строки с заменой выводятся по одному разу.

$sed -n 's/unix/linux/p' geekfile.txt

Вывод:

linux is great os. unix is opensource. unix is free os.
linux linux which one you choose.
linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.

Если использовать только -n, исключив /p, вывод команда не произведёт.


  8) Замена шаблона в указанном диапазоне строк

sed позволяет указывать диапазон строк, в которых требуется заменить определённый шаблон:

$sed '1,3 s/unix/linux/' geekfile.txt

#Вывод:
---
linux is great os. unix is opensource. unix is free os.
learn operating system.
linux linux which one you choose.
unix is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful.
---
Здесь sed производит замену в строках с 1 по 3. А вот ещё один пример:
---
$sed '2,$ s/unix/linux/' geekfile.txt
---

#Вывод:
---
unix is great os. unix is opensource. unix is free os.
learn operating system.
linux linux which one you choose.
linux is easy to learn.unix is a multiuser os.Learn unix .unix is a powerful
---

Здесь $ указывает на последнюю строку файла, в связи с чем sed заменяет первые вхождения шаблона, начиная со второй и заканчивая ей.


  9) Удаление строк из файла

С помощью sed также можно удалять строки из заданного файла:

    9.1 Удаление n-ой строки:

Синтаксис: $ sed 'nd' filename.txt
Пример: $ sed '5d' filename.txt

    9.2 Удаление последней строки:

Синтаксис: $ sed '$d' filename.txt

    9.3 Удаление строк с x> по y:

Синтаксис: $ sed 'x,yd' filename.txt
Пример: $ sed '3,6d' filename.txt

    9.4 Удаление строк с n-ой до последней:

Синтаксис: $ sed 'n,$d' filename.txt
Пример: $ sed '12,$d' filename.txt

    9.5 Удаление текста, соответствующего шаблону:

Синтаксис: $ sed '/pattern/d' filename.txt
Пример: $ sed '/abc/d' filename.txt


Добавление/удаление пустых строк в файле


Нумерация строк


Удаление строк


Просмотр/вывод строк


********************************
* Замена с помощью команды sed *
********************************

  [Два способа замены шаблона, игнорируя регистр:]
    1.1 Использовать флаг /i:
---<Синтаксис:>---
$ sed ‘s/old_pattern/new_pattern/i’ filename
---

-[Пример:]-
[root@rhel7 ~]# sed 's/life/Love/i' a.txt
---

    1.2 Использовать регулярные выражения:

-[Пример:]-
[root@rhel7 ~]# sed 's/[Ll]ife/Love/g' a.txt


2. Замена нескольких пробелов одним:

Пример: [root@rhel7 clang]# sed 's/ */ /g' filename

3. Замена шаблона, сопровождающего другой шаблон:

Синтаксис: sed ‘/followed_pattern/ s/old_pattern/new_pattern/’ filename
Пример: [root@rhel7 ~]# sed '/is/ s/live/love/' a.txt

10. Замена шаблона другим шаблоном, за исключением строки n:

Синтаксис: sed ‘n!s/old_pattern/new_pattern/’ filename
Пример: [root@rhel7 ~]# sed -i '5!s/life/love/' a.txt