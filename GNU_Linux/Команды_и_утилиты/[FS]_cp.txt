Копирование файлов. Команда cp

sources: [
  [1] "cp(1) - Linux man page": https://linux.die.net/man/1/cp
  [2] "Команда cp в Linux": https://losst.pro/komanda-cp-v-linux
  [3] "Команда cp в Linux. 7 практических примеров": \
    -> https://andreyex.ru/operacionnaya-sistema-linux/komanda-cp-v-linux-7-prakticheskih-primerov/
  [4] "Копирование файлов в Linux": https://losst.pro/kopirovanie-fajlov-v-linux
]
#also:
##>(a) "Sparse file": https://wiki.archlinux.org/title/Sparse_file
##>(b) "What is a sparse file and why do we need it?": https://stackoverflow.com/questions/43126760/what-is-a-sparse-file-and-why-do-we-need-it


#(b):>
---<Что такое sparse file (разреженный файл) и зачем он нужен>---
  Допустим, у вас есть файл с большим количеством пустых байтов \x00.
  Такие пустые байты \x00 называются дырами.
  Хранить пустые байты просто неэффективно, мы знаем, что их много в файле,
(?) так зачем хранить их на устройстве хранения?

(!) Вместо этого мы можем хранить МЕТАДАННЫЕ, описывающие эти нули.
  Когда процесс читает файл, эти блоки нулевых байт генерируются динамически, а не хранятся на физическом носителе.

  Именно поэтому разреженный файл эффективен!
  ✓ он не хранит нули на диске,
  ✓ вместо этого он содержит достаточно данных, описывающих нули, которые будут сгенерированы.

[Обратите внимание:]
  логический размер файла больше физического для разреженных файлов.
  Это связано с тем, что мы не храним нули физически на устройстве хранения.

#(a):
---<Sparse file (ArchLinux Wiki)>---
  Согласно Википедии, разреженный файл (sparse file)
    - это тип файла, который пытается более эффективно использовать пространство файловой системы (ФС),
    когда блоки, выделенные под файл, в основном пусты.
  Это достигается путем записи на диск краткой информации (метаданных), представляющей пустые блоки,
  вместо собственно «пустого» пространства, составляющего блок, что позволяет использовать меньше дискового пространства.
  Полный размер блока записывается на диск как фактический размер только тогда, когда блок содержит «реальные» (непустые) данные.

  При чтении разреженных файлов ФС во время выполнения прозрачно преобразует метаданные, представляющие пустые блоки,
  в «реальные» блоки, заполненные нулевыми байтами.
[!] Приложение НЕ ЗНАЕТ об этом преобразовании.

  Большинство современных ФС поддерживают разреженные файлы, включая большинство вариантов Unix и NTFS,
(!) но не HFS+ от Apple.

  Разреженные файлы обычно используются для создания
    ✓ образов дисков (не путать с разреженными образами),
    ✓ моментальных снимков баз данных,
    ✓ файлов журналов  и
    ✓ в научных приложениях.

[Преимущество разреженных файлов:]
  место для хранения выделяется только тогда, когда оно действительно необходимо:
    ➜ экономится дисковое пространство,
    ➜ большие файлы могут быть созданы даже при недостатке свободного места в ФС.

[Недостатки:]
  - разреженные файлы могут стать фрагментированными;
  - отчеты о свободном пространстве в ФС могут вводить в заблуждение;
  - заполнение ФС, содержащих разреженные файлы, может привести к неожиданным последствиям;
  - копирование разреженного файла программой, которая их явно не поддерживает,
    может скопировать весь файл, включая пустые блоки, которые явно не хранятся на диске
    ➜ что приводит к потере преимуществ разреженного свойства файла.
#(for more info: https://wiki.archlinux.org/title/Sparse_file)

---

[Синтаксис команды:]

cp [OPTION]... [-T] SOURCE DEST
cp [OPTION]... SOURCE... DIRECTORY
cp [OPTION]... -t DIRECTORY SOURCE...

[Описание:]
# Копирование SOURCE в DEST или нескольких SOURCE(ов) в DIRECTORY.
#(!) Обязательные аргументы длинных опций обязательны и для коротких опций.

#[!] Если DEST (целевой файл) существует, то его содержимое ЗАМЕНЯЕТСЯ БЕЗ ПРЕДУПРЕЖДЕНИЯ.

#[!] При копировании нескольких SOURCE должен быть указан целевой каталог.

-a, --archive
  = same as -dR --preserve=all
# = никогда не переходите по символическим ссылкам в SOURCE +
# + сохраняет указанные атрибуты (по умолчанию: mode,ownership,timestamps) и,
    если возможно, дополнительный атрибут links +
# + рекурсивное копирование каталогов +
# + сохранить (по возможности) все атрибуты

--backup[=CONTROL]
  = создать резервную копию каждого существующего файла назначения

-b
  = как --backup, НО не принимает аргумент

--copy-contents
  = копировать содержимое (contents) специальных файлов при рекурсии

-d
  = same as --no-dereference --preserve=links

-f, --force
  = если существующий файл назначения не может быть открыт,
    удалить его и повторите попытку (избыточно, если используется опция -n)

-i, --interactive
  = запрос перед перезаписью (отменяет предыдущую опцию -n)

-H
  = следовать символическим ссылкам командной строки в SOURCE

-l, --link
  = связывать (link) файлы вместо копирования

-L, --dereference
  = always follow symbolic links in SOURCE

-n, --no-clobber
  = НЕ ПЕРЕЗАПИСЫВАТЬ существующий файл (отменяет предыдущую опцию -i)

-P, --no-dereference
  = never follow symbolic links in SOURCE

-p
  = same as --preserve=mode,ownership,timestamps

--preserve[=ATTR_LIST]
  = сохраняет указанные атрибуты (по умолчанию: mode,ownership,timestamps),
    если возможно, дополнительные атрибуты: context, links, xattr, all

-c
  = same as --preserve=context

--no-preserve=ATTR_LIST
  = don't preserve the specified attributes

--parents
  = use full source file name under DIRECTORY

-R, -r, --recursive
  = copy directories recursively

--reflink[=WHEN]
  = control clone/CoW copies. See below.

--remove-destination
  = удалять каждый существующий целевой файл перед попыткой его открытия (в отличие от --force)

--sparse=WHEN
  = control creation of sparse files. See below.

--strip-trailing-slashes
  = remove any trailing slashes from each SOURCE argument

-s, --symbolic-link
  = make symbolic links instead of copying

-S, --suffix=SUFFIX
  = override the usual backup suffix

-t, --target-directory=DIRECTORY
  = copy all SOURCE arguments into DIRECTORY

-T, --no-target-directory
  = treat DEST as a normal file

-u, --update
  = копирование только в том случае, если SOURCE-файл новее, чем файл назначения, или если файл назначения отсутствует


-v, --verbose
  = explain what is being done

-x, --one-file-system
  = stay on this file system

-Z, --context=CONTEXT
  = set security context of copy to CONTEXT

[Работа с sparse files]
  По умолчанию разреженные файлы SOURCE определяются с помощью грубой эвристики,
  и соответствующий файл DEST также становится разреженным.
  Такое поведение выбирается командой --sparse=auto.

  --sparse=always
    = создавать разреженный DEST-файл всякий раз, когда SOURCE-файл содержит достаточно длинную последовательность нулевых байт.

  --sparse=never
    = запретить создание разреженных файлов.

[lightweight copy (облегченное копирование)]
  Если указано --reflink[=always], выполняется облегченное копирование, при котором блоки данных копируются только при их изменении.
  Если это невозможно, копирование завершится неудачей,
    <или>
  если указано --reflink=auto, произойдет возврат к стандартному копированию.


[Резервное копирование DEST-файлов:]
  Суффикс резервного копирования - '~', если он не задан с помощью --suffix или SIMPLE_BACKUP_SUFFIX.
  Метод контроля версий может быть выбран с помощью опции --backup или через переменную окружения VERSION_CONTROL.
  Вот ее значения:
    ● none, off
      = never make backups (even if --backup is given)
    ● numbered, t
      = make numbered backups
    ● existing, nil
      = numbered if numbered backups exist, simple otherwise
    ● simple, never
      = always make simple backups

[!] В качестве особого случая cp создает резервную копию SOURCE,
    (если заданы параметры force и backup)
    а SOURCE и DEST - это одно и то же имя существующего обычного файла.