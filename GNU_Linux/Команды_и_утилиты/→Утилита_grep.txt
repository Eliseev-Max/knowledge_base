sources:
  GNU Grep 3.8: {https://www.gnu.org/software/grep/manual/grep.html}
  ‼ Команда grep: опции, регулярные выражения и примеры использования: {https://zalinux.ru/?p=1270}
  Поиск текста в файлах Linux: {https://losst.pro/gerp-poisk-vnutri-fajlov-v-linux}
  Regular expressions in grep ( regex ) with examples {https://www.cyberciti.biz/faq/grep-regular-expressions/}

Название команды grep расшифровывается как "search globally for lines matching the regular expression, and print them"

Синтаксис команды:
  Общий вид:
  $  grep [опции] шаблон [/путь/к/файлу/или/папке...]
  
Варианты запуска по версии https://zalinux.ru/?p=1270
  $ grep [ОПЦИИ] ШАБЛОН [ФАЙЛ...]
	
  $ grep [ОПЦИИ] -e ШАБЛОН... [ФАЙЛ...]
## -e, --regexp=ШАБЛОН    использовать ШАБЛОН для поиска
---<https://linux.die.net/man/1/grep>---
  Используйте PATTERN (= ШАБЛОН) в качестве шаблона.
  Можно использовать для указания нескольких шаблонов поиска
  или для защиты шаблона, начинающегося с дефиса (-).
  (-e определено POSIX.)
---
    
    $ grep [ОПЦИИ] -f ФАЙЛ... [ФАЙЛ...]
	## брать ШАБЛОН из ФАЙЛа
	
  Фильтрация стандартного вывода команды:
    $ команда | grep [опции] шаблон
	
  • Опции - это дополнительные параметры, с помощью которых указываются различные настройки поиска и вывода,
    (например количество строк или режим инверсии)
  • Шаблон - это любая строка или регулярное выражение, по которому будет выполняться поиск.
  • Имя файла или папки - это то место, где будет выполняться поиск. 
  
  * grep позволяет искать в нескольких файлах;
  * grep позволяет искать каталоге, используя рекурсивный режим
    -r, --recursive
	  или
	-d =recurse (| --directories=recurse)


-F, --fixed-strings
интерпретировать PATTERN как список фиксированных строк, разделенных новыми строками, любая из которых должна быть сопоставлена
-G, --basic-regexp
интерпретировать PATTERN как базовое регулярное выражение (BRE, см. ниже). Это значение используется по умолчанию.

Шаблон (PATTERN) выбора и его интерпретация:
  -E, --extended-regexp PATTERN     = интерпретировать PATTERN как расширенное регулярное выражение (ERE)
  -F, --fixed-regexp PATTERN        = интерпретировать PATTERN как список фиксированных строк, разделенных новыми строками, любая из которых должна быть сопоставлена
  -G, --basic-regexp PATTERN        = интерпретировать PATTERN как базовое регулярное выражение (BRE) (используется по умолчанию)
  -P, --perl-regexp  PATTERN        = регулярное выражения языка Perl
  -e PATTERN, --regexp=PATTERN          = использовать PATTERN в качестве шаблона поиска
  -f, --file=ФАЙЛ        брать PATTERN из ФАЙЛа
  -i, --ignore-case      игнорировать различие регистра
  -w, --word-regexp      PATTERN должен подходить ко всем словам
  -x, --line-regexp      PATTERN должен подходить ко всей строке
  -z, --null-data        строки разделяются байтом с нулевым значением, а не
                         символом конца строки

---[]---

---
 
Разное:
  -s, --no-messages         не показывать сообщения об ошибках
  
  -v, --invert-match        выбирать не подходящие строки (антифильтр, всё, кроме указанного)
  
  -V, --version             показать информацию о версии и закончить работу
      --help                показать эту справку и закончить работу
 
Управление выводом:
  -m, --max-count=ЧИСЛО     остановиться после указанного
                            ЧИСЛА выбранных строк
  -b, --byte-offset         печатать вместе с выходными строками смещение в
                            байтах
  -n, --line-number         печатать номер строки вместе с выходными строками
      --line-buffered       сбрасывать буфер после каждой строки
  -H, --with-filename       печатать имя файла для каждой выводимой строки
  -h, --no-filename         не начинать вывод с имени файла
      --label=МЕТКА         использовать МЕТКУ в качестве имени файла для
                            стандартного ввода
  -o, --only-matching       = показывать только часть строки, совпадающей с ШАБЛОНОМ
  -q, --quiet, --silent     = тихий режим; не записывает ничего в стандартный вывод

---< Опция -q (--quiet) >---

= тихий режим; не записывает ничего в стандартный вывод.
  
  Опция -q дает средства простого определения, находится ли образец (или строка) в группе файлов/стандартном выводе.

  + при поиске в нескольких файлах она обеспечивает более высокую производительность
      (поскольку позволяет завершить работу, как только будет найдено первое соответствие)

  + не требует дополнительных усилий пользователя при формировании набора файлов-аргументов
      (поскольку grep вернет нулевой статус выхода при обнаружении соответствия,
       даже если при работе с предыдущими операндами-файлами произошла ошибка доступа или чтения)

  Также смотрите опцию -s или --no-messages. (-q указывается в POSIX .)
---

  --binary-files=ТИП    считать, что двоичный файл имеет ТИП:
                            «binary», «text» или «without-match».
  -a, --text                то же что и --binary-files=text
  -I                        то же, что и --binary-files=without-match
  -d, --directories=ДЕЙСТВ  как обрабатывать каталоги
                            ДЕЙСТВИЕ может быть «read» (читать),
                            «recurse» (рекурсивно) или «skip» (пропускать).
  -D, --devices=ДЕЙСТВ      как обрабатывать устройства, FIFO и сокеты
                            ДЕЙСТВИЕ может быть «read» или «skip»
  -r, --recursive           то же, что и --directories=recurse
  -R, --dereference-recursive                             тоже, но с переходом по всем символьным ссылкам
      --include=Ф_ШАБЛОН    обработать только файлы, подпадающие под Ф_ШАБЛОН
      --exclude=Ф_ШАБЛОН    пропустить файлы и каталоги,
                            подпадающие под Ф_ШАБЛОН
      --exclude-from=ФАЙЛ   пропустить файлы, подпадающие под шаблон
                            файлов из ФАЙЛА
      --exclude-dir=ШАБЛОН  каталоги, подпадающие под ШАБЛОН,
                            будут пропущены
  -L, --files-without-match печатать только имена ФАЙЛОВ без выбранных строк
  -l, --files-with-matches  печатать только имена ФАЙЛОВ с выбранными строками
  -c, --count               печатать только количество выбранных
                            строк на ФАЙЛ
  -T, --initial-tab         выравнивать табуляцией (если нужно)
  -Z, --null                печатать байт 0 после имени ФАЙЛА
 
Управление контекстом:
  -B, --before-context=ЧИС  печатать ЧИСЛО строк предшествующего контекста
  -A, --after-context=ЧИС   печатать ЧИСЛО строк последующего контекста
  -C, --context[=ЧИС]       печатать ЧИСЛО строк контекста
  -ЧИСЛО                    то же, что и --context=ЧИСЛО
      --color[=КОГДА],
      --colour[=КОГДА]      использовать маркеры для различия совпадающих
                            строк; КОГДА может быть «always» (всегда),
                            «never» (никогда) или «auto» (автоматически)
  -U, --binary              не удалять символы CR в конце строки
                            (MSDOS/Windows)
 
► Если в качестве ФАЙЛА указан символ «-», то читается стандартный ввод.
► Если ФАЙЛ не указан и задан параметр командной строки -r,
  то читается   текущий каталог «.»  и «-» в противном случае.
  Если указано менее двух ФАЙЛОВ, то предполагается -h.
  
  При нахождении совпадений любой строки, кодом завершения программы будет 0, и 1, если ничего не совпало.
  При возникновении ошибок и если не указан параметр -q, кодом завершения будет 2.

---< Обработка каталогов >---
-d ACTION, --directories=ACTION  - способ обработки каталогов.

## Если входной файл - это каталог, используйте ACTION для его обработки.

  ACTION = read (значение по умолчанию) - каталоги читаются так же, как если бы они были обычными файлами
  ACTION = recurse - grep рекурсивно читает все файлы в каждом каталоге;
                     это эквивалентно опции -r
  ACTION = skip  - пропускать в режиме silently
---

---<_Regular Expressions_>---
(https://linux.die.net/man/1/grep)

Регулярное выражение - это шаблон, описывающий набор строк (a set of strings).
Регулярные выражения строятся аналогично арифметическим выражениям,
с помощью различных операторов для объединения меньших выражений.

grep понимает три различных варианта синтаксиса регулярных выражений:
  1) basic ("базовый");
  2) extended ("расширенный");
  3) "perl"

[!] В GNU grep НЕТ РАЗНИЦЫ в доступной функциональности между базовым и расширенным синтаксисами.
В других реализациях базовые регулярные выражения менее функциональны.
Следующее описание относится к расширенным регулярным выражениям; различия для базовых регулярных выражений описаны далее.

Регулярные выражения Perl предоставляют дополнительную функциональность
и документированы в pcresyntax(3) и pcrepattern(3),
но могут быть доступны не в каждой системе.

Фундаментальными строительными блоками являются регулярные выражения, которые соответствуют одному символу.
Большинство символов, включая все буквы и цифры, являются регулярными выражениями, которые соответствуют сами себе.
Любой метасимвол, имеющий особое значение, можно заключить в кавычки, поставив перед ним обратную косую черту.
Точка (.) соответствует любому одиночному символу.


*******************************************
* Классы символов и выражения со скобками *
*******************************************

  Выражение со скобками - это список символов, заключенных в [ и ].
  Оно соответствует любому символу из этого списка;

[^]  если первым символом списка является каретка ^, то оно соответствует любому символу, НЕ ВХОДЯЩЕМУ В СПИСОК.

[Пример:]
  регулярное выражение [0123456789] соответствует любой одиночной цифре.

__(Диапазоны символов в regex)__
  Внутри выражения со скобками выражение диапазона состоит из двух символов, разделенных дефисом.
  Оно соответствует любому символу, который находится между этими двумя символами, ВКЛЮЧИТЕЛЬНО,
  с использованием последовательности коллизии и набора символов локали.

[Пример:]
  в локали C по умолчанию [a-d] эквивалентно [abcd].

  Во многих локалях символы сортируются в словарном порядке,
  и в этих локалях [a-d] обычно НЕ ЭКВИВАЛЕНТЕН [abcd];
  он может быть эквивалентен, например, [aBbCcDd].

[!]  Чтобы получить традиционную интерпретацию выражений со скобками, вы можете использовать локаль C,
     установив переменную окружения LC_ALL в значение C.

__(Ещё один вид выражений со скобками - классы символов)__
  Наконец, в выражениях со скобками предопределены определенные классы символов.
  Их названия не требуют пояснений, это
  [:alnum:]  = строка содержит только буквы и (или) цифры;
  [:alpha:]  = строка содержит только буквы;
  [:cntrl:]  = ?
  [:digit:]  = строка содержит только цифры;
  [:graph:]  = 
  [:lower:]  = строка содержит только буквы нижнего регистра;
  [:print:]  = строка содержит только печатаемые символы;
  [:punct:]  = 
  [:space:]  = строка содержит только пробельные символы;
  [:upper:]  = строка содержит только буквы верхнего регистра;
  <и>
  [:xdigit:] = 
  
[Пример:]
  [[:alnum:]] означает [0-9A-Za-z]
  (!) только последняя форма зависит от локали C и кодировки символов ASCII,
      тогда как первая не зависит от локали и набора символов.

[ОБРАТИТЕ ВНИМАНИЕ:]
  скобки в этих именах классов ([: :]) являются частью символических имен
  и ДОЛЖНЫ БЫТЬ ВКЛЮЧЕНЫ В ДОПОЛНЕНИЕ К СКОБКАМ, ограничивающим выражение со скобками.
[Пример:]
  [[:alnum:]] или [^[:alnum:]]


[!] Большинство метасимволов теряют свое особое значение внутри скобочных выражений.

  Чтобы включить литерал ], поместите его ПЕРВЫМ В СПИСКЕ.
  Аналогично, чтобы включить литерал ^, поместите его куда угодно, только НЕ НА ПЕРВОЕ МЕСТО.
  Наконец, чтобы включить литерал -, поставьте его последним.


************
* Якорение *
************
  Каретка ^ и знак доллара $ - это метасимволы, которые соответствуют пустой строке в начале и конце строки.


*******************************************************
* Символ обратной косой черты и специальные выражения *
*******************************************************

  Символы \< и \> соответственно соответствуют пустой строке в начале и конце слова.
  Символ \b соответствует пустой строке на краю слова, а \B соответствует пустой строке, если она не находится на краю слова.
  Символ \w является синонимом для [[:alnum:]],
  а \W - синонимом для [^[:alnum:]].


**************
* Повторение *
**************
  За регулярным выражением может следовать один из нескольких ОПЕРАТОРОВ ПОВТОРЕНИЯ:

  ?
  => Предшествующий элемент необязателен и используется не более одного раза.

  *
  => Предшествующий элемент будет соответствовать нулю или более раз.

  +
  => Предшествующий элемент будет сопоставлен один или более раз.

  {n}
  => Предшествующий элемент будет встречен ровно n раз.

  {n,}
  => Предыдущий элемент встречается n или более раз.


  {,m}
  => Предшествующий элемент встречается не более m раз.


  {n,m}
  => Предыдущий элемент встречается не менее n раз, но не более m раз.


****************
* Конкатенация *
****************
  Два регулярных выражения могут быть объединены;
  полученное регулярное выражение соответствует любой строке, образованной объединением двух подстрок,
  которые соответственно соответствуют объединенным выражениям.


***************
* Чередование *
***************
  Два регулярных выражения могут быть соединены инфиксным оператором |;
  результирующее регулярное выражение соответствует любой строке, соответствующей любому альтернативному выражению.


*************
* Приоритет *
*************
  ПОВТОРЕНИЕ имеет приоритет над КОНКАТЕНАЦИЕЙ; 
  КОНКАТЕНАЦИЯ, в свою очередь, имеет приоритет над ЧЕРЕДОВАНИЕМ.

  Целое выражение может быть заключено в круглые скобки (...), чтобы отменить эти правила старшинства и сформировать подвыражение.


##############################################
# БАЗОВЫЕ И РАСШИРЕННЫЕ РЕГУЛЯРНЫЕ ВЫРАЖЕНИЯ #
##############################################
  В базовых регулярных выражениях метасимволы ?, +, {, |, ( и ) теряют свое особое значение;
  вместо них используются варианты с обратным слэшем \?, \+, \{, \|, \( и \).

  Традиционный egrep не поддерживал метасимвол `{`, а некоторые реализации egrep вместо него поддерживают `\{`
  => переносимые сценарии должны избегать `{` в шаблонах grep -E и использовать [{] для соответствия литералу {.

  GNU grep -E пытается поддержать традиционное использование, предполагая, что `{` НЕ ЯВЛЯЕТСЯ СПЕЦИАЛЬНЫМ СИМВОЛОМ,
  если он является началом недопустимой спецификации интервала.


Например, команда
---
$ grep -E '{1'
---
  ищет двухсимвольную строку
---
{1
---
  , а не сообщает о синтаксической ошибке в регулярном выражении.
  POSIX.2 допускает такое поведение в качестве расширения, 
[!]  но переносимые сценарии должны его ИЗБЕГАТЬ.


**********************************
* Обратные ссылки и подвыражения *
**********************************
  Обратная ссылка \n
  ,где n - единственная цифра,
  соответствует подстроке, которая ранее была сопоставлена n-му подвыражению регулярного выражения, заключенному в скобки.
