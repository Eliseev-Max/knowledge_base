SonarQube
Installing SonarQube from the Docker image
(https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/install-the-server/#installing-sonarqube-from-the-docker-image)
{more: https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/install-the-server/}


## SonarQube
##  - это ведущий инструмент для непрерывной проверки качества и безопасности кодовых баз,
## а также для руководства работой команд разработчиков в процессе проверки кода.
## Охватывая 27 языков программирования и сопрягаясь с существующим программным конвейером,
## SonarQube предоставляет разработчикам четкие рекомендации по устранению проблем,
## а командам в целом - более качественное и безопасное программное обеспечение.
## Имея более 225 000 деплоев (deployments), помогающих как небольшим командам разработчиков, так и глобальным организациям,
## SonarQube предоставляет всем командам и компаниям по всему миру возможность контролировать качество и безопасность кода.


Docker image SonarQube поддерживают работу 
  • на архитектуре amd64, 
  • на Apple Silicon на базе arm64.

‼ Рекомендуется использовать: Docker Engine v. 20.10 и выше.

Шаги для первой установки:
  1. Создание следующих томов позволяет предотвратить потерю информации 
     - при обновлении до новой версии или 
	 - при переходе на более высокую редакцию:
       • sonarqube_data: содержит файлы данных, такие как встроенная база данных H2 и индексы Elasticsearch
       • sonarqube_logs: содержит журналы SonarQube о доступе, веб-процессе, CE-процессе и Elasticsearch
       • sonarqube_extensions: содержит все установленные вами плагины и, при необходимости, драйвер Oracle JDBC.

    Создать тома с помощью следующих команд:
      $ docker volume create --name sonarqube_data
      $ docker volume create --name sonarqube_logs
      $ docker volume create --name sonarqube_extensions

#‼ Убедиться, что мы используем именно volumes (созданные в приведённом выше примере),
#‼ а не bind mounts
#‼ Использование bind mounts не позволяет плагинам корректно заполняться.

  Пример для запуска с помощью docker-compose.yaml:
  # не факт, что правильный
sonarqube:
  ...
  volumes:
    - ${COMPOSE_BUILD_DIR}/sonarqube/data:/opt/sonarqube/data
    - ${COMPOSE_BUILD_DIR}/sonarqube/logs:/opt/sonarqube/logs
    - ${COMPOSE_BUILD_DIR}/sonarqube/extensions:/opt/sonarqube/extensions

    Драйверы для поддерживаемых баз данных (кроме Oracle) уже предоставлены.
    Если вы используете базу данных Oracle, то вам необходимо добавить драйвер JDBC в том sonar_extensions.
    (Если вдруг БД = Oracle, читать источник, п. 1a, b, c )

  3. Запустить образ со свойствами базы данных, заданными с помощью флага переменной окружения -e:
# Для справки:
# --env, -e  = установить переменные окружения
# --env-file = считать файл с переменными окружения
# Флаги -e, --env и --env-file используются для установки простых (не являющихся массивами) переменных окружения в запускаемом контейнере
# или для перезаписи переменных, определенных в Dockerfile запускаемого образа.
# Вы можете задать переменную и ее значение при запуске контейнера

## $ docker run --env VAR1=value1 --env VAR2=value2 ubuntu env | grep VAR
## VAR1=value1
## VAR2=value2
  
  docker run -d --name sonarqube \
    -p 9000:9000 \
    -e SONAR_JDBC_URL=... \
    -e SONAR_JDBC_USERNAME=... \
    -e SONAR_JDBC_PASSWORD=... \
    -v sonarqube_data:/opt/sonarqube/data \                # примонтировали ранее созданный volume
    -v sonarqube_extensions:/opt/sonarqube/extensions \    # к директории внутри контейнера
    -v sonarqube_logs:/opt/sonarqube/logs \
    <image_name>

# Громоздко и убого...
# То же самое, но через docker-compose.yml

  sonarqube:
    restart: always
    image: 'sonarqube:latest'
    depends_on:
      - master_service
    environment:
      SONAR_JDBC_URL: jdbc:postgresql://database:5432/sonar
      SONAR_JDBC_USERNAME: ${SONARQUBE_DB_USER}
      SONAR_JDBC_PASSWORD: ${SONARQUBE_DB_PASSWORD}
    ports:
      - 9000:9000
    volumes:
      - 'sonarqube_data:/opt/sonarqube/data'
      - 'sonarqube_logs:/opt/sonarqube/logs'
      - 'sonarqube_extensions:/opt/sonarqube/extensions'

#####################################
# SonarQube and PostgreSQL database #
#####################################
{"Installing the SonarQube database":
  https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/install-the-server/installing-the-database/}
  Поддерживается несколько внешних движков (engines) баз данных.
  Требования, указанные к СУБД PostgreSQL (‼обязательны к исполнению):

[!]►
    1. Создайте пустую схему и пользователя sonarqube.
    2. Предоставьте этому пользователю sonarqube права на создание, обновление и удаление объектов для этой схемы.

  # По умолчанию используется схема, называющаяся "public"
    Если вы хотите использовать пользовательскую схему, а не "public",
    → необходимо установить свойство PostgreSQL search_path:
---
ALTER USER mySonarUser SET search_path to mySonarQubeSchema
---

  /opt/sonarqube/conf/sonar.properties
#----- PostgreSQL 11 or greater
# By default the schema named "public" is used.
It can be overridden with the parameter "currentSchema".
#sonar.jdbc.url=jdbc:postgresql://localhost/sonarqube?currentSchema=my_schema



Для установок на базе docker переменные окружения заменяют все параметры, которые были заданы в свойствах.
Более подробную информацию см.:
https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/configure-and-operate-a-server/environment-variables/

Дополнительную информацию об установке и обновлении плагинов SonarQube внутри тома Docker можно найти на странице Install a plugin:
https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/install-a-plugin/


################################
# Особенности работы SonarQube #
################################

  SonarQube запускает процесс Elasticsearch;
  → для процесса Elasticsearch будет использоваться та же учетная запись, под которой запущен сам SonarQube.
  Elasticsearch не может быть запущен от имени root → SonarQube также не может быть запущен под root.
  Для запуска SonarQube необходимо выбрать какую-либо другую учетную запись, не являющуюся root-аккаунтом,
  предпочтительно специально предназначенную для этой цели.


Установка плагинов SonarQube
  Существует 2 способа установки плагинов в SonarQube:
  1. Marketplace: В Community Edition можно автоматически устанавливать плагины с вкладки Administration > Marketplace.
     В коммерческих изданиях можно просматривать подключаемые модули в Marketplace,
	 но УСТАНАВЛИВАТЬ и ОБНОВЛЯТЬ их необходимо ВРУЧНУЮ.

  2. Ручная установка:
     При использовании любой коммерческой версии SonarQube необходимо вручную устанавливать подключаемые модули.
	 Также вручную можно установить подключаемые модули,
	   → если у экземпляра SonarQube нет доступа в Интернет
	     или
	   → если устанавливаемый модуль отсутствует в магазине SonarQube Marketplace

  ‼ Плагины не предоставляются компанией SonarSource; поэтому вы устанавливаете их на свой страх и риск.
    Администратор SonarQube должен подтвердить этот риск в Marketplace перед установкой плагинов
	или при появлении запроса в SonarQube после установки плагина вручную.
	
	Устанавливать и обновлять плагины из Marketplace можно только в SonarQube CE.
	В коммерческих редакциях необходимо устанавливать и обновлять плагины вручную.
	
  Если ваш экземпляр имеет доступ в Интернет и вы подключены к SonarQube под пользователем с глобальным правом Administer System,
  вы можете найти Marketplace по адресу Administration > Marketplace.
  
  Отсюда:
    • Найдите плагин, который вы хотите установить.
    • Нажмите кнопку Install (Установить) и дождитесь завершения загрузки.

После завершения загрузки будет доступна кнопка Restart (Перезапустить), чтобы перезапустить ваш экземпляр. Перезапуск включит новый плагин. При перезапуске не будут учтены изменения в настройках sonar-properties.
	

Установка плагинов SonarQube внутри Docker
  При запуске SonarQube под Docker любой плагин, который вы хотите установить,
  должен быть также скопирован в том Docker, который вы создаете во время установки.
  
  <_Ручная установка плагина в докер-контейнер SonarQube_>
    
	(Имя docker container: sonarqube)

  Самый простой способ ручной установки плагина:
    1. Проверьте, существует ли данная версия плагина.
	  Выполните команду
	  $ docker exec sonarqube bash -c 'ls "$SONARQUBE_HOME"/extensions/plugins'
	  , чтобы увидеть весь список плагинов, устанавливаемых вручную.
    
	2. Если в списке присутствует предыдущая версия плагина, удалите ее с помощью:
	  $ docker exec sonarqube bash -c 'rm "$SONARQUBE_HOME"/extensions/plugins/<PLUGIN_JAR_FILE_NAME>'.
	  
    3. Установите новый плагин с помощью:
	  $ docker exec sonarqube bash -c 'wget <PLUGIN_JAR_URL> -P "$SONARQUBE_HOME"/extensions/plugins/'
    
	4. Перезапустите docker-контейнер SonarQube с помощью команды:
	  $ docker restart sonarqube

# -c string Если присутствует опция -c, то команды считываются из строки.
# Если после строки имеются аргументы, то они присваиваются позиционным параметрам, начиная с $0.

  ‼ Внимание:
    если вы следовали рекомендациям, изложенным на этой странице, то полученный плагин будет доступен в томе sonarqube_extensions,
	который вложен в папку <SONARQUBE_HOME>/extensions/plugins.

{Prerequisites and overview: https://docs.sonarsource.com/sonarqube/latest/requirements/prerequisites-and-overview/}
{Jenkins extension for SonarQube:https://docs.sonarsource.com/sonarqube/latest/analyzing-source-code/scanners/jenkins-extension-sonarqube/}

---
Prerequisites and overview (Необходимые условия и обзор)

  ‼ На машине, где планируется запуск SonarQube, должна быть возможность установки Java (Oracle JRE или OpenJDK)

< Требования к аппаратному обеспечению >

  Для эффективной работы небольшого экземпляра сервера SonarQube (индивидуального или для небольшой команды) требуется:
    • не менее 2 ГБ оперативной памяти и
    • 1 ГБ свободной оперативной памяти для ОС.
  
  Если вы устанавливаете экземпляр для большой команды или предприятия, обратите внимание на дополнительные рекомендации, приведенные ниже.
  
  ‼ Объем необходимого дискового пространства зависит от объема кода, который вы анализируете с помощью SonarQube.
    SonarQube должен быть установлен на жестких дисках с отличной производительностью чтения и записи.
      Наиболее важным является то, что в папке "data" хранятся индексы Elasticsearch,
    по которым при работе сервера будет выполняться огромное количество операций ввода-вывода.
    Поэтому производительность жестких дисков при чтении и записи будет оказывать большое влияние на общую производительность сервера SonarQube.

< Рекомендации по аппаратному обеспечению для предприятий >

  Для больших команд или корпоративных инсталляций SonarQube требуется дополнительное оборудование.
  На уровне предприятия мониторинг экземпляра SonarQube имеет большое значение и должен определять дальнейшую модернизацию оборудования по мере роста экземпляра.
  Начальная конфигурация должна включать как минимум:
    • 8 ядер, чтобы основная платформа SonarQube могла работать с несколькими рабочими вычислительными машинами.
    • 16 ГБ оперативной памяти.
  
  Дополнительные требования и рекомендации, касающиеся баз данных и Elasticsearch, см. в разделе "Рекомендации по аппаратному обеспечению"
  (https://docs.sonarsource.com/sonarqube/latest/requirements/hardware-recommendations/)

< Поддерживаемые платформы >
  - для работы SonarQube server требуется Java версии 17;
  - для работы SonarQube Scaner минимальная рекомендуемая версия - Java 17. Java 11 в качестве среды выполнения сканера устарела.

SonarQube способен анализировать исходные файлы Java любого типа, независимо от версии Java, которой они соответствуют.

  ‼ Подходящие версии PostgreSQL: 11...15


**************************
* Примечания к платформе *
**************************
(https://thetechdarts.com/how-to-change-default-vm-max_map_count-on-linux/)
---
Когда мы запускаем сервер SonarQube, он внутренне инициирует elasticsearch.
Для оптимального запуска elasticsearch необходимо пройти несколько загрузочных проверок.
---
  Если мы запускаем SonarQube на Linux, мы должны убедиться в том, что:
    • vm.max_map_count    → больше либо равно 524288;
    • fs.file-max         → больше либо равно 131072;
    • пользователь, запускающий с SonarQube может открыть не менее 131072 файловых дескрипторов;
    • пользователь SonarQube может открыть не менее 8192 потоков
---  
  ‼ Elasticsearch по умолчанию использует каталог mmapfs для хранения индексов,
    и ограничение операционной системы по умолчанию для счетчиков mmap может привести к нехватке памяти.
  ‼ Максимальное количество виртуальных областей памяти vm.max_map_count [65530] слишком мало,
    увеличьте хотя бы до [262144] (→524288).
****
[‼] Проверить значения файловых дескрипторов (open files) и vm.max_map_count

--<Просмотр текущего размера файловых дескрипторов:>--
$ ulimit -a
---

--<для просмотра жёстких значений:>--
$ ulimit -Hn
---

--<для просмотра мягких значений:>--
$ ulimit -Sn
---

--<Просмотр размера vm.max_map_count:>--
$ sudo sysctl -a|grep vm.max_map_count
---

--<Просмотр максимального количества дескрипторов файлов в Linux (=ограничение на кол-во открытых файлов):>--
$ cat /proc/sys/fs/file-max
---
##<или>
$ sudo sysctl fs.file-max
---

#→ в нашем случае значение fs.file-max = 9223372036854775807

## Дескрипторы файлов представляют собой максимальное количество файлов, открытых отдельными пользователями Linux за сеанс.

[?] Почему elasticsearch требует увеличения значения vm.max_map_count
>  Это увеличение виртуальной памяти требуется elastic search,
   так как внутри elasticsearch использует карты памяти или mmapfs для хранения файлов,
   для которых ему требуется виртуальная память.
   Elasticsearch потребляет много карт памяти, поэтому меньшее значение может привести к тому,
   что система будет выдавать ошибки о нехватке памяти, когда процесс достигнет предела.
   Однако следует помнить, что увеличение этого лимита приведет к увеличению потребления памяти в системе,
   поскольку дополнительная память будет расходоваться на карты памяти.
   Чтобы elasticsearch работал без сбоев, нам необходимо:
   ‼ выделить виртуальную память для самого elasticsearch.

  → проверить текущее значение vm.max_map_count для своей системы:
  $ sudo sysctl vm.max_map_count
---

  Мы можем увидеть эти значения, выполнив следующие команды:
    $ sysctl vm.max_map_count
    $ sysctl fs.file-max
    $ ulimit -n
    $ ulimit -u

••••••••••••••••••••••••••••
• Редактирование значений: •
••••••••••••••••••••••••••••


1) для текущего сеанса (динамически):
#[!] выполнять команды от имени root:

--[COMMAND]--
sysctl -w vm.max_map_count=524288
sysctl -w fs.file-max=131072
ulimit -n 131072
ulimit -u 8192
---

2) установка значений на более длительное время:
#  => необходимо обновить файл:

#:>
/etc/sysctl.d/99-sonarqube.conf
  <или>
#:>
/etc/sysctl.conf

# (по своему усмотрению)
# чтобы они отражали эти значения.

---
# /etc/sysctl.conf = Configuration file for setting system variables
# See /etc/sysctl.d/ for additional system variables.
---

#[!]  `/etc/sysctl.conf` = постоянная модификация

  Если пользователь, запускающий SonarQube (в данном примере sonarqube),
  не имеет права иметь не менее 131072 открытых дескрипторов,
  необходимо вставить эту строку в файл /etc/security/limits.d/99-sonarqube.conf 
  (или /etc/security/limits.conf по вашему усмотрению):
---
sonarqube   -   nofile   131072
sonarqube   -   nproc    8192
---
  Если для запуска SonarQube используется systemd:
---
[Service]
...
LimitNOFILE=131072
LimitNPROC=8192
...
---

( more:
    https://ru.linux-console.net/?p=14234&ysclid=lq6myeboub396729330
    https://russianblogs.com/article/88971116389/
)

< seccomp filter >
  по умолчанию Elasticsearch использует seccomp filter.
  Убедиться, что мы используем ядро с включенным seccomp, можно следующим образом:
  $ grep SECCOMP /boot/config-$(uname -r)
  # если ядро имеет seccomp, мы увидим следующее:

CONFIG_HAVE_ARCH_SECCOMP_FILTER=y
CONFIG_SECCOMP_FILTER=y
CONFIG_SECCOMP=y

--- Подробнее о seccomp ---
(https://www.kernel.org/doc/Documentation/prctl/seccomp_filter.txt)
  Введение
------------

Каждый пользовательский процесс имеет большое количество системных вызовов,
причем многие из них остаются неиспользованными в течение всего времени существования процесса.
По мере изменения и развития системных вызовов в них обнаруживаются и устраняются ошибки.
Определенное подмножество пользовательских приложений выигрывает от уменьшения набора доступных системных вызовов. 
Полученный набор уменьшает общий слой ядра, доступный приложению.
Фильтрация системных вызовов предназначена для работы с такими приложениями.

Фильтрация Seccomp предоставляет процессу возможность задать фильтр для входящих системных вызовов.
Фильтр выражается в виде программы Berkeley Packet Filter (BPF), как и в случае с фильтрами сокетов,
за исключением того, что данные, с которыми оперируют, относятся к выполняемому системному вызову: номер системного вызова и аргументы системного вызова.
Это позволяет осуществлять выразительную фильтрацию системных вызовов с помощью языка программ-фильтров,
имеющего долгую историю обращения к пользовательской среде и простой набор данных.

Кроме того, BPF не позволяет пользователям seccomp стать жертвой атак типа time-of-check-time-of-use (TOCTOU),
характерных для фреймворков интерпозиции системных вызовов.
BPF-программы не могут разыменовывать указатели, что ограничивает все фильтры только непосредственной оценкой аргументов системного вызова.

Чем она не является
-------------

Фильтрация системных вызовов - это не "песочница".
Она предоставляет четко определенный механизм для минимизации открытой поверхности (слоя) ядра.
Она предназначена для использования разработчиками "песочниц".
Кроме того, управление политикой логического поведения и потоком информации должно осуществляться с помощью комбинации других методов защиты системы и,
возможно, с помощью LSM по вашему выбору.
Выразительные динамические фильтры предоставляют дополнительные возможности на этом пути
(например, не допускать патологических размеров или выбирать, какой из мультиплексированных системных вызовов в socketcall() разрешен),
что может быть ошибочно истолковано как более полное решение "песочницы".

---< SonarQube logging >---
(https://docs.sonarsource.com/sonarqube/latest/setup-and-upgrade/configure-and-operate-a-server/environment-variables/#logging)

SonarQube создает журналы в четырех файлах журналов, расположенных в одной директории
(см. свойство SONAR_PATH_LOGS ниже), по одному на процесс:

  • Главный процесс (он же App) ведет журнал в файле sonar.log
  • Веб-сервер (он же Web) записывает журнал в web.log
  • Compute Engine (aka. CE) ведет журнал в ce.log
  • Elasticsearch (aka. ES) ведет журнал в es.log

Все четыре файла подчиняются одной и той же политике
(см. SONAR_LOG_ROLLINGPOLICY и SONAR_LOG_MAXFILES),
но применяются по отдельности (например, если SONAR_LOG_MAXFILES=4, то может быть не более 4 файлов, т.е. всего 16 файлов).

Формат логов, уровни логирования и другие настройки: см.статью.
