Копирование коммитов. git cherry-pick
[source: https://www.youtube.com/watch?v=TZJxBSfR0NE]

Команда git cherry-pick позволяет копировать коммиты.
‼ Требование:
	рабочее дерево было чистым (никаких изменений после коммита HEAD).
	Cherry picking в Git означает выбрать коммит из одной ветки и применить его к другой.

Самый частый случай использования cherry-pick:
  - есть 2 ветки:
    • ветка для версии 1.0 (последний коммит - C) (v1.0)
	• ветка для версии 2.0 (последний коммит - F) (v2.0)
  
  - обнаружена ошибка в файле, который есть в обоих ветках.

	Наши действия:
	→ исправляем ошибку в одной ветке (v1.0);
	→ делаем commit (новый коммит - D);
	→ копируем новый коммит на ветку v2.0:
		$ git cherry-pick D
	# cherry-pick берёт изменения нового коммита (diff между C и D)
	# и применяет их к текущей ветке v2.0, создавая новый коммит D'

	D и D' - это эквивалентные коммиты.
	Они взаимно независимы, НО содержат одинаковые изменения.

Отличие cherry-pick от слияния (merge) и перебазирования (rebase):
	- слияние (git merge D) объединяет ветки целиком == вносит все изменения одной ветки в другую
	- rebase также применяет множество коммитов к другой ветке.


Копированием коммитов (как и прочим дублированием) лучше не злоупотреблять.
Альтернативное решение проблемы:
	• создаём новую ветку от того же коммита, от которого ответвилась v1.0 (коммит B)
		($ git checkout -b fix B)
	• вносим изменения в новую ветку
	• коммитим изменения в ветку (fix)
	• мерджим коммит и в v1.0, и в v2.0

Пример: cherry-pick в действии [00:02:03]
	Имеем 2 ветки: feature и master
	Находимся на ветке master
	$ git cherry-pick <hash_of_commit_on_feature_branch>
	→ создан новый коммит с уникальным хешем на вершине ветки master
	
Сравнение коммитов:
  [на ветке master] → $ git show --no-decorate
  [для feature]     → $ git show <hash_of_commit>
  
  Коммиты идентичны за исключением:
	- идентификаторов
	- имя и дата коммиттера у нового коммита
	
	$ git show --pretty=fuller --quiet
	# выведет имя и дату создания для автора и имя и дату для коммиттера

Как понять, где оригинал, а где копия?
	$ git cherry-pick -x
	# команда добавит в описание коммита строку с информацией, откуда он был скопирован.

cherry-pick может копировать не один, а сразу несколько коммитов и даже целую ветку.
Для этих целей можно:
	1. указать хеши нескольких коммитов
	2. указать диапазон (например, $ git cherry-pick master..feature),
	   где master и feature - названия веток

‼ cherry-pick выполняет слияние файлов, когда накладывает изменения одного коммита на другое состояние проекта.
Поэтому в процессе cherry-picking-а могут возникнуть конфликты.

Команды на случай возникновения конфликта:
	1. $ git cherry-pick --abort
		- отменит уже скопированные коммиты и вернёт всё в состояние до cherry-pick
		‼ отменяет только неоконченное копирование!
	
	2. $ git cherry-pick --continue
		- продолжить выполнение cherry-pick. Не сработает, если обнаружен конфликт при слиянии.
	
	3. $ git cherry-pick --quit
		- остановиться там, где мы находимся сейчас, и сбросить запомненное состояние;
		= прекратить выполнение cherry-pick.

Удалить завершённый cherry-pick можно с помощью $ git reset --hard
	- если скопирован один коммит => reset на 1 шаг назад:
	  $ git reset --hard @~
	
	- если скопировано 2 коммита => на 2 шага назад:
	  $ git reset --hard @~2
	
	- если не очень понятно, что произошло → reflog:
	  $ git reflog --no-decorate <-n>
	  # выведет последние n записей

Как добавить изменения в индекс ветки БЕЗ КОММИТА?
  (например, добавить изменения в ветку master, но немного их подредактировать):
    --no-commit, -n:
	$ git cherry-pick --no-commit <hash_index>
	(==$ git cherry-pick -n <hash_index>)

  Посмотреть внесённые изменения можно с помощью:  $ git diff --cached 
