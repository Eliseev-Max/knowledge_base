Копирование коммитов. git cherry-pick
[source: https://www.youtube.com/watch?v=TZJxBSfR0NE]

Команда git cherry-pick позволяет копировать коммиты.

Самый частый случай использования cherry-pick:
  - есть 2 ветки:
    • ветка для версии 1.0 (последний коммит - C) (v1.0)
	• ветка для версии 2.0 (последний коммит - F) (v2.0)
  
  - обнаружена ошибка в файле, который есть в обоих ветках.

	Наши действия:
	→ исправляем ошибку в одной ветке (v1.0);
	→ делаем commit (новый коммит - D);
	→ копируем новый коммит на ветку v2.0:
		$ git cherry-pick D
	# cherry-pick берёт изменения нового коммита (diff между C и D)
	# и применяет их к текущей ветке v2.0, создавая новый коммит D'

	D и D' - это эквивалентные коммиты.
	Они взаимно независимы, НО содержат одинаковые изменения.

Отличие cherry-pick от слияния (merge):
	- слияние (git merge D) объединяет ветки целиком == вносит все изменения одной ветки в другую

Копированием коммитов (как и прочим дублированием) лучше не злоупотреблять.
Альтернативное решение проблемы:
	• создаём новую ветку от того же коммита, от которого ответвилась v1.0 (коммит B)
		($ git checkout -b fix B)
	• вносим изменения в новую ветку
	• коммитим изменения в ветку (fix)
	• мерджим коммит и в v1.0, и в v2.0

Пример: cherry-pick в действии [00:02:03]
	Имеем 2 ветки: feature и master
	Находимся на ветке master
	$ git cherry-pick <hash_of_commit_on_feature_branch>
	→ создан новый коммит с уникальным хешем на вершине ветки master
	
Сравнение коммитов:
  [на ветке master] → $ git show --no-decorate
  [для feature]     → $ git show <hash_of_commit>
  
  Коммиты идентичны за исключением:
	- идентификаторов
	- имя и дата коммиттера у нового коммита
	
	$ git show --pretty=fuller --quiet
	# выведет имя и дату создания для автора и имя и дату для коммиттера

Как понять, где оригинал, а где копия?
	$ git cherry-pick -x
	# команда добавит в описание коммита строку с информацией, откуда он был скопирован.

...
	