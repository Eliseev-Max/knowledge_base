Различия между git rebase и git merge --ff-only
{git rebase: https://git-scm.com/docs/git-rebase}

‼ git rebase выполняет иную задачу, чем git merge (с или без --ff-only).
Что делает rebase, так это берет существующие коммиты и копирует их.
---
...-○--○--A--B        <-- HEAD=branch1
        \
         ○--C         <--branch2
---

Предположим, например, что мы находимся на ветке1 и сделали два коммита A и B.
Мы решаем, что лучше, чтобы эти два коммита находились в ветке2.
Как можно этого добиться:
  • получить список изменений, сделанных в A (diff A относительно его родителя)
  • получить список изменений, сделанных в B (diff B относительно A)
  • переключиться на ветку2
  • внести те же изменения, что и в A, и зафиксировать их (commit), скопировав сообщение о фиксации из A; назовем эту фиксацию A'
  • а затем сделайте те же изменения, которые вы внесли в B, и зафиксируйте их, скопировав сообщение о фиксации из B; назовем это B'.

Существует команда git, которая делает это разделение, а затем копирование и коммит за вас:
  $ git cherry-pick

Итак:
    git checkout branch2      # switch HEAD to branch2 (commit C)
    git cherry-pick branch1^  # this copies A to A'
    git cherry-pick branch1   # and this copies B to B'

---
...-o--o--A--B         <-- branch1
        \
         o--C--A'-B'   <-- HEAD=branch2
---

Теперь можно переключиться обратно на ветку1 и удалить исходные A и B, используя git reset
(здесь я использую --hard, так удобнее, так как очищается и рабочее дерево):
  $ git checkout branch1
  $ git reset --hard HEAD~2

Это действие удаляет исходные A и B,1, так что теперь имеем следующее:
---
...-o--o               <-- HEAD=branch1
        \
         o--C--A'-B'   <-- branch2
---

Теперь, чтобы продолжить работу в ветке2, нужно просто перепроверить (re-check-out) её.
Именно это и делает git rebase: он "перемещает" коммиты
##(хотя на самом деле не перемещает, потому что не может:
## в git коммит никогда не может быть изменен, поэтому даже простое изменение родительского идентификатора требует копирования его в новый и немного другой коммит).

Другими словами, если git cherry-pick - это автоматический diff-and-redo одного коммита,
то git rebase - это автоматизированный процесс переделки нескольких коммитов, плюс, в конце, перемещение меток, чтобы "забыть" или спрятать оригиналы.

Выше показано перемещение коммитов из одной локальной ветки branch1 в другую локальную ветку branch2,
но git использует точно такой же процесс для перемещения коммитов, когда у вас есть удалённая отслеживаемая ветка,
которая приобретает новые коммиты при выполнении git fetch (включая fetch, который является первым шагом git pull).

Мы можем начать с работы над веткой feature, которая имеет восходящий поток origin/feature, и сделать несколько собственных коммитов:
---
...-o        <-- origin/feature
     \
      A--B   <-- HEAD=feature
---
Но затем вы решаете, что нужно посмотреть, что произошло выше по течению (upstream), и выполняете git fetch,2,
и, ага! Кто-то выше по течению написал коммит C:

---
...-o--C     <-- origin/feature
     \
      A--B   <-- HEAD=feature
---
В этот момент вы можете просто перестроить функции A и B на C, получив:
---
...-o--C     <-- origin/feature
        \
         A'-B'  <-- HEAD=feature
---
Это копии ваших оригиналов A и B, причем оригиналы после завершения копирования выбрасываются (но см. сноску [1]).

Иногда перебазировать нечего, т.е. нет работы, которую вы сами выполнили.
То есть график перед выборкой (fetch) выглядит следующим образом:
---
...-o      <-- origin/feature
           `-- HEAD=feature
---

Однако если затем выполнить git fetch и закоммитить C,
то ваша ветвь feature будет указывать на старый коммит, в то время как origin/feature продвинулась вперед:
---
...-o--C   <-- origin/feature
     `---- <-- HEAD=feature
---
Вот тут-то и приходит на помощь git merge --ff-only:
если вы попросите объединить вашу текущую ветку feature с origin/feature, git увидит, что можно просто передвинуть стрелку вперед,
так что feature будет указывать непосредственно на коммит C.
Никакого реального слияния не требуется.

Если же у вас есть собственные коммиты A и B, и вы просите объединить их с C
git выполнит настоящее слияние (merge), создав новый коммит M:
---
...-o--C        <-- origin/feature
     \   `-_
      A--B--M   <-- feature
---
Здесь --ff-only остановится и выдаст ошибку.
Rebase, с другой стороны, может скопировать A и B в A' и B', а затем скрыть оригинальные A и B.

git rebase и fast-forward просто делают разные вещи.
Иногда результат один и тот же, а иногда нет.
  -> Если копировать A и B можно, то можно использовать git rebase;
  -> если же есть какая-то веская причина не копировать их, то можно использовать git merge, возможно, с параметром --ff-only,
  чтобы слить или не слить в зависимости от ситуации.

[1] Git действительно хранит оригиналы в течение некоторого времени - обычно месяца в данном случае - но прячет их.
Проще всего найти их с помощью "рефлогов" git'а, которые хранят историю того, куда указывала каждая ветка и куда указывал HEAD,
перед каждым изменением, обновлявшим ветку и/или HEAD.

В конце концов, срок действия записей в истории reflog истекает, и тогда эти коммиты становятся пригодными для сборки мусора.

[2] Или, опять же, можно использовать git pull, который представляет собой удобный скрипт, начинающийся с выполнения git fetch.
После завершения выборки скрипт запускает либо git merge, либо git rebase, в зависимости от того, как вы его настроили и запустили.