Оркестрация и взаимодействие контейнеров. Docker Compose

[00:06:41]	Recap (Освежим знания, полученные на предыдущей лекции)

		[Dockerfile] → Build → [Image] → Run → [Container]
		
	docker build [-t, --tag] [-f, --file] context - создание образа
	docker run [--rm] [-it] <image>				  - создаёт и запускает новый контейнер
	docker stop/kill			  				  - остановить контейнер (SIGTERM + SIGKILL / SIGKILL)
	
	Базовые команды
	
	docker ps [-a, --all]				- вывести список контейнеров
	docker images						- вывести список образов
	docker exec [-it] <container-id>	- выполнить команду внутри РАБОТАЮЩЕГО контейнера
	docker rm <container-id>			- удалить контейнер
	docker rmi <image>					- удалить image из системы
	docker inspect [-f, --format] <container-id> - информация о контейнере
	docker inspect --format='{{.Config.Image}}' <container-id>
	
	__Директивы Dockerfile__
		FROM
		RUN
		WORKDIR
		ADD
		COPY
		CMD
		ENTRYPOINT

[00:10:13]	Директива EXPOSE
	
	EXPOSE - сообщает Docker engine о том, что в данном контейнере будет существовать процесс,
			 прослушивающий заданный порт или несколько портов
		Сама директива не несёт непосредственной практической нагрузки (ничего не открывает)
		Директива EXPOSE используется как ДОКУМЕНТАЦИЯ.
		Пользователь будет понимать, что ему нужно будет примапить/открыть порт
		
	При запуске контейнера нужно указать маппинг портов хоста и контейнера
		$ docker run -p {HOST_PORT}:{CONTAINER_PORT} image
		-p = динамический выбор порта
		Такая команда ПЕРЕНАПРАВЛЯЕТ ПОРТЫ ХОСТА В КОНТЕЙНЕР
		
[00:21:20]	Manage data
	
	Работа с данными
	• Bind mounts - данные хранятся в произвольном месте файловой системы
	• Volumes (Тома) - часть файловой системы хоста, управляемой Docker
	• tmpfs mounts - данные хранятся в RAM хоста		# удобно для хранения конфиденциальных данных
(см. рисунок)

[00:24:28]	Bind mounts
	Bind mounts - монтирование локальных директориев / файлов хоста
	docker run -v {HOST_DIR}:{CONTAINER_DIR} <image>
	
	Варианты использования:
		• Шаринг конфигурационных файлов между хостом и контейнером
		• Шаринг исходного кода либо артефактов билдов между хостом и контейнером
		
[00:27:31]	Настройка Bind mounts
		Когда используется Bind mounts, необходимо использовать полный путь, а не относительный
			$ docker run --rm -it -v /users/agridyaev/OTUS/docker2/py_server:/app py_server sh
			
		При выполнении команды попадаем внутрь конейнера, выполняется интерпретатор shell (sh)
		Когда мы создаём Bind mounts для директория, которого нет на хосте, он создаётся
		Bind mounts перекрывает содержимое того, что уже есть в контейнере (содержится в Dockerfile).
		Таким образом,
			• все файлы, уже существующие в {HOST_DIR}, становятся доступными внутри контейнера;
			• если каталог {CONTAINER_DIR} ранее существовал в контейнере, его содержимое будет скрыто созданным томом;
			• никакие файлы из образа не копируются в том;
			• этот том не будет удалён механизмом Docker ($ docker rm -v )

[00:33:33]	Volumes (тома)
		они более гибкие, чем Bind mounts
	Volumes - механизм для постоянного хранения данных, созданных и используемых контейнерами.
	Тома Docker - это каталоги, которые НЕ ЯВЛЯЮТСЯ частью файловой системы UnionFS конкретного контейнера,
				  а представляют собой обычные каталоги в файловой системе хоста, но могут быть смонтированы
				  как отдельные файловые системы (bind mounting) внутри контейнера.
	
	Варианты использования:
		• шаринг данных между несколькими контейнерами
		• когда предполагается удалённое хранение данных контейнера (удалённый хост или облако)
		• когда может потребоваться backup/restore данных контейнера или миграция на другой Docker-хост
	
	$ docker volume ls										# Посмотреть список volumes в системе
	$ docker volume inspect [OPTIONS] {VOLUME} [VOLUME...]	# Показать подробную информацию об одном [или более] томов
	
	Можно находясь на хосте, создать/скопиовать файл в том, и он появится в контейнере:
		$ sudo touch /var/lib/docker/{путь/до/volume} <filename>
		
	Анонимный Volume (Anonymous volumes)
	
	Создание:
	  1. Опция -v в docker run 
		docker run -v {CONTAINER_DIR} image
		Пример:
		$ docker run [--rm] -it -v /app py_server sh	# в системе создаётся volume с ID
														# с флагом --rm контейнер удаляется вместе с volume
	  2. Директива VOLUME в файле Dockerfile:
		VOLUME /data
	Удаляется при использовании опции --rm вместе с docker run
	Любая инструкция, расположенная после инструкции VOLUME в Dockerfile, не произведёт никаких изменений в этом томе.
	Пример:
		FROM debian:bookworm
		RUN useradd foo
		VOLUME /data
		RUN touch /data/x				# инструкция запустится в томе временного контейнера
		# Том /x будет удалён после выполнения команды
		RUN chown -R foo:foo /data		# изменения в томе не сохранятся
	
	Backup
		Совместно использовать данные (том) двумя и более разными контейнерами:
			--volumes-from <CONTAINER>
			
		# запускаем контейнер, указываем ему анонимный volume
		docker run --name py_server -v /py_vol py_srv
		# запускаем промежуточный контейнер, монтируем volume предыдущего контейнера промежуточному конейнеру
		docker run --rm --volumes-from py_srv -v $(pwd)/backup:/backup ubuntu:20.04		
		tar cvf /backup/backup.tar /py_vol			# создаём архив
		tar -tvf backup/backup.tar					# разархивирование архива
	!!! способ работает вне зависимости от того, активен ли в текущий момент контейнер, содержащий тома.
	│► Том НЕВОЗМОЖНО УДАЛИТЬ, пока существует хотя бы один контейнер, установивший связь с этим томом ◄│
	
	* Явное указание связываемого каталога хоста в аргументе -v команды run
		$ docker run -v {HOST_DIR}:{CONTAINER_DIR}			# = Bind Mounts
	Этот способ НЕЛЬЗЯ использовать в Dockerfile!
		т.к. он нарушает принцип переносимости и создаёт угрозу безопасности
		
	$ docker volume inspect <container-id>		# информация о volume
	Удалить неиспользуемые volumes:
	$ docker volume prune
	
[00:47:51]	Именованные volumes (Named volumes)
		гораздо удобнее анонимных volumes
	docker volume create {VOLUME}				# {VOLUME} - задаваемое нами имя
	docker volume inspect {VOLUME}
	docker run -v {VOLUME}:{CONTAINER_DIR} <image>
	docker inspect {CONTAINER} -f '{{(index.Mounts 0).Name}}'		# просто форматирование вывода
	
	Пример:
	$ docker volume create py_vol						# создаём volume
	$ docker run -it -v py_vol:/app py_server sh		# монтируем созданный volume внутрь контейнера
	
	# запустим ещё один контейнер и пробуем подключить к нему созданный volume
	$ docker run -it -v py_vol:/app another_server sh
	
	!!! Флаг --link устарел (=Legacy feature)!
	
[00:54:30]	Networking, типы драйверов
	
	Networking-драйверы:
	• bridge - используется для контейнеров, которым нужно сетевое взаимодействие в изолированных сетях (=default)
	• host - для контейнеров с возможностью доступа к сети хоста
	• overlay - для взаимодействия контейнеров на разных хостах
	• macvlan - возможность установки контейнеру MAC-адреса
	• none - для контейнеров без доступа к сети
	
	$ docker network ls
	$ docker network create [-d bridge] <network_name>
	$ docker network inspect <network_name>
	
	Без настройки невозможно обратиться к контейнеру по имени, только по IP
	
[01:05:57]	bridge networks
	
	Отличия default bridge и user-defined bridge network
		• User-defined сети обеспечивают возможность обращения по DNS-имени
		• User-defined сети обеспечивают лучшую изоляцию
		• Контейнеры можно на лету подключать/отключать к/от user-defined сети
	
	Команды:
		docker network connect <network> <container>
		docker network disconnect <network> <container>
		
	Пример:
		# отсоединим контейнер от дефолтной сети
		$ docker network disconnect bridge <container_name>
	
	ЕСТЬ User-defined подсеть == есть взаимодействие между контейнерами по их DNS-именам

	Различия между пользовательским bridge и bridge по умолчанию
	[https://docs.docker.com/network/bridge/#differences-between-user-defined-bridges-and-the-default-bridge]
	
	• User-defined bridge обеспечивают автоматическое разрешение DNS между контейнерами.
		Контейнеры в сети bridge по умолчанию могут обращаться друг к другу только по IP-адресам. (в отсутствии устаревшего флага --link)
		В определяемой пользователем сети bridge контейнеры могут разрешать доменные имена друг для друга по имени или алиасу.
		По суть --link создаёт ссылку на контейнер. Ссылка однонаправленная, чтобы два контейнера могли взаимодействовать
		друг с другом, необходимо создать 2 ссылки.
		Если контейнеров больше, чем 2, линкование сильно усложняется. Поэтому от --link отказались.

    • User-defined bridge обеспечивают лучшую изоляцию.
		Все контейнеры, для которых не указан параметр --network, присоединяются к сети bridge по умолчанию.
		"-" несвязанные стеки / службы / контейнеры могут обмениваться данными.
		Использование определяемой пользователем сети обеспечивает сеть с ограниченной областью действия, в которой только контейнеры,
		подключенные к этой сети, могут обмениваться данными.

    • Контейнеры можно подключать и отсоединять от пользовательских сетей "на лету".
		В течение срока службы контейнера вы можете на лету подключать или отключать его от пользовательских сетей.
		Чтобы удалить контейнер из сети default bridge, вам необходимо:
			1. остановить контейнер
			2. запустить контейнер с другими параметрами сети.

    • Каждая определяемая пользователем сеть создает настраиваемый bridge.
		Если ваши контейнеры используют default bridge, вы можете настроить ее,
		но все контейнеры используют одни и те же настройки, такие как правила MTU и iptables.
		Кроме того, настройка сети default bridge происходит вне самого Docker и требует перезапуска Docker.
		* MTU = Maximum Transmission Unit  - это максимальный объём данных, который может быть передан протоколом
			    за одну итерацию. 
		 (Например, Ethernet MTU = 1500, т.е. максимальный объём данных, переносимый Ethernet фреймом, не может превышать 1500 байт
		  без учёта заголовка и FCS)
		 MTU  означает максимальный размер полезного блока данных одного пакета (англ. payload),
			  который может быть передан протоколом без фрагментации.
			  
    User-defined сети создаются и настраиваются с помощью docker network create.
	
    • !Связанные контейнеры в переменных среды общего доступа к сети моста по умолчанию.

    Первоначально единственным способом обмена переменными среды между двумя контейнерами было их связывание с помощью флага --link. Этот тип совместного использования переменных невозможен в пользовательских сетях. Однако есть более совершенные способы совместного использования переменных среды. Несколько идей:

        ♦ Несколько контейнеров могут монтировать файл или каталог, содержащий общую информацию, с помощью тома Docker.

        ♦ Несколько контейнеров могут быть запущены вместе с помощью docker-compose, а файл compose может определять общие переменные.

        ♦ Вы можете использовать службы роя вместо автономных контейнеров и воспользоваться преимуществами общих секретов и конфигураций.

Контейнеры, подключенные к одной и той же определяемой пользователем сети мостов, эффективно открывают все порты друг другу. Чтобы порт был доступен для контейнеров или хостов, не относящихся к Docker, в разных сетях, этот порт должен быть опубликован с помощью флага -p или --publish.
	
	
[01:13:15]	Docker Compose
	
	docker-compose - утилита для создания и запуска многоконтейнерных приложений
	
	Для описания конфигурации используется YAML-формат
	
	docker-compose build - создать многоконтейнерный образ
	docker-compose up (--build) - запустить образ
	docker-compose rm - удалить конейнеры
	
	docker-compose up --abort-on-container-exit && docker-compose rm -fsv
		Опция --abort-on-container-exit следит за работой контейнеров и завершает работу всех контейнеров, когда
		работа хотя бы одного из них завершена.
РАЗЪЯСНЕНИЯ К ДИРЕКТИВАМ DOCKER-COMPOSE ФАЙЛА

https://docs.docker.com/network/
https://karthi-net.medium.com/docker-tutorial-build-docker-images-using-jenkins-d2880e65b74
