Иан Милл, Эйдан Хобсон Сейерс, "Docker на практике"
------------------------------------------------------

2.2 Демон Docker
[Метод 2]: Запуск контейнеров в качестве демонов

Запуск контейнеров Docker в качестве служб с предсказуемым поведением через программную изоляцию
является одним из основных вариантов использования Docker.
Речь идёт о запуске контейнера Docker в фоновом режиме как службы.

-> использовать флаг -d (--detach)
$ docker run -d
# Run container in background and print container ID

Целиком команда выглядит так:
$ docker run -d -i -p 1234:1234 --name daemon <docker-image> nc -l 1234

  -d = запуск контейнера в фоновом режиме
  -i = даёт контейнеру возможность взаимодействовать с сеансом Telnet
  -p 1234:1234 = опубликовать порт 1234 из контейнера на хост
  --name = присвоить контейнеру имя
  nc -l 1234 = запустить простой прослушивающий эхо-сервер netcat (nc) на порту 1234

#=> теперь можно подключиться к контейнеру daemon и отправлять сообщения через Telnet.
($$ telnet localhost 1234)
  Результат, что контейнер получил сообщения, можно увидеть с помощью команды
$ docker logs daemon


(?) Что происходит со службой, если она не работает/останавливается/продолжает давать сбой снова и снова?

(>) Флаг --restart команды docker run позволяет применить набор правил,
    которым необходимо следовать, когда контейнер завершается
    (= стратегия повторного запуска)

[Значения:]
  --restart=no  - не перезапускать при выходе контейнера;
  --restart=always  - всегда перезапускать при выходе контейнера;
  --restart=unless-stopped  - всегда перезагружать, но помнить о явной остановке ($ docker stop)
  --restart=on-failure[:max-retry]  - перезапускать только в случае сбоя (== ненулевой код завершения основного процесса)
  # :max-retry - количество попыток перезапуска
  # можно продемонстрировать так:
  # ($ docker run -d -i --restart=on-failure:10 <docker-image> /bin/false)
[!] ID контейнера при перезапуске не меняется.

Информацию о состоянии контейнера можно посмотреть, выполнив команду:
$ docker ps -a

*******************************************************
* [Клиент Docker] <--(HTTP-запрос)--> [Docker Daemon] *
*******************************************************


2.3 Клиент Docker
[Метод 4]: Использование socat для мониторинга трафика Docker API

Для диагностики проблемы может быть полезно посмотреть поток данных,
поступающих к демону Docker и от него.
# = Debugging 


[Клиент Docker] <-(HTTP-запрос/ответ)-> {UNIX Domain Socket,(UDS)} <-(HTTP-запрос/ответ)-> {Docker UDS}[Docker Daemon/Server]


# вставляем между Клиентом и Демоном Docker доменный сокет UNIX (UDS)

Для создания этого "прокси" используем socat

socat - это мощная утилита, которая позволяет передавать данные практически любого типа между двумя каналами данных.
(мощнее, чем netcat).

[Syntax]:
---
$ socat -v UNIX-LISTEN:/tmp/dockerapi.sock,fork UNIX-CONNECT:/var/run/docker.sock &
---

  -v = делает вывод читаемым, с указанием потока данных
  UNIX-LISTEN = прослушивать сокет Unix;
  fork = гарантирует, что socat не завершит работупосле первого запроса
  UNIX-CONNECT = указывает socat подключиться к Unix-сокету Docker
  & = указывает, что команда выполняется в фоновом режиме.


Пример команды, которую мы вводим, чтобы увидеть запрос и ответ:
$ docker -H unix:///tmp/dockerapi.sock ps -a

## (обратить внимание на вывод команды == HTTP запрос+ответ, стр. 51-52)


+ Некоторые факты про socat +
  1) socat может обрабатывать множество различных протоколов:
     = не только прослушивать сокеты Unix,
       но и прослушать внешний порт с помощью TCP-LISTEN: <port>,fork
       (вместо UNIX-LISTEN)
  2) нет необходимости перезапускать демон Docker - просто вкл/выкл socat
  3) можно комбинировать socat и docker attach, чтобы присоединиться к уже запущенному терминалу контейнера.
  4) можно установить socat в качестве посредника между внешним миром и сокетом Docker


