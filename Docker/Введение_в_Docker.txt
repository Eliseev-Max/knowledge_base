Введение в Docker и контейнеризацию

Возможность запуска тестов в изолированном окружении
Упрощённый запуск тестов в CI + развёртывание инфраструктуры

[00:05:09]	Обзор Docker

Docker - это открытая платформа для разработки, доставки и эксплуатации приложений.

Варианты использования:
• упаковка приложения (тестов) в контейнеры
• раздача и доставка контейнеров командам для разработки и тестирования
• деплой контейнеров в Production (хорошо масштабируется горизонтально)

[
	Компоненты платформы Docker:
		• Docker Engine
			- механизм, отвечающий за создание и функционирование контейнеров;
			
		• Docker Hub
			- облачный сервис для распространения контейнеров.
]

[00:11:36]	Docker flow

	Образ (image) - шаблон, который используется для создания контейнеров
	Реестр (registry) - репозиторий образов (Docker Hub = hub.docker.com)
	Dockerfile - текстовый файл с инструкциями, необходимыми для создания образа контейнера
	Контейнер (container) - запущенное приложение, т.е. совокупность процессов и образа

	[Dockerfile] -► Build -► [Image] -► Run -► [Container]
	
[00:16:24]	Компоненты Docker
			Клиент (Client)
				• диалог с демоном Docker:
					♦ получить информацию от демона;
					♦ передать инструкции демону.
					
					► unix: по протоколу HTTP (соединение ч/з сокет домена Unix)
						по умолчанию создаётся в /var/run/docker.sock
					► tcp: TCP-socket для поддержки соединения с удалёнными клиентами
					► fd: дескриптор файла для сокетов, управляемых systemd
					
			Сервер (Server/Host) [Docker Daemon]
				• создание контейнеров;
				• запуск контейнеров;
				• контроль работы контейнеров;
				• создание образов;
				• хранение образов.

Реестры: публичные | приватные
	Приватный реестр Docker - это служба (сервис), который хранит образы Docker.
	Образы могут быть запрошены любым Docker-демоном, имеющим соответствующий доступ.
	Этот реестр находится во внутренней сети и не является общедоступным, поэтому он считается приватным.

		  Принципиальные различия в целях использования VM и контейнеров:
		  ► Целью применения виртуальной машины является полная эмуляция инородной программной (операционной) среды
		  ► Цель применения контейнера - сделать приложения ПЕРЕНОСИМЫМИ и САМОДОСТАТОЧНЫМИ
		  
[00:18:52]	Сравнение Docker-контейнеров и виртуальных машин (VM)
		♦ VM более изолированы,
		♦ Каждая VM использует свою ОС (Guest OS), свои библиотеки, файлы, службы
		♦ Всеми виртуальными ОС управляет Гипервизор (Hypervisor)
		  
		• Все контейнеры задействуют одно общее ядро ОС
		• Контейнеры пользуются общими библиотеками (не дублируя их)

[00:23:07]	Преимущества контейнеров
		   • Время запуска - контейнеры запускаются быстрее (несколько секунд), чем VM (несколько минут)
						  (запуск контейнера == запуск службы)
		   • Ресурсы - контейнеры потребляют меньше ресурсов, чем VM (HDD, RAM, CPU)
					   Процессы внутри контейнеров равнозначны собственным процессам ОС хоста
					   и не влекут за собой дополнительных накладных расходов, связанных с выполнением гипервизора
		   • Лицензирование - большинство технологий для запуска контейнеров бесплатны и являются Open Source проектами
		   • Переиспользование кода - образы легко создаются из Dockerfile и могут распространяться через реестры
		  
[00:25:17]	Преимущества виртуальных машин (VM)
			Изолированность - у VM более высокая степень изоляции друг от друга и от хостовой системы
			Портирование - возможность запуска VM с Linux на хосте Windows и наоборот
			Откат изменений (rollback) - удобная система Snapshots

[00:27:53]	Базовые команды Docker CLI
			Многие команды docker требуют привелегий суперпользователя
			Чтобы постоянно не прибегать к sudo docker..., нужно добавить своего пользователя в группу docker
			$ sudo usermod -aG имя_группы имя_пользователя
			$ sudo usermod -aG docker max
			
[00:30:06]	Проверка правильности установки
	docker --version	# выведем version ..., build ...
	запуск контейнера из образа hello-world:
		docker run hello-world
	При выполнении docker-команды из удалённого репозитория (библиотеки) скачивается образ
	hello-world последней версии.
	Запустившийся контейнер выводит сообщение о том, какие действия были выполнены Docker-клиентом
	и Docker-сервером (Docker Daemon) в консоль
	
	Шаги Docker:
	1. Docker клиент связался с Docker демоном
	2. Docker daemon вытащил (извлёк) образ из (удалённого репозитория) Docker Hub
	3. Docker daemon запустил новый контейнер из этого образа ► контейнер запустил исполняемый файл ►
	   ► вывел строку (которую мы прочитали)
	4. Docker daemon транслировал этот вывод клиенту, который в свою очередь отправил вывод в наш терминал
	
[00:34:38]	Базовые команды
{
	Поиск образа:					$ docker search <ИМЯ_ОБРАЗА>
	Выгрузка образа из реестра:		$ docker pull <ИМЯ_ОБРАЗА>
}
	$ docker ps [-a, --all]
		$ docker ps				- показывает запущенные контейнеры
		$ docker ps -a \--all	- выводит список всех контейнеров
		$ docker ps -q			- выводит ID контейнеров
		$ docker ps -f			- фильтровать контейнеры по заданному условию
		
	$ docker images				- выводит список образов
	$ docker run [--rm] <image>	- создаёт и запускает новый контейнер
		# Всякий раз запуская команду docker run создаётся новый контейнер
		# Из одного образа можно запустить несколько контейнеров
		# Опция --rm удаляет контейнер после того, как в нём отработала программа (код)
	
	# Что "под капотом" команды docker run:
		Run a command in a new container
		$ docker run [OPTIONS] IMAGE [COMMAND] [ARG...]
	
		docker run = docker create <image> + docker start <container-ID> [--attach, -a]
		
		# опция --attach позволяет подсоединить потоки вывода (STDOUT) и ошибок (STDERR) к нашему терминалу
		
	$ docker create <ИМЯ_ОБРАЗА>	→	 (возвращает) идентификатор
	$ docker run [-it, -d] <container-ID> {command}	- интерактивный режим
		--detach, -d 		= Run container in background and print container ID
		--interactive, -i	= Keep STDIN open even if not attached
		--tty, -t			= Allocate a pseudo-TTY \ назначить псевдо-телетайп
		
		Пример:
		docker run -it ubuntu:20.04 bash		# Запуск интерпретатора команд bash в ОС Ubuntu внутри контейнера
												# Если образ ubuntu не скачан, он скачается
		# При выполнении команды пользователь, от которого мы выполняем команды, меняется на
		  пользователя root@<id>:/#
		# Запущенная в контейнере ОС минимизирована (отсутствуют некоторые пакеты, например man, python3)
	
	$ docker start <КОНТЕЙНЕР>		- запуск остановленного контейнера
	$ docker stop <КОНТЕЙНЕР>		- остановка контейнера
	$ docker restart <КОНТЕЙНЕР>	- перезагрузка (перезапуск) контейнера
	
	docker exec
		Run a command in a running container
		
		$ docker exec [OPTIONS] CONTAINER COMMAND [ARG...]
		
		$ docker exec [-it] <container-ID>	- выполнение команды внутри работающего контейнера
			# опция -it позволяет подключиться к работающему контейнеру
	
	$ docker run --name my_container -it -d ubuntu:20.04 bash
		--name - задать для контейнера имя (для удобства обращения к нему)
		-it - интерактивный режим работы с контейнером (попадаем "внутрь" контейнера)
		-d - запуск контейнера в режиме бэкграунда (фоновом режиме), при нажатии CTRL+D контейнер не завершит свою работу
	Прежде чем скачивать с docker hub образ, нужно сформулировать свои требования к образу и его содержимому.
	После этого выбираем самый подходящий нам образ
	
	CTRL + D - 	завершить работу контейнера
	
[00:55:23]	Как остановить работу контейнера, работающего в бэкграунде:
	
	docker stop/kill			- остановить контейнер (SIGTERM + SIGKILL / SIGKILL) 
								  (gracefull-завершение/принудительное завершение)
	docker rm <container-ID>	- удалить контейнер
	docker rmi <image>			- удалить image из системы
		
		# если запущен контейнер, использующий образ, этот образ нельзя удалить
		# следует перед этим удалить все контейнеры с этим образом
		$ docker ps -a -f ancestor=hello-world:latest		# ancestor - указание на image-предок
		$ docker ps -aq -f ancestor=hello-world:latest		# вывести ID последних контейнеров hello-world
		
		Удаляем все контейнеры hello-world:
		$ docker rm $(docker ps -aq -f ancestor=hello-world:latest)
			или
		$ docker ps -aq -f ancestor=hello-world:latest | xargs docker rm 
			# xargs выводит по одной строке из stdout предыдущей (|) команды
			
	docker cp <container-ID>:src_path dest_path		- скопировать файл из контейнера на хост
	
	docker inspect [-f, --format] <container-ID>	- 	информация о контейнере
	docker inspect --format='{{.Config.Image}}' <container-ID>

_______________________________________________________________________________________________________
[01:05:08]	Dockerfile
		Dockerfile - текстовый документ, который содержит все необходимые команды для создания образа
	Для создания образа необходимы:
		* Dockerfile;
		* контекст создания образа
			- это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY
			в Dockerfile
		
		Клиент Docker способен принимать входные данные из STDIN, если в команде указать аргумент "-" 
		вместо контекста создания образа: (docker build - < Dockerfile)
		
	Dockerfile + build_context (контекст создания образа) → docker build → Docker Image
	
	docker build [-t, --tag] [--file, -f] <context> - создание образа
		# -t, --tag		- создание тэга (имени) образа (для удобства)
		# .	(точка)		- указание на то, что сборка будет производиться из текущего директория
		# -f, --file	- указываем путь до Dockerfile (с указанием самого /Dockerfile в конце пути)
	docker build -t my_image . -f /path/Dockerfile
	
	Контекст билда - это набор файлов, расположенных по указаному пути или URL
	Контекст может задаваться с помощью
		• локального пути до директория
		• архива (tar.gz, xz, bzip2)
		• URL (git-репозиторий)
			В этом случае клиент Docker создаёт клон такого репозитория и всех подчинённых модулей
			во временном каталоге, который затем передаётся в Docker Daemon как контекст создания образа.
	
	Файл .dockerignore, содержащий простые регулярные выражения, которые позволяют исключить файлы из  
	
Работа с образом Docker происходит "слоями", один за другим, последовательно
В процессе создания своего образа создаётся, а затем удаляется промежуточный контейнер (слой)

	docker history	- посмотреть набор уровней образа

Директивы Dockerfile
	FROM - определяет базовый образ
	RUN - выполнение указанной инструкции и сохранение результата
	WORKDIR - рабочий директорий для директив RUN, ADD, COPY, ENTRYPOINT, CMD
	# изначально рабочий директорий у образа - root (/)
	
	‼ Слои в итоговом образе создают только инструкции:
		• FROM
		• RUN
		• COPY
		• ADD
	
Пример использования WORKDIR
	FROM python:3.9.6	# за основу взят образ, содежащий python версии 3.9.6
	
	RUN mkdir app		# создаём директорию app в корневом каталоге
	
	WORKDIR ./app		# перемещаемся в созданную нами директорию
	
	COPY ./script.py ./script.py	# копируем с рабочего хоста в директорию app в образе файл script.py
		# при сборке образа для того, чтобы скопировать скрипт script.py, после указания пути до Dockerfile
		# нам нужно указать (контекст) относительный путь до директория, в котором находится файл скрипта
	
	WORKDIR /			# перемещаемся обратно в корневой каталог
	
	CMD ["cat", "app/script.py"]	# запустить команду при запуске контейнера, развёрнутого из образа
	
	Команда для сборки образа (пример):
	$ docker build -t copyfile -f Dockerfiles/03_copyfile/Dockerfile Dockerfiles/03_copyfile
	# скрипт script.py находится в директории по относительному пути: Dockerfiles/03_copyfile
	
	ADD - копирует файлы из контекста создания или из удалённых URL-ссылок в создаваемый образ.
		  Если архивный файл добавляется из локального пути, то он будет автоматически распакован
		  
	COPY - используется для копирования файлов из контекста создания в образ		# Предпочтительно в общем случае

[01:23:03]	
	CMD - запускает заданную инструкцию во время инициализации контейнера.
		  Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться, как аргумент для ENTRYPOINT.
		  Инструкция CMD замещается любыми аргументами, указанными в команде docker run после имени образа
		  Так в случае нашего примера при запуске контейнера на базе python:3.9.6 командой
			$ docker run --rm copyfile
		  выполнится скрипт script.py
		  Но если запускать контейнер командой 
			$ docker run --rm copyfile ls
		  выполнится команда ls. Т.о. то, что есть в директиве CMD, перезаписывается
		  
	ENTRYPOINT - определяет выполняемый файл (и аргументы по умолчанию), запускаемый при инициализации контейнера.
				В эту выполняемую программу передаются как аргументы любые инструкции CMD или аргументы команды
				docker run, записанные после имени образа
				Например:
					FROM ubuntu
					CMD ["/bin"]
					ENTRYPOINT ["ls"]
				выполнит ls в директории /bin

[01:27:56]	Пример создания docker image с тестами
				 
	# Устанавливаю базовый образ
	# Директива FROM указывает, поверх какого образа мы будем собирать свой образ
	FROM python:3.8-alpine

	# Устанавливаю рабочую директорию внутри контейнера
	# Директория будет создана, если её не было
	# Будет в дальнейшем использоваться, как базовая
	WORKDIR /app

	# Копирую сначала зависимости
	# Для того, чтобы не пересобирать их каждый раз при сборке
	COPY requirements.txt .			# копируем из текущей папки на хосте в текущую папку (app), в которую мы перешли

	# Выполняю необходимые команды
	# Директива RUN позволяет выполнить команду при создании образа
	RUN pip install -U pip
	RUN pip install -r requirements.txt

	# Копирую остальные файлы проекта
	COPY . .

	# Этот параметр можно переопределить при СОЗДАНИИ контейнера, т.е. run
	CMD ["pytest", "--browser", "chrome"]

	Сборка образа из директории со всеми нужными файлами и Dockerfile-ом
		$ docker build -t tests .
	
	Запуск контейнера bash-скриптом:
	
	$ docker run --name test_run tests && docker cp test_run:/app/allure-report . && allure serve allure-report

[Тезисы об инструкции ARG]
{
	ARG - единственная инструкция, которая может предшествовать инструкции FROM в Dockerfile.
	ARG определяет переменную для передачи из командной строки в образ.
	Инструкции FROM поддерживают переменные, объявленные любыми инструкциями ARG, расположенными перед первой командой FROM.
	
	Dockerfile:
		ARG  CODE_VERSION=latest
		FROM base:${CODE_VERSION}
		CMD  /code/run-app

		FROM extras:${CODE_VERSION}
		CMD  /code/run-extras
	ARG, объявленная перед FROM, находится вне стадии сборки, поэтому ее нельзя использовать ни в одной инструкции после FROM.
	(В отличие от ENV-переменных, ARG-переменные не доступны для запущенных контейнеров.)
	ARG нужно использовать, если требуется указать значения ENV по умолчанию при создании образа Docker.
	Чтобы использовать значение по умолчанию ARG, объявленное перед первым FROM, используйте инструкцию ARG без значения внутри этапа сборки:
	Dockerfile:
		ARG VERSION=latest
		FROM busybox:$VERSION
		ARG VERSION							# инструкция ARG без значения
		RUN echo $VERSION > image_version
	
	Резюме:
		В момент сборки образа ($ docker build -t image_tag .) мы не можем задать/изменить значение ENV в Dockerfile.
		А значение ARG мы можем передать через параметр команды docker build или оставить по умолчанию (как указано в Dockerfile)
	Пример:
		________________________________
		Dockerfile
		ARG BUILDTIME_VAR=default_value
		FROM ...
		ENV ENV_VAR_NAME=$BUILDTIME_VAR
		________________________________
		sh:
		$ docker build --build-arg BUILDTIME_VAR=value_1
	
	[Sources:
		§ https://docs.docker.com/engine/reference/builder/
		§ https://tproger.ru/translations/docker-instuction/
		§ https://vsupalov.com/docker-build-time-env-values/
	]
}

Документация
	• https://docs.docker.com/
Полезные ссылки:
	Docker самый простой и понятный туториал:
		• https://badcode.ru/docker-tutorial-dlia-novichkov-rassmatrivaiem-docker-tak-iesli-by-on-byl-ighrovoi-pristavkoi/
	Docker и docker-compose для начинающих. Докеризуем интернет-магазин:
		• https://webdevkin.ru/posts/raznoe/docker
	Руководство по Docker Compose для начинающих:
		• https://habr.com/ru/company/ruvds/blog/450312/
	Установка Docker Engine на Ubuntu Server:
		• https://habr.com/ru/sandbox/149480/
	Установка Docker на Ubuntu
		• https://losst.ru/ustanovka-docker-na-ubuntu-16-04
Книги
	• Моуэт Э. "Использование Docker"
Видео
	Контейнерная виртуализация в Linux	(Лекция)
