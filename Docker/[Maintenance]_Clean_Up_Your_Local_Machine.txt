Docker. Очисти свою машину от хлама!
("Docker Tips: Clean Up Your Local Machine")

[sources:]
1) "Docker Tips: Очистите свою машину от хлама": https://habr.com/ru/articles/486200/
2) "Всё /var/lib/docker пожрал … docker": https://habr.com/ru/articles/790592/
3) "docker container prune": https://docs.docker.com/reference/cli/docker/container/prune/
4) "docker image prune": https://docs.docker.com/reference/cli/docker/image/prune/
5) "Prune unused Docker objects": https://docs.docker.com/config/pruning/


(?) Как Docker использует дисковое пространство хостовой машины?
(?) Как это пространство освободить от составляющих неиспользуемых образов и контейнеров
    (производных жизненного цикла Docker)


********************
* docker system df *
********************

$ docker system df [OPTIONS]
  = отображает информацию об объеме дискового пространства, используемого демоном Docker.

[OPTIONS:]
  --format
    = Форматирование вывода с использованием пользовательского шаблона:
      'table': = вывод в формате таблицы с заголовками столбцов (по умолчанию)
      'table TEMPLATE': = вывод в формате таблицы с использованием заданного шаблона Go
      'json': = вывод в формате JSON
      'TEMPLATE': = напечатать вывод, используя заданный шаблон Go.
  # Дополнительная информация о форматировании вывода с помощью шаблонов:
  #=> https://docs.docker.com/go/formatting/

  -v, --verbose
    = Показать подробную информацию об использовании пространства

# В формате таблицы (по умолчанию) выводятся следующие столбцы:
  TYPE
  TOTAL
  ACTIVE
  SIZE
  RECLAIMABLE

# В столбце TYPE можно встретить такие значения:
  ● Images
  ● Containers
  ● Local Volumes
  ● Build Cache


# С флагом -v, --verbose отчёт делится на пространства:
  Images space usage
  Containers space usage
  Local Volumes space usage

## У каждого пространства существует свой набор столбцов.
[Images space usage:]
  REPOSITORY
  TAG
  IMAGE ID
  CREATED
  SIZE
  SHARED SIZE
  UNIQUE SIZE
  CONTAINERS

[Containers space usage:]
  CONTAINER ID
  IMAGE
  COMMAND
  LOCAL VOLUMES
  SIZE
  CREATED
  STATUS
  NAMES

[Local Volumes space usage:]
  NAME
  LINKS
  SIZE


SHARED SIZE
  = это объем пространства, который образ делит с другим образами
    (т.е. их общие данные).

UNIQUE SIZE
  = это объем пространства, который используется только данным образом.

SIZE
  = виртуальный размер образа, представляющий собой сумму SHARED SIZE + UNIQUE SIZE


#[!] Информация о сети не отображается, поскольку она не занимает место на диске.


[Какие преимущества предоставляет Docker?]

  * значительная экономия ресурсов процессора и оперативной памяти.
  * невероятное упрощение и унификация управления жизненным циклом используемых рабочих сред.


Какие сущности Docker потребляют ресурс дискового пространства:

  ● образы (images)
    – общий размер образов, которые были скачаны из хранилищ образов и построены в вашей системе;

  ● контейнеры (containers)
    – общий объем дискового пространства, используемый запущенными контейнерами
      (имеется ввиду общий объем слоев чтения-записи всех контейнеров);

  ● локальные тома (local volumes)
    – объем локальных хранилищ, примонтированных к контейнерам;

  ● кэш сборки (build cache)
    – временные файлы, сгенерированные процессом построения образов
      (при использовании инструмента BuildKit, доступного начиная с Docker версии 18.09).


************************************
* Использование диска контейнерами *
************************************

  Каждый раз при создании контейнера
  на хостовой машине в каталоге /var/lib/docker создается несколько файлов и каталогов,
  среди которых стоит отметить следующие:

  (dir) /var/lib/docker/containers/ID_контейнера
      = при использовании стандартного драйвера логгирования именно сюда сохраняются журналы событий в JSON-формате.
      # Слишком подробные логи => часто причина переполнения дисков

  (dir) /var/lib/docker/overlay2
      = содержит слои чтения-записи контейнеров
        (overlay2 – предпочитаемые драйвер в большинстве дистрибутивов Linux).
        Если контейнер сохраняет данные в своей ФС, то именно в этом каталоге они и будут размещены.

[Где именно на хостовой машине хранятся данные, сгенерированные в слое RW docker-контейнера?]
/var/lib/docker/overlay2/<container_hash>/merged/<data>
/var/lib/docker/overlay2/<container_hash>/diff/<data>

#(Как одной командой удалить все установленные контейнеры
# и очистить ваш диск от всех созданных ими на уровне чтения-записи файлов:)

  $ docker container prune
# Данная команда удаляет все ОСТАНОВЛЕННЫЕ контейнеры,
# описанные в колонке RECLAIMABLE таблицы $(docker system df)
#(!) Действие аналогично, как если бы контейнер был запущен с флагом --rm

-->
docker container prune [OPTIONS]
[OPTIONS:]
  --filter		Provide filter values (e.g. until=<timestamp>)
  -f, --force		Do not prompt for confirmation

# наглядные примеры и описание: https://docs.docker.com/reference/cli/docker/container/prune/
<--

#При условии, что образ не используется ни одним контейнером:
#(!) Удаление не только остановленных, но и ЗАПУЩЕННЫХ контейнеров:
---
# Historical command
$ docker rm -f $(docker ps –aq)

# More recent command
$ docker container rm -f $(docker container ls -aq)
---



********************************
* Использование диска образами *
********************************

[!] Есть несколько типов образов, которые напрямую не видны конечному пользователю:

  * intermediate образы
      => на их основе собраны другие образы (базовые образы);
      (!) они не могут быть удалены, если вы используете контейнеры на базе этих самых «других» образов;

  * dangling образы
      => это такие intermediate образы, на которые НЕ ССЫЛАЕТСЯ НИ ОДИН из запущенных контейнеров
      == они могут быть удалены.

(!) Проверить наличие в системе dangling образов:
---
$ docker image ls -f dangling=true
---

(!) Удалить dangling-образы из системы:
---
$ docker image rm $(docker image ls -f dangling=true -q)
---
(+) Можно также использовать субкоманду prune:
---
docker image prune
#= удалить неиспользуемые образы
# Примеры с применением Filtering (--filter):
#=> https://docs.docker.com/reference/cli/docker/image/prune/
---

# Удалить вообще все образы из системы:
---
$ docker image rm $(docker image ls -q)
---


******************************
* Использование диска томами *
******************************

(*) Тома (volumes) применяются для хранения данных за пределами файловой системы контейнера.
  Данные, содержащиеся в томе, будут находиться на хостовой машине
  в каталоге /var/lib/docker/volumes
  #= такое поведение характерно и для образов, собранных из Dockerfile,
  # в котором есть директива VOLUME:
*-->
Команда VOLUME создает точку монтирования с указанным именем
и помечает ее как содержащую монтируемые извне тома с родного хоста или других контейнеров.
Значением может быть:
  * массив JSON,
  * VOLUME ["/var/log/"],
  * или обычная строка с несколькими аргументами
    (например VOLUME /var/log или VOLUME /var/log /var/db).
<--*
{ more:
  1. https://docs.docker.com/storage/volumes/
  2. https://docs.docker.com/reference/dockerfile/#volume
}

# Удалить все тома:
---
$ docker volume rm $(docker volume ls -q)
##<или>
$ docker volume prune
---


***********************************************
* Использование диска для кэша сборки образов *
***********************************************

[!] В Docker 18.09 процесс создания образов претерпел некоторые изменения благодаря инструменту BuildKit.

[BuildKit]:>
  + увеличивается скорость процесса,
  + оптимизируется управление хранением данных и безопасностью.

(?) Как BuildKit затрагивает вопросы использования дискового пространства?
# Соберём простое приложение Node.js, которое запускает простой HTTP сервер,
# отвечающий строкой на каждый полученный запрос:
#(содержимое файлов index.js и packages.json - в Источнике)
---<Dockerfile>---
FROM node:13-alpine
COPY package.json /app/package.json
RUN cd /app && npm install
COPY . /app/
WORKDIR /app
EXPOSE 80
CMD ["npm", "start"]
---

  1. Соберём образ обычным способом (без использования BuildKit):
---
$ docker build -t app:1.0 .
---
# проверим использование дискового пространства:
---
TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE
Images         2          0          109.3MB    109.3MB (100%)
Containers     0          0          0B         0B
Local Volumes  0          0          0B         0B
Build Cache    0          0          0B         0B
---
## место занимают только базовый образ (node:13-alpine) и конечный образ (app:1.0)

  2. Соберем вторую версию нашего приложения, уже с использованием BuildKit.
  ## Для этого нам лишь необходимо установить переменную DOCKER_BUILDKIT в значение 1:
  ---
  $ DOCKER_BUILDKIT=1 docker build -t app:2.0 .
  ---
# проверим использование диска: 
---
$ docker system df
TYPE           TOTAL      ACTIVE     SIZE       RECLAIMABLE
Images         2          0          109.3MB    109.3MB (100%)
Containers     0          0          0B         0B
Local Volumes  0          0          0B         0B
Build Cache    11         0          8.949kB    8.949kB
---
#теперь там участвует КЭШ СБОРКИ (buid-cache):

[!] Для очистки кэша сборки существует команда:
**************************
* $ docker builder prune *
**************************

[!] Полная очистка всех сущностей Docker:
  $ docker system prune


###############################
# Prune unused Docker objects #
###############################
>(https://docs.docker.com/config/pruning/)<

  Docker использует консервативный подход к очистке неиспользуемых объектов
  (часто называемый "garbage collection" == "сборкой мусора").

  ОБЪЕКТЫ:
    ● образы (images),
    ● контейнеры (containers),
    ● тома (volumes)  и
    ● сети (networks).

  Эти объекты обычно НЕ УДАЛЯЮТСЯ, если вы ЯВНО НЕ ПОПРОСИТЕ Docker сделать это.
[!] Это может привести к тому, что Docker будет использовать дополнительное дисковое пространство.

[*] Для каждого типа объектов Docker предоставляет команду prune.

  Кроме того, вы можете использовать команду: docker system prune
  для очистки нескольких типов объектов одновременно.

****************
* Prune images *
****************

  Команда (docker image prune) позволяет очистить неиспользуемые образы.
  По умолчанию docker image prune очищает только dangling ("висячие") образы.
  Dangling образ - это образ, который не помечен (isn't tagged)
                              и на который не ссылается ни один контейнер.

  Чтобы удалить dangling образы:
---
$ docker image prune

WARNING! This will remove all dangling images.
Are you sure you want to continue? [y/N] y
---
# Чтобы обойти подсказку ("WARNING!..."), используйте флаг -f или --force.

  Чтобы удалить ВСЕ ОБРАЗЫ, которые НЕ ИСПОЛЬЗУЮТСЯ существующими контейнерами,
  используйте флаг -a:
---
$ docker image prune -a
---

Вы можете ограничить количество уничтожаемых образов с помощью выражений фильтрации с флагом --filter.
Например, учитываются только образы, созданные более 24 часов назад:
---
$ docker image prune -a --filter "until=24h"
---


********************
* Prune containers *
********************




*****************
* Prune volumes *
*****************




******************
* Prune networks *
******************
