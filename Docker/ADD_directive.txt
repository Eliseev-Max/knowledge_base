
---
При добавлении файлов или каталогов, содержащих специальные символы (например, [ и ]), необходимо экранировать эти пути в соответствии с правилами Golang, чтобы они не рассматривались как совпадающий шаблон. Например, чтобы добавить файл с именем arr[0].txt, выполните следующее;
---
ADD arr[[]0].txt /mydir/

---
Все новые файлы и каталоги создаются с UID и GID, равными 0,
если только необязательный флаг --chown не указывает имя пользователя, имя группы или комбинацию UID/GID для запроса конкретного права собственности на добавляемое содержимое.
Формат флага --chown позволяет использовать
  * либо строки имени пользователя и названия группы,
  * либо прямые целочисленные UID и GID в любой комбинации.
При указании имени пользователя без имени группы или UID без GID будет использоваться тот же числовой UID, что и GID.
Если указано имя пользователя или имя группы, то для перевода имени в целочисленные UID или GID будут использоваться файлы корневой файловой системы контейнера /etc/passwd и /etc/group соответственно.
В следующих примерах показаны допустимые определения для флага --chown:
---

ADD --chown=55:mygroup files* /somedir/
ADD --chown=bin files* /somedir/
ADD --chown=1 files* /somedir/
ADD --chown=10:11 files* /somedir/
ADD --chown=myuser:mygroup --chmod=655 files* /somedir/

---
Если корневая файловая система контейнера не содержит файлов /etc/passwd или /etc/group и в флаге --chown используются имена пользователей или групп, сборка завершится неудачей на операции ADD. Использование числовых идентификаторов не требует поиска и не зависит от содержимого корневой файловой системы контейнера.

В случае, когда <src> - это URL удаленного файла, конечный файл будет иметь права доступа 600.
Если удаленный файл имеет заголовок HTTP Last-Modified, то временная метка из этого заголовка будет использована для установки mtime для файла назначения.
Однако, как и для любого другого файла, обрабатываемого во время ADD, mtime не будет учитываться при определении того, изменился ли файл и нужно ли обновлять кэш.
---

---<ПРИМЕЧАНИЕ>---
Если вы собираете, передавая Dockerfile через STDIN (docker build - < somefile),
контекст сборки отсутствует, поэтому Dockerfile может содержать только инструкцию ADD, основанную на URL.
Вы также можете передать сжатый архив через STDIN: (docker build - < archive.tar.gz),
Dockerfile в корне архива и остальная часть архива будут использованы в качестве контекста сборки.
---

Если ваши файлы URL защищены с помощью аутентификации,
вам нужно использовать RUN wget, RUN curl или другой инструмент из контейнера,
поскольку инструкция ADD не поддерживает аутентификацию.

---<ПРИМЕЧАНИЕ>---

    Первая встретившаяся инструкция ADD аннулирует кэш для всех последующих инструкций из Dockerfile,
    если содержимое <src> изменилось.
    Это включает в себя аннулирование кэша для инструкций RUN.
    Дополнительные сведения см. в руководстве Dockerfile Best Practices guide - Leverage build cache.

ADD подчиняется следующим правилам:
  -> Путь <src> должен находиться внутри контекста сборки;
     вы не можете ADD ../something /something,
     !! потому что первым шагом сборки докера является отправка контекстного каталога (и подкаталогов) демону докера.

  -> Если <src> - это URL-адрес, а <dest> не заканчивается косой чертой,
     то файл загружается с URL-адреса и копируется в <dest>.

  -> Если <src> - это URL, а <dest> заканчивается косой чертой,
     то имя файла определяется из URL и файл загружается в <dest>/<filename>.
     Например, ADD http://example.com/foobar / создаст файл /foobar.
     URL должен иметь нетривиальный путь, чтобы в этом случае можно было найти подходящее имя файла
     (http://example.com не работает).

  -> Если <src> - это каталог, то копируется все содержимое каталога, включая метаданные файловой системы.
  --> ПРИМЕЧАНИЕ
        Сама директория не копируется, копируется только её содержимое.

  -> Если <src> - это локальный tar-архив в распознанном формате сжатия (identity, gzip, bzip2 или xz),
    то он распаковывается как каталог.
    Ресурсы с удаленных URL не распаковываются.
    Когда каталог копируется или распаковывается, он ведет себя так же, как и tar -x:
      результатом будет объединение:
        того, что существовало по пути назначения, и
        содержимого исходного дерева, причем конфликты разрешаются в пользу "2." на основе каждого файла.

##Примечание

##Определение файла как распознанного формата сжатия производится исключительно на основе содержимого файла,
##а не его имени.
##Например, если пустой файл заканчивается .tar.gz, он не будет распознан как сжатый
##и не выдаст никакого сообщения об ошибке распаковки, а просто будет скопирован в место назначения.

  -> Если <src> - файл любого другого типа, он копируется отдельно вместе со своими метаданными.
     В этом случае, если <dest> заканчивается слэшем /, он будет считаться каталогом, и содержимое <src> будет записано по адресу <dest>/base(<src>).

  -> Если указано несколько ресурсов <src>, либо напрямую, либо с помощью подстановочного знака,
     то <dest> должен быть каталогом и заканчиваться косой чертой /.

  -> Если <dest> не заканчивается косой чертой, он будет считаться обычным файлом,
     и содержимое <src> будет записано в <dest>.

  -> Если <dest> не существует, он будет создан вместе со всеми отсутствующими каталогами в его пути.
---


Verifying a remote file checksum ADD --checksum=<checksum> <http src> <dest>

The checksum of a remote file can be verified with the --checksum flag:

ADD --checksum=sha256:24454f830cdb571e2c4ad15481119c43b3cafd48dd869a9b2945d1036d1dc68d https://mirrors.edge.kernel.org/pub/linux/kernel/Historic/linux-0.01.tar.gz /

The --checksum flag only supports HTTP sources currently.
Adding a git repository ADD <git ref> <dir>

This form allows adding a git repository to an image directly, without using the git command inside the image:

ADD [--keep-git-dir=<boolean>] <git ref> <dir>

# syntax=docker/dockerfile:1
FROM alpine
ADD --keep-git-dir=true https://github.com/moby/buildkit.git#v0.10.1 /buildkit

The --keep-git-dir=true flag adds the .git directory. This flag defaults to false.
Adding a private git repository

To add a private repo via SSH, create a Dockerfile with the following form:

# syntax=docker/dockerfile:1
FROM alpine
ADD git@git.example.com:foo/bar.git /bar

This Dockerfile can be built with docker build --ssh or buildctl build --ssh, e.g.,

$ docker build --ssh default

$ buildctl build --frontend=dockerfile.v0 --local context=. --local dockerfile=. --ssh default
