[Dockerfile]	
{https://docs.docker.com/engine/reference/builder/}
	Dockerfile - текстовый документ, который содержит все необходимые команды для создания образа
	
	Dockerfile - это простая последовательность ограниченного набора команд, выполняемых в строгом порядке.
	[И.Милл, Э.Х.Сейерс, "Docker на практике"]
	
	Для создания образа необходимы:
		* Dockerfile;
		* контекст создания образа
			- это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY
			в Dockerfile
		
		Клиент Docker способен принимать входные данные из STDIN, если в команде указать аргумент "-" 
		вместо контекста создания образа: (docker build - < Dockerfile)
		
	Dockerfile + build_context (контекст создания образа) → docker build → Docker Image
	
	docker build [-t, --tag] [--file, -f] <context> - создание образа
		# -t, --tag		- создание тэга (имени) образа (для удобства)
		# .	(точка)		- указание на то, что сборка будет производиться из текущего директория
		# -f, --file	- указываем путь до Dockerfile (с указанием самого /Dockerfile в конце пути)
	docker build -t my_image . -f /path/Dockerfile
	
	Контекст билда - это набор файлов, расположенных по указаному пути или URL
	Контекст может задаваться с помощью
		• локального пути до директория
		• архива (tar.gz, xz, bzip2)
		• URL (git-репозиторий)
			В этом случае клиент Docker создаёт клон такого репозитория и всех подчинённых модулей
			во временном каталоге, который затем передаётся в Docker Daemon как контекст создания образа.
	
	Файл .dockerignore, содержащий простые регулярные выражения, которые позволяют исключить файлы из
	каталога сборки образа
	
Работа с образом Docker происходит "слоями", один за другим, последовательно
В процессе создания своего образа создаётся, а затем удаляется промежуточный контейнер (слой)

	docker history	- посмотреть набор уровней образа

Директивы Dockerfile
	FROM - определяет базовый образ
	RUN - выполнение указанной инструкции и сохранение результата
	WORKDIR - рабочий директорий для директив RUN, ADD, COPY, ENTRYPOINT, CMD
	# изначально рабочий директорий у образа - root (/)
	
	LABEL - добавить метаданные к образу.
	  Представляет собой пару "ключ-значение"
	  Пример:
		LABEL "com.example.vendor"="ACME Incorporated"
		LABEL version="1.0"
		LABEL description="This text illustrates \
		that label-values can span multiple lines."
	
	Образ может иметь более одной метки LABEL.
	Можно указать всё в одной строке:
		LABEL multi.label1="val1" multi.label2="val2"
	или каждую метку в отдельной строке, используя в конце экранирование переноса строки \
	‼ ОБЯЗАТЕЛЬНО использовать двойные кавычки! "___"
	
	‼ Слои в итоговом образе создают только инструкции:
		• FROM
		• RUN
		• COPY
		• ADD
	
Пример использования WORKDIR
	FROM python:3.9.6	# за основу взят образ, содежащий python версии 3.9.6
	
	RUN mkdir app		# создаём директорию app в корневом каталоге
	
	WORKDIR ./app		# перемещаемся в созданную нами директорию
	
	COPY ./script.py ./script.py	# копируем с рабочего хоста в директорию app в образе файл script.py
	# при сборке образа для того, чтобы скопировать скрипт script.py, после указания пути до Dockerfile
	# нам нужно указать (контекст) относительный путь до директория, в котором находится файл скрипта
	
	WORKDIR /			# перемещаемся обратно в корневой каталог
	
	CMD ["cat", "app/script.py"]	# запустить команду при запуске контейнера, развёрнутого из образа
	---


COPY - используется для копирования файлов из контекста создания в образ		# Предпочтительно в общем случае
Синтаксис директивы COPY:
	COPY <src> <dest>

Директива COPY подчиняется следующим правилам:
	• Путь <src> должен находиться внутри контекста сборки;
	  # нельзя копировать ../smthng /something (нельзя перейти в родительский директорий),
	  # поскольку первым шагом сборки docker является передача контекстного каталога (и подкаталогов) демону docker.
	  
	• Если <src> - это каталог, то копируется все содержимое каталога, включая метаданные файловой системы.
	  # ‼ Сам КАТАЛОГ НЕ КОПИРУЕТСЯ, копируется только его содержимое.
	  
	• Если <src> - файл любого другого типа, он копируется отдельно вместе со своими метаданными.
	  # В этом случае, если <dest> заканчивается косой чертой (/), он будет считаться каталогом,
	  # и содержимое <src> будет записано по адресу <dest>/base(<src>).
	  
	• Если указано несколько ресурсов <src>, либо напрямую, либо благодаря использованию подстановочного знака,
	  то <dest> должен быть каталогом, и он должен заканчиваться косой чертой (/).
	  
	• Если <dest> не заканчивается косой чертой, то он будет считаться обычным файлом, 
	  и содержимое <src> будет записано в <dest>.
	  
	• Если <dest> не существует, он будет создан вместе со всеми отсутствующими каталогами в его пути.


Команда для сборки образа (пример):
	$ docker build -t copyfile -f Dockerfiles/03_copyfile/Dockerfile Dockerfiles/03_copyfile
	# скрипт script.py находится в директории по относительному пути: Dockerfiles/03_copyfile
	
	ADD - копирует файлы из контекста создания или из удалённых URL-ссылок в создаваемый образ.
		  Если архивный файл добавляется из локального пути, то он будет автоматически распакован
		  
[CMD, ENTRYPOINT]	
	CMD - запускает заданную инструкцию во время инициализации контейнера.
		  Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться, как аргумент для ENTRYPOINT.
		  Инструкция CMD замещается любыми аргументами, указанными в команде docker run после имени образа
		  Так в случае нашего примера при запуске контейнера на базе python:3.9.6 командой
			$ docker run --rm copyfile
		  выполнится скрипт script.py
		  Но если запускать контейнер командой 
			$ docker run --rm copyfile ls
		  выполнится команда ls. Т.о. то, что есть в директиве CMD, перезаписывается
		  
	ENTRYPOINT - определяет выполняемый файл (и аргументы по умолчанию), запускаемый при инициализации контейнера.
				В эту выполняемую программу передаются как аргументы любые инструкции CMD или аргументы команды
				docker run, записанные после имени образа
				Например:
					FROM ubuntu
					CMD ["/bin"]
					ENTRYPOINT ["ls"]
				выполнит ls в директории /bin

[VOLUME]  Инструкция VOLUME
  VOLUME ["/data"]
	- создаёт точку монтирования с указанным именем и помечает ее как содержащую тома, смонтированные из внешнего хоста или других контейнеров.
	
  Возможные значения:
    • массив JSON
    • VOLUME ["/var/log/"]
    • простая строка с несколькими аргументами: 
	  •• VOLUME /var/log
	  •• VOLUME /var/log /var/db
	
  Команда docker run инициализирует только что созданный том (volume) с любыми данными,
	которые существуют в указанном месте в базовом образе.
	Пример:
		FROM ubuntu
		RUN mkdir /myvol
		RUN echo "hello world" > /myvol/greeting
		VOLUME /myvol
	
	docker run → создание точки монтирования в /myvol → копировать файл приветствия во вновь созданный том
	Примечания об указании томов:
	1. Тома в контейнерах на базе Windows:
	    при использовании контейнеров на базе Windows место назначения тома внутри контейнера должно быть одним из:
		• несуществующий или пустой каталог;
		• диск, отличный от C:
	2. Изменение тома из Dockerfile:
	    если какие-либо шаги сборки изменят данные внутри тома после его объявления, эти изменения будут отменены.
	3. Форматирование JSON: список анализируется как массив JSON. Вы должны заключать слова в двойные кавычки (""), а не в одинарные кавычки (').
	
	4.‼! Каталог хоста объявляется во время выполнения контейнера: !‼
	   каталог хоста (точка монтирования) по своей природе зависит от хоста.
	   Это делается для сохранения переносимости образа, поскольку нельзя гарантировать, что данный каталог хоста будет доступен на всех хостах.
	   ‼ По этой причине вы не можете смонтировать каталог хоста из Dockerfile.
	   ‼ Инструкция VOLUME НЕ ПОДДЕРЖИВАЕТ указание параметра host-dir.
	     Вы должны указать точку монтирования при создании или запуске контейнера.

[]	Пример создания docker image с тестами
				 
	# Устанавливаю базовый образ
	# Директива FROM указывает, поверх какого образа мы будем собирать свой образ
	FROM python:3.8-alpine

	# Устанавливаю рабочую директорию внутри контейнера
	# Директория будет создана, если её не было
	# Будет в дальнейшем использоваться, как базовая
	WORKDIR /app

	# Копирую сначала зависимости
	# Для того, чтобы не пересобирать их каждый раз при сборке
	COPY requirements.txt .			# копируем из текущей папки на хосте в текущую папку (app), в которую мы перешли

	# Выполняю необходимые команды
	# Директива RUN позволяет выполнить команду при создании образа
	RUN pip install -U pip
	RUN pip install -r requirements.txt

	# Копирую остальные файлы проекта
	COPY . .

	# Этот параметр можно переопределить при СОЗДАНИИ контейнера, т.е. run
	CMD ["pytest", "--browser", "chrome"]

	Сборка образа из директории со всеми нужными файлами и Dockerfile-ом
		$ docker build -t tests .
	
	Запуск контейнера bash-скриптом:
	
	$ docker run --name test_run tests && docker cp test_run:/app/allure-report . && allure serve allure-report

Об инструкциях ARG и ENV:
	• инструкции ARG или ENV можно использовать для указания переменных, доступных для инструкции RUN;
	• Переменные среды, определенные с помощью инструкции ENV, всегда переопределяют инструкцию ARG с тем же именем.
		---
		FROM ubuntu
		ARG CONT_IMG_VER
		ENV CONT_IMG_VER=v1.0.0
		RUN echo $CONT_IMG_VER
		---
		$  docker build --build-arg CONT_IMG_VER=v2.0.1 .
	►► В этом случае инструкция RUN использует версию 1.0.0 вместо версии 2.0.1, переданной с параметром ARG
		
	( В отличие от ENV-переменных, ARG-переменные не доступны для запущенных контейнеров )
	ARG нужно использовать, если требуется указать значения ENV по умолчанию при создании образа Docker.
	Чтобы использовать значение по умолчанию ARG, объявленное перед первым FROM, используйте инструкцию ARG без значения внутри этапа сборки:
	Dockerfile:
		ARG VERSION=latest
		FROM busybox:$VERSION
		ARG VERSION							# инструкция ARG без значения
		RUN echo $VERSION > image_version
	
	Резюме:
		В момент сборки образа ($ docker build -t image_tag .) мы не можем задать/изменить значение ENV в Dockerfile.
		А значение ARG мы можем передать через параметр команды docker build или оставить по умолчанию (как указано в Dockerfile)
	Пример:
		________________________________
		Dockerfile
		ARG BUILDTIME_VAR=default_value
		FROM ...
		ENV ENV_VAR_NAME=$BUILDTIME_VAR
		________________________________
		sh:
		$ docker build --build-arg BUILDTIME_VAR=value_1
	
	[Тезисы об инструкции ARG]
{	Инструкция ARG определяет переменную, которую пользователи могут передать во время сборки сборщику
	с помощью команды docker build, используя флаг --build-arg <имя_переменной>=<значение>.
	ARG <name>[=<default value>]
	[shell] 	  $ docker build -t example --build-arg test_set custom_set . → 
	[Dockerfile]: FROM ...\n ARG test_set=default_set
	
	Если пользователь указывает аргумент сборки, который не был определен в Dockerfile, сборка выводит предупреждение.
	{ Возможно, устарело:
		ARG - единственная инструкция, которая может предшествовать инструкции FROM в Dockerfile.
	}
	Dockerfile может содержать одну или более инструкций ARG
	
	‼ Определение переменной ARG вступает в силу из строки, в которой оно определено в Dockerfile
	Инструкция ARG выходит из области действия в конце этапа сборки, на котором она была определена.
	Чтобы использовать аргумент на нескольких этапах, каждый этап должен включать инструкцию ARG:
		FROM busybox
		ARG SETTINGS
		RUN ./run/setup $SETTINGS

		FROM busybox
		ARG SETTINGS
		RUN ./run/other $SETTINGS

	
	Dockerfile:
		ARG  CODE_VERSION=latest
		FROM base:${CODE_VERSION}
		CMD  /code/run-app

		FROM extras:${CODE_VERSION}
		CMD  /code/run-extras
		
		{ ARG, объявленная перед FROM, находится вне стадии сборки,
		  поэтому ее нельзя использовать ни в одной инструкции после FROM }
	
	[Sources:
		§ https://docs.docker.com/engine/reference/builder/
		§ https://tproger.ru/translations/docker-instuction/
		§ https://vsupalov.com/docker-build-time-env-values/
	]
}
