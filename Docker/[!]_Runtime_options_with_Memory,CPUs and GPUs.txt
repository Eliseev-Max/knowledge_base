Параметризация потребляемых docker-контейнером ресурсов

#######################################################
#     Runtime options with Memory, CPUs, and GPUs     #
# (Параметры времени выполнения с памятью, CPU и GPU) #
#######################################################

  По умолчанию контейнер НЕ ИМЕЕТ ОГРАНИЧЕНИЙ по ресурсам
  и может использовать столько ресурсов, сколько позволяет планировщик ядра хоста.

  Docker предоставляет возможность контролировать, сколько памяти или процессора может использовать контейнер,
  устанавливая флаги конфигурации времени выполнения (runtime configuration flags) команды docker run.
  
В этом разделе подробно описано:
  -> когда следует устанавливать такие ограничения   и
  -> каковы возможные последствия их установки


(!) Многие из этих функций требуют, чтобы ваше ядро поддерживало возможности Linux.

(->) Чтобы проверить наличие поддержки, можно воспользоваться командой:
---
$ docker info
---
  Если какая-либо возможность отключена в вашем ядре, вы можете увидеть предупреждение в конце вывода,
(как показано ниже):
---
WARNING: No swap limit support
---

## Для их включения обратитесь к документации по операционной системе.
## Дополнительные сведения см. в руководстве по устранению неполадок Docker Engine:
#-> https://docs.docker.com/engine/install/troubleshoot/#kernel-cgroup-swap-limit-capabilities


##########
# Memory #
##########

<[Понимание того, чем грозит нехватка памяти:]>

[!] Важно не позволять запущенному контейнеру потреблять слишком много памяти хост-машины!

[Механизм Linux для борьбы с нехваткой памяти:]
(На хостах Linux):
  если ядро обнаруживает, что памяти недостаточно для выполнения важных системных функций,
  оно выбрасывает OOME (= Out Of Memory Exception), и начинает убивать процессы, чтобы освободить память.
  
  Убить можно ЛЮБОЙ ПРОЦЕСС, включая Docker и другие важные приложения.
[!] Это может привести к КРАХУ ВСЕЙ СИСТЕМЫ, если будет убит не тот процесс.

Docker пытается снизить эти риски, регулируя приоритет OOM для демона Docker, чтобы его вероятность быть убитым была ниже, чем у других процессов в системе.
[!] Приоритет OOM для контейнеров НЕ КОРРЕКТИРУЕТСЯ.
    Таким образом, вероятность УНИЧТОЖЕНИЯ ОТДЕЛЬНОГО КОНТЕЙНЕРА ВЫШЕ,
    чем вероятность уничтожения демона Docker или других системных процессов.

[!] Не стоит пытаться обойти эти меры защиты, 
    вручную устанавливая --oom-score-adj в экстремально отрицательное число для демона или контейнера,
    или устанавливая --oom-kill-disable для контейнера.

Дополнительную информацию об управлении OOM в ядре Linux см. в разделе Out of Memory Management:
(https://www.kernel.org/doc/gorman/html/understand/understand016.html)

********************************************************************
* Мероприятия по снижению риска нестабильности системы из-за OOME: *
********************************************************************

  -> Проведите тесты, чтобы понять требования к памяти вашего приложения, прежде чем запускать его в production.
  -> Убедитесь, что ваше приложение запускается только на хостах с достаточными ресурсами.
  -> Ограничьте объем памяти, который может использовать ваш контейнер, (как описано ниже).
  -> Будьте внимательны при настройке свопа на хостах Docker.
     Подкачка (swap) медленнее, чем Memory, но может служить БУФЕРОМ на случай нехватки системной памяти.
  -> Рассмотрите возможность преобразования контейнера в сервис (https://docs.docker.com/engine/swarm/services/)
     и использования ограничений на уровне сервиса и меток нод (nodes)
     для обеспечения запуска приложения только на нодах с достаточным количеством памяти.


*****************************************
* Ограничьте доступ контейнера к памяти *
*****************************************

  Docker может накладывать ЖЕСТКИЕ или МЯГКИЕ ограничения на память.

  Жесткие ограничения
    -> позволяют контейнеру использовать НЕ БОЛЕЕ фиксированного объема памяти.

  Мягкие ограничения
    -> позволяют контейнеру использовать столько памяти, сколько ему нужно, если не выполняются определенные условия,
       (например, когда ядро обнаруживает нехватку памяти или нехватку ресурсов на хост-машине).

# Некоторые из этих опций имеют различные эффекты при использовании по отдельности или при установке нескольких опций.

Большинство из этих опций принимают целое положительное число, за которым следует суффикс:
  * b = байты,
  * k = килобайты,
  * m = мегабайты,
  * g = гигабайты


[Опции:]

  -m, --memory=
    -> Максимальный объем памяти, который может использовать контейнер.
       Если вы установите этот параметр, минимально допустимое значение будет 6m (6 мегабайт).
       То есть вы должны установить значение НЕ МЕНЕЕ 6 мегабайт.

  --memory-swap
    -> Объем памяти, который этот контейнер может свопировать на диск.
       Подробнее см. в разделе: "--memory-swap details"
       (https://docs.docker.com/config/containers/resource_constraints/#--memory-swap-details)

  --memory-swappiness
    -> По умолчанию ядро хоста может менять местами определенный процент анонимных страниц, используемых контейнером.
       Вы можете установить значение --memory-swappiness в диапазоне от 0 до 100, чтобы настроить этот процент.
       Подробности см. в разделе "--memory-swappiness":
       (https://docs.docker.com/config/containers/resource_constraints/#--memory-swappiness-details)

  --memory-reservation
    -> Позволяет указать мягкий лимит, меньший, чем --memory,
       который активируется, когда Docker обнаруживает нехватку или недостаток памяти на хост-машине.
       Если вы используете параметр --memory-reservation, он должен быть установлен НИЖЕ, чем --memory,
       чтобы иметь приоритет.
       Поскольку это МЯГКОЕ ограничение, оно НЕ ГАРАНТИРУЕТ, что контейнер не превысит лимит.

  --kernel-memory 
    -> Максимальный объем памяти ядра, который может использовать контейнер.
       Минимально допустимое значение - 6m.
       Поскольку память ядра не может быть вытеснена (swapped out),
       контейнер, которому не хватает памяти ядра, может блокировать ресурсы хост-машины,
       что может иметь побочные эффекты для хост-машины и для других контейнеров.
       Подробности см. в параметре "--kernel-memory details":
       (https://docs.docker.com/config/containers/resource_constraints/#--kernel-memory-details)

  --oom-kill-disable 
    -> По умолчанию при возникновении ошибки out-of-memory (OOM) ядро убивает процессы в контейнере.
       Чтобы изменить это поведение, используйте параметр --oom-kill-disable.
       Отключать OOM killer можно ТОЛЬКО в тех контейнерах, где также установлен флаг -m/--memory.
  [!]  Если флаг -m НЕ УСТАНОВЛЕН, на хосте может закончиться память,
       и ядру может потребоваться убить процессы хост-системы, чтобы освободить память.

## Дополнительные сведения о cgroups и памяти в целом см. в документации по Memory Resource Controller:
# (https://www.kernel.org/doc/Documentation/cgroup-v1/memory.txt)


************************
* Детали --memory-swap *
************************
  --memory-swap - это флаг-модификатор, который имеет значение только в том случае, если также установлен флаг --memory.
  Использование свопа позволяет контейнеру записывать на диск избыточные потребности в памяти,
  когда контейнер исчерпал всю доступную ему оперативную память.

[!]  Приложения, часто использующие подмену памяти на диск, теряют в производительности.

(*) Его настройка может иметь сложные последствия:
  -> Если параметр --memory-swap имеет целое положительное значение,
     => то должны быть установлены оба параметра --memory и --memory-swap.
     --memory-swap представляет собой ОБЩИЙ ОБЪЕМ ПАМЯТИ И СВОПА,
     который может быть использован,
     а --memory контролирует объем, используемый не свопируемой памятью.
-->
#[Пример:]
#  если --memory="300m" и --memory-swap="1g",
#  контейнер может использовать 300m памяти и 700m (1g - 300m) swap.
<--

  -> Если параметр --memory-swap установлен в 0,
     => то настройка игнорируется, и значение рассматривается как несброшенное.

  -> Если --memory-swap имеет ТО ЖЕ ЗНАЧЕНИЕ, что и --memory,
     а --memory имеет положительное целое число,\
     => контейнер не будет иметь доступа к swap.
     (См. "Запретить контейнеру использовать своп")

  -> Если параметр --memory-swap не установлен, а --memory установлен,
     => контейнер может использовать столько свопа, сколько установлено в параметре --memory,
     если в хост-контейнере настроена своп-память.
-->
#[Например:]
#  если --memory="300m" и --memory-swap не задано,
#  == контейнер может использовать 600m в сумме (памяти + swap)

  -> Если параметр --memory-swap явно установлен в -1,
     => контейнеру разрешается использовать неограниченное количество swap,
        вплоть до объема, доступного на хост-системе.

[! Внутри контейнера:]
  такие инструменты, как free, сообщают О ДОСТУПНОМ СВОПЕ НА ХОСТЕ,
  а НЕ О ТОМ, ЧТО ДОСТУПНО ВНУТРИ КОНТЕЙНЕРА!

[!]  НЕ ПОЛАГАЙТЕСЬ на вывод free или аналогичных инструментов для определения наличия свопа.

[Запретите контейнеру использовать своп:]
  Если для --memory и --memory-swap установлено одинаковое значение, это не позволит контейнерам использовать своп.
  Это происходит потому, что
    --memory-swap - это количество комбинированной памяти и свопа, которое может быть использовано,
    --memory - это только количество физической памяти, которое может быть использовано.

<-- Управление лимитами memory в Docker Compose -->
+(https://for-each.dev/lessons/b/-ops-docker-memory-limit)

#######
# CPU #
#######
(https://docs.docker.com/config/containers/resource_constraints/#cpu)

  По умолчанию доступ каждого контейнера к процессорным циклам хост-машины НЕОГРАНИЧЕН.
  Можно установить различные ограничения, чтобы ограничить доступ данного контейнера к циклам ЦП хост-машины.
  Большинство пользователей используют и настраивают планировщик CFS (CFS scheduler) по умолчанию.
# (https://docs.docker.com/config/containers/resource_constraints/#configure-the-default-cfs-scheduler)

  Можно также настроить планировщик реального времени (real-time-scheduler).
# (https://docs.docker.com/config/containers/resource_constraints/#configure-the-real-time-scheduler)