How Compose works
(https://docs.docker.com/compose/compose-application-model/)

Docker Compose опирается на конфигурационный файл YAML, который обычно называется compose.yaml.

Файл compose.yaml соответствует правилам определения многоконтейнерных приложений, изложенным в спецификации Compose.
(https://github.com/compose-spec/compose-spec)
Это реализация Docker Compose формальной спецификации Compose (https://docs.docker.com/compose/compose-file/)

[Модель приложения Compose]

  Вычислительные компоненты приложения определяются как сервисы.
  Сервис - это абстрактная концепция, реализуемая на платформах путем запуска одного и того же образа контейнера и его конфигурации один или несколько раз.

  Сервисы взаимодействуют друг с другом через сети.
  В спецификации Compose сеть - это абстракция возможностей платформы для создания IP-маршрута между контейнерами внутри сервисов, соединенных между собой.

  Сервисы хранят и обмениваются постоянными данными в томах.
  Спецификация описывает такие постоянные данные как высокоуровневое монтирование файловой системы с глобальными опциями.

  Некоторые сервисы требуют конфигурационных данных, которые зависят от времени выполнения или платформы.
  Для этого в спецификации определена специальная концепция configs.
  С точки зрения контейнера сервисов, конфигурации можно сравнить с томами, поскольку они представляют собой файлы, монтируемые в контейнер.
  Но фактическое определение включает в себя отдельные ресурсы и сервисы платформы, которые абстрагируются этим типом.

  Секрет - это особый вид конфигурационных данных для конфиденциальных данных, которые не должны быть открыты без учета соображений безопасности.
  Секреты предоставляются сервисам в виде файлов, монтируемых в их контейнеры, но ресурсы платформы для предоставления конфиденциальных данных достаточно специфичны,
  чтобы заслужить отдельное понятие и определение в спецификации Compose.

[!] С помощью volumes, конфигураций и секретов вы можете иметь простое объявление на верхнем уровне,
    а затем добавлять более специфическую для платформы информацию на уровне служб (service level).


  Проект
    - это отдельное развертывание спецификации приложения на платформе.
	  Имя проекта, задаваемое с помощью атрибута `name` верхнего уровня, используется для
		- объединения ресурсов в группы
		и
		- изоляции их от других приложений или других установок того же приложения, специфицированного Compose, с различными параметрами.
	  
	  Если вы создаете ресурсы на платформе, вы должны префиксировать имена ресурсов проектом и установить метку:
		com.docker.compose.project.

	  Compose предлагает возможность задать пользовательское имя проекта и переопределить его,
	  чтобы один и тот же файл compose.yaml можно было развернуть дважды на одной и той же инфраструктуре без изменений,
	  просто передав другое имя.


Взаимодействие с приложением Compose осуществляется через Compose CLI.
  $ docker compose up		# запустить приложение;
  $ docker compose down 	# останавить приложение и удалить контейнеры.


[Файл Compose]

  Путь к файлу Compose по умолчанию:
    compose.yaml		#(предпочтительно)
	compose.yml,

  Compose-файл помещается в рабочую директорию.
  Compose также поддерживает:
    * docker-compose.yaml
	* docker-compose.yml
  ## для обратной совместимости с предыдущими версиями.

[!] Если оба файла существуют, Compose предпочитает канонический compose.yaml

  Вы можете использовать фрагменты и расширения, чтобы сделать ваш файл Compose эффективным и простым в обслуживании.

__Объединение нескольких файлов Compose:
  
  Несколько файлов Compose могут быть объединены вместе для определения модели приложения.
  Объединение YAML-файлов осуществляется путем добавления или переопределения элементов YAML в соответствии с установленным порядком Compose-файлов.
  
  * Простые атрибуты и карты (maps) переопределяются Compose-файлом высшего порядка,
  * списки объединяются путем добавления.
  * Относительные пути определяются на основе родительской папки первого Compose-файла,
    (если объединяемые файлы находятся в других папках).

  Поскольку некоторые элементы файла Compose могут быть выражены как отдельными строками, так и сложными объектами, слияния применяются к расширенной форме. Дополнительные сведения см. в разделе Работа с несколькими файлами Compose:
  (https://docs.docker.com/compose/multiple-compose-files/)

__Использование include:
  Когда используется include:
    > требуется повторно использовать другие файлы Compose 
	> нужно разделить части модели вашего приложения на отдельные файлы Compose.

[полезно:]
  если приложение Compose зависит от другого приложения, которое управляется другой командой;
       приложение Compose должно быть совместно использовано с другими.

Иллюстрированный пример:  https://docs.docker.com/compose/compose-application-model/#illustrative-example

Рассмотрим приложение, разделенное на внешнее веб-приложение и внутреннюю службу.

Фронтенд настраивается во время выполнения с помощью файла конфигурации HTTP, управляемого инфраструктурой, в котором указывается внешнее доменное имя и сертификат HTTPS-сервера, вводимый защищенным хранилищем секретов платформы.

Бэкэнд хранит данные в постоянном томе.

Оба сервиса взаимодействуют друг с другом в изолированной сети внутреннего уровня, а фронтенд также подключен к сети внешнего уровня и открывает порт 443 для внешнего использования.
---
Пример приложения состоит из следующих частей:

  2 сервиса, поддерживаемые образами Docker: webapp и база данных
  1 секрет (HTTPS сертификат), внедряемый во фронтенд
  1 конфигурация (HTTP), инжектируемая во фронтенд
  1 постоянный том, подключенный к бэкенду
  2 сети

---[compose.yaml]---
services:
  frontend:
    image: example/webapp
    ports:
      - "443:8043"
    networks:
      - front-tier
      - back-tier
    configs:
      - httpd-config
    secrets:
      - server-certificate

  backend:
    image: example/database
    volumes:
      - db-data:/etc/data
    networks:
      - back-tier

volumes:
  db-data:
    driver: flocker
    driver_opts:
      size: "10GiB"

configs:
  httpd-config:
    external: true

secrets:
  server-certificate:
    external: true

networks:
  # The presence of these objects is sufficient to define them
  front-tier: {}
  back-tier: {}
---