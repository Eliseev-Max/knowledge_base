Все действия с контейнерами выполняются утилитой docker.
Ее можно запускать от имени вашего пользователя после того, как он был добавлен в группу программы.

	$ docker [опции] команда [опции_команды] [аргументы]
	
	Основные опции команды:
		-D - включить режим отладки;
		-H - подключиться к серверу, запущенному на другом компьютере;
		-l - изменить уровень ведения логов, доступно: debug,info,warn,error,fatal;
		-v - показать версию;
		--help вывести справку по команде или утилите в целом;

	Команды:
		attach - подключиться к запущенному контейнеру;
		build - собрать образ из инструкций dockerfile;
		commit - создать новый образ из изменений контейнера;
		cp - копировать файлы между контейнером и файловой системой;
		create - создать новый контейнер;
		diff - проверить файловую систему контейнера;
		events - посмотреть события от контейнера;
		exec - выполнить команду в контейнере;
		export - извлечь содержимое контейнера в архив;
		history - посмотреть историю изменений образа;
		images - список установленных образов;
		import - создать контейнер из архива tar;
		info - посмотреть информацию о системе;
		inspect - посмотреть информацию о контейнере;
		kill - остановить запущенный контейнер;
		load - загрузить образ из архива;
		login - авторизация в официальном репозитории Docker;
		logout - выйти из репозитория Docker;
		logs - посмотреть логи контейнера;
		pause - приостановить все процессы контейнера;
		port - подброс портов для контейнера;
		ps - список запущенных контейнеров;
		  ps -a - список всех контейнеров;
		pull - скачать образ контейнера из репозитория;
		push - отправить образ в репозиторий;
		restart - перезапустить контейнер;
		rm - удалить контейнер;
		rmi - удалить образ;
		run - выполнить команду в контейнере;
		save - сохранить образ в архив tar;
		search - поиск образов в репозитории по заданному шаблону;
		start - запустить контейнер;
		stats - статистика использования ресурсов контейнером;
		stop - остановить контейнер;
		top - посмотреть запущенные процессы в контейнере;
		unpause - проложить выполнение процессов в контейнере.

	Опции команды run:
		-e - переменные окружения для команды;
		-h, --hostname - имя хоста контейнера;
		-i - интерактивный режим, связывающий stdin терминала с командой;
		-m - ограничение памяти для команды;
		-u - пользователь, от имени которого будет выполнена команда;
		-t - связать tty с контейнером для работы ввода и вывода;
		-v - примонтировать директорию основной системы в контейнер.

	Поиск нужного пакета:
		$ docker search <ключевое_слово/часть имени>
	
	Загрузка образа на локальный хост:
		$ docker pull <имя_образа>

[
	Docker предоставляет API для взаимодействия с демоном Docker
	(называемым Docker Engine API), а также SDK для Go и Python.
]

_________________________________		
Полезные команды и методы работы:
_________________________________
	В момент инициализации нового контейнера можно задать имя хоста контейнера:
		$ docker run -h CONTAINER -it debian:latest /bin/bash
		root@CONTAINER:/#
	
	Просмотр информацию о контейнере:
		$ docker inspect <имя_контейнера> (или) <ID контейнера>
		[
			{
				"Id": "",
				"Created": "YYYY-MM-DD T HH:MM:SS.mS",
				"Path": "/bin/bash",
				"Args": [],
				"State":{
					"Running": true,
					...
				}
			}
		]
	
	Для вывода конкретной информации можно воспользоваться:
		• утилитой grep;
		• аргументом --format (принимает шаблон языка Go)
		
		$ docker inspect <имя_контейнера> | grep IPAddress
			"IPAddress": "192.168.1.11",
			"SecondaryIPAddress": null
		
		$ docker inspect --format {{.NetworkSettings.IPAddress}} <имя_контейнера>
			192.168.1.11
	
	Вывести список файлов, изменённых в работающем контейнере:
		$ docker diff <имя_контейнера>
	
	Файловая система (ФС) контейнеров Docker: UnionFS (Union File System).
	Она позволяет монтировать несколько файловых систем в общую иерархию, которая выглядит как единая файловая система.
	► ФС конкретного образа смонтирована как уровень только для чтения;
	► любые изменения в работающем контейнере происходят на уровне с разрешённой записью,
	  монтируемого поверх основной ФС образа.
	
	***
	
	Команда docker logs
	$ docker logs <имя_контейнера> (\<ID контейнера>)
		= вывести список всех событий, произошедших внутри заданного контейнера.
	
	!! Вывести идентификаторы всех остановленных контейнеров:
		$ docker ps -aq -f status=exited
	
	Удалить все остановленые контейнеры:
		$ docker rm -v $(docker ps -aq -f status=exited)
		# аргумент -v позволяет удалить все тома (разделы), управляемые Docker, на которые
		  не ссылаются какие-либо другие контейнеры.
	
	***
	Превратим КОНТЕЙНЕР ► в ► ОБРАЗ с помощью команды docker commit
	# не имеет значения статус контейнера: работает или остановлен
		Параметры, передаваемые в команду:
		1. имя контейнера (container_name)
		2. имя для создаваемого образа (created_image)
		3. имя репозитория, в котором образ будет сохранён (repo)
	
	$ docker commit container_name repo/created_image
	
Образы, контейнеры и файловая система Union File System
	
	Ключевой момент технологии, лежащей в основе Docker, - UnionFS (= каскадно-объединённое монтирование, union mount)
	Реализации UnionFS, поддерживаемых Docker:
		• AUFS;
		• Overlay;
		• devicemapper;
		• BTRFS
		• ZFS
	Определить реализацию, используемую в конкретной системе:
		docker info (см. содержимое заголовка "Storage Driver")
	
	Образы Docker состоят из нескольких уровней (layers).
	Каждый уровень представляет собой защищённую от записи файловую систему.
	Для каждой инструкции в Dockerfile создаётся свой уровень, который размещается поверх предыдущих уровней.
	Во время преобразования IMAGE → CONTAINER (docker run, docker create) механизм Docker:
		► выбирает нужный образ;
		► добавляет на самом верхнем уровне ФС с возможностью записи
		◄=► одновременно с этим инициализируются разнообразные параметры настройки, такие как
			• IP-адрес;
			• имя;
			• идентификатор;
			• ограничения ресурсов.
	Хорошей практикой является сведение к минимуму количество уровней посредством записи нескольких
	UNIX-команд в одной инструкции RUN
	
	Состояния контейнера:
		• created 		- "создан", (docker create)
		• restarting 	- "перезапуск"
		• running 		- "активен", "работает"
		• paused 		- "приостановлен"
		• exited 		- "остановлен" (= stopped), в контейнере нет активно выполняющихся процессов
	Контейнер существует, пока существует его основной процесс
	остановленный контейнер != исходный образ
	
	Тома (Volumes) - это файлы или каталоги, которые смонтированы непосредственно на ХОСТЕ и НЕ ЯВЛЯЮТСЯ частью
					 каскадно-объединённой ФС.
	Другие контейнеры (и сам хост) могут совместно использовать их, и все изменения будут сразу же фиксироваться
	в ФС хоста.
	Объявление каталога как тома:
		• использование инструкции VOLUME в Dockerfile;
		• включение флага -v в команду docker run.
	
	Пример: определим каталог /data как том внутри контейнера:
		Dockerfile:	VOLUME /data
		$ docker run -v /data test/webserver
		В общем виде:	$ docker run -v /directoryName IMAGE
	
	По умолчанию заданный каталог (файл) будет смонтирован на хосте внутри каталога,
	в котором был установлен Docker	(/var/lib/docker/)
	!!! В качестве точки монтирования можно определить любой другой каталог хоста в команде docker run:
		$ docker run -d -v /host/dir:/container/dir test/webserver
	
	***
	В файле Dockerfile определить каталог хоста как точку монтирования НЕВОЗМОЖНО по причинам, связанным
	с обеспечением переносимости и безопасности