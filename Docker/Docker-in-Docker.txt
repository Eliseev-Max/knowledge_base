####################################
# Docker can now run within Docker #
####################################
{https://www.docker.com/blog/docker-can-now-run-within-docker/}

__Привилегированный режим для контейнеров

  Одной из (многих!) особенностей Docker 0.6 является новый "привилегированный" режим для контейнеров.
  Он позволяет запускать некоторые контейнеры с (почти) всеми возможностями хост-машины, касающимися функций ядра и доступа к устройствам.
  Среди (многих!) возможностей "привилегированного" режима - возможность запускать Docker внутри самого Docker.
  План действий:
    1. посмотрим, как это реализовать;
	2. объясним, что происходит под капотом;
	3. покажем нечто еще более мощное, чем Docker в Docker!


*******************************
* Docker-in-Docker в действии *
*******************************

  (Docker version >= 0.6)
  ## Запуск контейнера в привилегированном режиме:
    $ docker run -privileged -t -i jpetazzo/dind

  # Это загрузит мой специальный образ Docker (позже мы увидим, почему он особенный) и запустит его в новом привилегированном режиме.
  # По умолчанию будет запущен локальный демон docker, и вы попадете в оболочку.
  # В этой оболочке давайте попробуем выполнить классическую команду "Docker 101":
  # (Запускаем внутри контейнера)
	$ docker run -t -i ubuntu bash
  
[!Note]
  как меняется идентификатор контейнера при переходе от контейнера, в котором запущен Docker, к самому внутреннему контейнеру!

[Особенности DinD образа:]
  
  Что особенного в моем dind-образе?
  Почти ничего! Он собран с помощью обычного Dockerfile. Давайте посмотрим, что находится в этом Dockerfile.

Во-первых, он устанавливает несколько пакетов:
  + lxc и iptables (потому что они нужны Docker), 
  + ca-certificates (потому что при взаимодействии с индексом и реестром Docker должен подтвердить их SSL-сертификаты).

В Dockerfile также указано, что /var/lib/docker должен быть volume
Это важно, потому что файловая система контейнера - это точка монтирования AUFS, состоящая из нескольких ветвей;
и эти ветви должны быть "нормальными" файловыми системами (т. е. не точками монтирования AUFS).
Другими словами, /var/lib/docker, место, где Docker хранит свои контейнеры, не может быть файловой системой AUFS.
Поэтому мы указываем Docker, что этот путь должен быть volume.

У volumes (томов) много назначений, но в данном сценарии мы используем их как проход к "обычной" FS хост-машины.
Каталог /var/lib/docker вложенного Docker будет находиться где-то в /var/lib/docker/volumes на хост-системе.

И, конечно, Dockerfile вставляет в образ бинарный файл Docker, а также вспомогательный скрипт.
Скрипт-помощник решает три задачи:

  1. Он обеспечивает правильное монтирование псевдофайловых систем cgroup, поскольку они нужны Docker (или, точнее, lxc-start).
  2. Закрывает посторонние файловые дескрипторы, которые могли просочиться из родительского процесса. Это не является строго необходимым, но вы можете заметить странные побочные эффекты, если не сделаете этого;
  3. Проверяет, указали ли вы переменную окружения PORT с помощью опции командной строки -e PORT=...
     Если указали, то демон Docker запускается на переднем плане и слушает запросы API на указанном TCP-порту.
	 Если вы не указали переменную PORT, то Docker будет запущен в фоновом режиме и предоставит вам интерактивную оболочку.


Почему переменная окружения PORT может быть очень полезной?
Docker-as-a-Service

  Если вы просто хотите поэкспериментировать с Docker-in-Docker, просто запустите образ в интерактивном режиме, как показано выше. Теперь давайте представим, что вы хотите предоставлять Docker-как-услугу. Я говорю не о контейнерах как услуге, а о целых экземплярах Docker. Каждый раз, когда кто-то захочет получить свой собственный экземпляр Docker, просто выполните следующее:
  
    $ docker run -privileged -d -p 1234 -e PORT=1234 jpetazzo/dind

  Затем с помощью docker inspect получите публичный порт, выделенный для этого контейнера, и передайте его пользователю. Они смогут создавать контейнеры на этом "частном Docker", указывая своему клиенту Docker на IP-адрес и порт, которые вы им дали. (Аналогичный пример см. в статье Memcached-as-a-Service).

Однако обратите внимание, что это чревато серьезными последствиями для безопасности: поскольку частные экземпляры Docker работают в привилегированном режиме, они могут легко перейти на хост, а вам это, скорее всего, не нужно! Если вы действительно хотите запустить нечто подобное и выложить это в открытый доступ, вам придется точно настроить файл шаблона LXC, чтобы ограничить возможности и устройства, доступные для экземпляров Docker. В будущем Docker позволит более тонко управлять разрешениями, но пока мы считаем, что возможность переключаться между "заблокированным" и "привилегированным" - это отличный первый шаг.

Docker-in-Docker-in-Docker-in…

  Можно ли запустить Docker-in-Docker-in-Docker?\
  Да.
  Когда вы находитесь внутри привилегированного контейнера, вы всегда можете вложить еще один уровень:
  
    $ docker run -t -i -privileged jpetazzo/dind

  