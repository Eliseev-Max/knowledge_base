Настройка Linux для работы с NTLM
{
https://itsecforu.ru/2019/05/20/%F0%9F%96%AA-%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B8%D1%82%D1%8C-linux-%D0%B4%D0%BB%D1%8F-%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-ntlm/
}

{ cntlm manual
	http://cntlm.sourceforge.net/cntlm_manual.pdf
}

Исходные данные:
Host IP: 172.29.24.32
Proxy IP: 172.25.200.200:3128
Domain: prosoft.ural.ru
MS User: m.eliseev

Порядок действий:
1. После завершения обновления установить CNTLM:
	$ sudo apt-get install cntlm -y

2. Хешируем свой пароль:
	$ sudo cntlm -H -d DOMAIN -u USER
	DOMAIN = prosoft.ural.ru
	USER = m.eliseev
	(OUTPUT):> 
	  PassLM
	  PassNT
	  PassNTLMv2
	(хешированные пароли необходимо скопировать)

3. Конфигурация CNTLM (внесение изменений в конфигурационный файл):
	$ sudo nano /etc/cntlm.conf
	Настройка:
	Username MS_USERNAME
	Domain DOMAIN
	Proxy IP:PORT
	Password PASSWORD
	где
	MS_USERNAME = m.eliseev
	DOMAIN = prosoft.ural.ru
	IP = 172.25.200.200
	PORT = 3128
	PASSWORD = <хешированный пароль>

	‼ Если в сети более одного Proxy:
	Proxy IP_1:PORT_1
	Proxy IP_2:PORT_2
	например,
	Proxy 192.168.1.10:8080
	Proxy 192.168.1.11:8080

	После сохранения конфигурации перезагрузить службу:
		$ sudo systemctl restart cntlm
	---
	Итог: компьютер с ОС Linux может подключаться к прокси-серверу MS NTLM

4. Настроить приложения или службы для подключения через прокси
	Настройка сразу для всех приложений:
	• $ nano ~/.bashrc
	> (всавить в конец файла):
	export http_proxy=http://127.0.0.1:3128
	export https_proxy=https://127.0.0.1:3128
	export ftp_proxy=http://127.0.0.1:3128
	[Сохранить]
	
	•• $ . ~/.bashrc

Credentials

PassLM          0E84EEE0BA16D141C7CD36D039EB482E
PassNT          F13CB66290E46D20BEAC61525FB2FB37
PassNTLMv2      5045F2414A509004E753B7A59BF44FE1    # Only for user 'm.eliseev', domain 'prosoft.ural.ru'

# For testing jenkins.io
# 52.167.253.43

---
(из мануала по cntlm)

Cntlm - это аутентифицирующий HTTP(S) прокси с туннелированием и ускорением TCP/IP
Он принимает адрес вашего прокси, одного или нескольких (host1..N и port1..N) и открывает слушающий сокет, пересылая каждый запрос родительскому прокси (перемещаясь по круговому списку, если активный родитель перестает работать).
По пути соединение с родительским прокси создается заново и аутентифицируется или, если доступно, ранее кэшированное соединение используется повторно для достижения большей эффективности и более быстрых ответов. Когда цепочка настроена, cntlm следует использовать в качестве прокси в ваших приложениях.
Cntlm также интегрирует прозрачную переадресацию портов TCP/IP (туннелирование) через родителя (включая аутентификацию).
Каждый туннель открывает новый слушающий сокет на определенном локальном порту и перенаправляет все соединения на заданный хост:порт за вторичным прокси.
На странице руководства объясняется, как правильно настроить cntlm, используя конфигурационный файл или аргументы командной строки.

Cntlm работает аналогично NTLMAPS
	+ полная поддержка NTLM,
	+ куча новых возможностей 
	+ ни одного из его недостатков и неэффективности.
Он добавляет поддержку реального keep-alive (с обеих сторон) и кэширует все аутентифицированные соединения для повторного использования в последующих запросах.
Он может быть перезапущен без задержки TIME_WAIT, использует лишь малую часть памяти по сравнению с NTLMAPS и на порядки меньше CPU.
Каждый поток полностью независим, и один не может блокировать другой.
Cntlm имеет множество функций безопасности/приватности, таких как поддержка NTLMv2 и защита паролем - можно заменить хэши паролей (которые можно получить с помощью -H) на реальный пароль или ввести пароль интерактивно.
Если используется пароль в открытом виде, он автоматически хэшируется при запуске и все его следы удаляются из памяти процесса.

В дополнение к меньшему использованию системных ресурсов, cntlm достигает более высокой пропускной способности на данном канале.
Кэшируя аутентифицированные соединения, он действует как HTTP-ускоритель; таким образом, прозрачно устраняется 5-стороннее рукопожатие аутентификации для каждого соединения, обеспечивая прямой доступ большую часть времени.
NTLMAPS не аутентифицирует параллельно с запросом - вместо этого он сначала подключается, посылает зонд и отключается. Не ранее чем после этого он снова подключается и инициирует NTLM handshake.
Cntlm также не считывает весь запрос, включая тело HTTP, в память, фактически, не генерируется никакого трафика, кроме обмена заголовками, пока соединение "клиент <-> сервер" не будет полностью согласовано.
Только после этого тела запроса и ответа пересылаются непосредственно между сокетами клиента и сервера.
Таким образом, cntlm избегает большинства накладных расходов TCP/IP, присущих аналогичным прокси-серверам.
Наряду с тем, что cntlm написан на оптимизированном языке C, он обеспечивает до 15x более быстрые ответы.
Чем медленнее линия, тем большее влияние оказывает cntlm на скорость загрузки.

Пример сравнения cntlm и NTLMAPS при идентичных условиях (Pentium M 1,8 ГГц):
	► cntlm:
		выдал avg 76 kB/s
		пиковое использование CPU: 0,3%
	► NTLMAPS
		выдал avg 48 kB/s
		пиковое использование CPU: 98%
		
(значения указаны в КиБ):
VSZ RSS CMD
3204 1436 ./cntlm -f -c ./cntlm.conf -P pid
411604 6264 /usr/share/ntlmaps/main.py -c /etc/ntlmaps/server.cfg

Неотъемлемой частью разработки является профилирование и скрининг управления памятью с помощью Valgrind.
Исходный дистрибутив содержит файл valgrind.txt, где вы можете увидеть отчет, подтверждающий:
	• нулевые утечки,
	• отсутствие доступа к нераспределенной памяти,
	• отсутствие использования неинициализированных данных
-> все отслежено до каждой инструкции процессора, эмулированной в виртуальном процессоре Valgrind во время типичного времени жизни прокси.

Большинство опций можно предварительно установить в конфигурации.
Указание опции более одного раза не является ошибкой, но cntlm игнорирует все случаи, кроме последнего.
Это не относится к опциям типа -L, каждая из которых создаёт  новый экземпляр некоторой функции.
Cntlm может быть собран с жестко заданной конфигурацией (например. /etc/cntlm.conf), который всегда загружается, если это возможно.
(См. опцию -c о том, как переопределить некоторые или все его настройки.)

---

Конфигурация
Конфигурационный файл - это, по сути, INI-файл, за исключением того, что между ключами и значениями нет знака "=".
Он состоит из ограниченных пробелами пар ключевых слов и пары значений.
Кроме того, есть секции, они имеют обычный синтаксис "[имя_секции]".
Комментарий начинается с хэша "#" или точка с запятой ";" и может находиться в любом месте файла. 
Все, что идет после знака, вплоть до EOL, является комментарием. Значения могут содержать любые символы, включая пробелы.
Вы можете использовать двойные кавычки вокруг значения, чтобы задать строку, содержащую специальные символы,
такие как пробелы, знаки фунта и т.д.
В строках, заключенных в кавычки, не допускается использование экранирующих последовательностей.

Существует два типа ключевых слов: локальные и глобальные.
Локальные параметры определяют детали аутентификации для каждого домена (или местоположения).
Глобальные ключевые слова относятся ко всем разделам и прокси-серверам.
Их следует размещать перед всеми разделами, но это не обязательно.
К ним относятся: Allow, Deny, Gateway, Listen, SOCKS5Proxy, SOCKS5User, NTLMToBasic, Tunnel

Read More
https://manpages.ubuntu.com/manpages/xenial/man1/cntlm.1.html
https://vijiboy.wordpress.com/2018/03/14/configure-cntlm-to-generate-hash-for-your-password-h-and-verify-m/
https://ruslanmv.com/blog/How-to-install-local-proxy-with-cntlm
https://ru.wikibooks.org/wiki/%D0%A1%D0%B5%D1%82%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B2%D0%B0_Debian/Cntlm
