Jenkins. Разбираемся с сущностями: node, agent, executor

{ Используемые источники:
  1. Брент Ластер. "Jenkins 2. Приступаем к работе"
  2. "Managing Nodes" (https://www.jenkins.io/doc/book/managing/nodes/)
  3. "What Is a Jenkins Agent?": https://youtu.be/4KghHJEz5no
  4. "How to Create an Agent Node in Jenkins" (https://www.youtube.com/watch?v=99DddJiH7lM&ab_channel=CloudBeesTV)
  5. "Using Jenkins agents" (https://www.jenkins.io/doc/book/using/using-agents/#creating-your-docker-agent)
  6. "How to Setup Docker Containers As Build Agents for Jenkins" (https://www.youtube.com/watch?v=ymI02j-hqpU&ab_channel=CloudBeesTV)
  7. "wiki.jenkin-ci.orf: Jenkins : Distributed builds": https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds
}

###################################################
#[1] Системы: ведущие, узлы, агенты и исполнители #
###################################################

В традиционной версии Jenkins было только две категории:
  -> ведущие
    <и>
  -> ведомые

************************************************
* Ведущая система Jenkins (Jenkins Controller) *
************************************************
      - это основная система управления экземпляром Jenkins.
      Она имеет полный доступ
      -> ко всем настройкам и параметрам Jenkins,
      -> а также к полному списку заданий,
      и является расположением по умолчанию для выполнения заданий, если не указана другая система.

[!]   Однако она НЕ ПРЕДНАЗНАЧЕНА ДЛЯ ВЫПОЛНЕНИЯ каких-либо ТЯЖЕЛОВЕСНЫХ задач.
      Задания, требующие существенной обработки, должны выполняться в системе, отличной от ведущей.

[!]   Ещё одна причина этого заключается в том,
      что задание, выполняемое в ведущей системе, имеет доступ системы ко всем данным, конфигурации и операциям, что может представлять угрозу безопасности.

[+]   Ведущая система не должна иметь потенциально блокируемых операций, выполняемых на ней,
      поскольку должна иметь возможность отвечать и управлять операциями непрерывно.


***************
* Узел (node) *
***************
    - это общий термин, который используется в Jenkins 2 для обозначения любой системы, которая может запускать задания Jenkins.
    Это относится как к мастерам (master), так и к агентам (agents) и иногда используется вместо этих терминов.
    Узел может быть Docker контейнером.
    Главный узел (node) всегда присутствует в любой установке Jenkins.

[!] Запускать задания на главном узле не рекомендуется!


*****************
* Агент (agent) *
*****************
  - это то, что в ранних версиях Jenkins называли "ведомым" (slave).
  Ведомый = любая неосновная система в Jenkins.

[Суть:>]
  Ведомые системы (slaves) управляются ведущей системой (master)
  и распределяются по мере необходимости или в соответствии с указаниями обрабатывать отдельные задания.

[3] Что представляет из себя Jenkins Agent?
    Как правило в качестве agent могут выступать:
      -> либо машина (VM, bare-metall (PC), Raspberry Pi)
      -> либо контейнер
      -> либо облачный сервис (EC2, Azure, Yandex.Cloud)
    , которые подключаются к Jenkins Controller и выполняют задачи по указанию контроллера.

    Назначение Jenkins Controller:
      * управление соединениями (администрирование)
      * инструментарий для этих агентов.

  => Практически любой тип машин, на которых может быть запущена Java,
  потенциально могут выполнять роль Jenkins Agent для Jenkins Controller.

  Некоторые могут задаваться вопросом: "Зачем мне агенты? У меня есть Jenkins Controller, 
  я могу запускать job'ы прямо на контроллере!"
  (!) Хорошей практикой с точки зрения перспектив безопасности и производительности считается использование агентов
      для выполнения всех заданий/работы.
  

[Примеры реализации:]
  1) можно выделить разных агентов для разных сборок для разных версий ОС;
  2) можно выделить несколько агентов для параллельного запуска с целью тестирования.

[!] Обычно для обработки запущенных заданий устанавливается только ОБЛЕГЧЁННОЕ КЛИЕНТСКОЕ ПРИЛОЖЕНИЕ Jenkins
    с ограниченным доступом к ресурсам
      -> упрощение нагрузки на ведомые системы;
      -> уменьшение проблем с безопасностью.

[Как соотносятся агенты и узлы:]
  Агенты работают на узлах.
  В сценарном конвейере (Scripted pipeline) node используется как термин для системы с агентом.
  В декларативном конвейере (Declarative pipeline) указание конкретного агента для использования выделяет узел.

[Директивы против шагов:]
  Scripted pipeline:    -> node
  Declarative pipeline: -> agent

---


**************************
* Исполнитель (executor) *
**************************
  - это просто слот для запуска задания на узле/агенте.

  Узел может иметь 0 и более исполнителей.
  Количество исполнителей определяет, сколько заданий может быть одновременно запущенно на этом узле.

  Когда ведущая система (master) направляет задания на конкретный узел,
  должен быть доступный слот исполнителя для немедленной обработки задания.
  В противном случае он будет ждать, пока исполнитель станет доступным.

[!] Никогда не допускайте, чтобы количество исполнителей превышало количество CPU или VCPU, доступных для агента!

  Количество исполнителей и другие параметры могут быть настроены при создании узлов.
  Выбор количества исполнителей в одном агенте определяется спецификой задач, планируемых ку выполнению на агенте,
  и средней нагрузкой на процессор в момент работы агента.
  Например, на агента может быть возложена многопоточная нагрузка на C++,
  соответственно инструменты сборки должны быть адаптированы под затачи такого плана (расчёт на основе количества потоков).

(? В каком случае можно нарушить правило: "Количество исполнителей не должно превышать количество CPU" ?)
  Если при наличии N vCPU задания стоят в очереди, но процессор нагружен только на (25-30) %.


[2]---< Компоненты распределенных сборок >---

  В архитектуре распределенных сборок используются:
    - узлы (nodes),
    - агенты (agents)
      <и>
    - исполнители,

  которые отличаются от самого КОНТРОЛЛЕРА Jenkins.

  Понимание того, что представляет собой каждый из этих компонентов, полезно при управлении узлами:

**********************
* Контроллер Jenkins *
**********************

  Контроллер Jenkins
    - это сам сервис Jenkins, на котором установлен Jenkins.
    Это веб-сервер, который также выступает в качестве "мозга" для принятия решений о том, как, когда и где запускать задачи.
    
  Задачи управления, такие как
    - конфигурация,
    - авторизация и аутентификация,
      и т.д.
    выполняются на контроллере, который обслуживает HTTP-запросы.

  Файлы, записываемые при выполнении конвейера, записываются в файловую систему контроллера,
  !! если только они не выгружаются в хранилище артефактов, например Nexus или Artifactory.


****************
* Узлы (nodes) *
****************

  Узлы
    - это "машины", на которых работают агенты сборки.
    Jenkins контролирует каждый подключенный узел на предмет:
      -> наличия дискового пространства (disk space),
      -> свободного временного пространства (free temp space),
      -> свободного свопа (free swap),
      -> времени синхронизации (clock time/sync)
        <и>
      -> времени отклика (response time)

[!]  Узел отключается, если любое из этих значений выходит за пределы настроенного порога.

  Jenkins поддерживает два типа узлов:
    * агенты (agents)
    * встроенный узел (built-in node)

  Встроенный узел
    - это узел, существующий внутри процесса контроллера.
    Для выполнения задач можно использовать агентов и встроенный узел.
    Однако по соображениям 
      * безопасности,
      * производительности
        <и>
      * масштабируемости
    запускать задачи на встроенном узле НЕ РЕКОМЕНДУЕТСЯ.

[!]  Количество исполнителей (executors), настроенных для узла, определяет способность узла выполнять задачи.
[>]  Установите число исполнителей на 0, чтобы запретить выполнение задач на встроенном узле.


*******************
* Агенты (Agents) *
*******************
  Агенты управляют выполнением задач от имени контроллера Jenkins с помощью ИСПОЛНИТЕЛЕЙ.
  Агент
    - это небольшой (170 КБ один jar) клиентский процесс Java, который подключается к контроллеру Jenkins и считается ненадежным.
    Обычно в роли агента выступает либо виртуальная машина/контейнер docker,
    либо "железная" машина (возможен вариант даже с Raspberry Pi),
    либо Облачный сервис,
    которая подключается к Контроллеру и выполняет задания по указанию Контролера.

[!] В основном ЛЮБОЙ ТИП МАШИН, на которых можно запустить Java, может выступать в роли агента Jenkins
[!] Агент может использовать ЛЮБУЮ ОПЕРАЦИОННУЮ СИСТЕМУ, поддерживающую Java.

  Все инструменты, необходимые для сборки и тестирования, устанавливаются на узел, на котором работает агент.

[!]  Поскольку эти инструменты являются частью узла, они могут быть установлены напрямую или в контейнере, таком как Docker или Kubernetes.

  Каждый агент представляет собой процесс с собственным идентификатором процесса (PID) на главной машине (host machine).

  На практике узлы и агенты по сути одно и то же,
  (!) но следует помнить, что концептуально они различаются.


***************************
* Исполнители (Executors) *
***************************

  Исполнитель
    - это слот для выполнения заданий. По сути, это поток в агенте. Количество исполнителей на узле определяет количество одновременных задач, которые могут выполняться.
(!) Другими словами, это определяет количество одновременных этапов Pipeline, которые могут выполняться в одно и то же время.

  Правильное количество исполнителей на узле сборки должно определяться исходя из ресурсов, доступных на узле, и ресурсов, необходимых для выполнения рабочей нагрузки.
  При определении количества исполнителей на узле учитывайте требования к процессору и памяти, а также объем операций ввода-вывода и сетевой активности:
    
    * Один исполнитель на узел (One executor per node)
      - самая безопасная конфигурация.

    * Один исполнитель на ядро процессора
      -> может работать хорошо, если выполняемые задачи невелики.

    * При запуске нескольких исполнителей на узле внимательно следите
      > за производительностью ввода-вывода (I/O performance),
      > за загрузкой процессора,
      > за использованием памяти,
      > за пропускной способностью ввода-вывода (I/O throughput).


---<Jenkins : Distributed builds>---
{ https://wiki.jenkins-ci.org/display/JENKINS/Distributed+builds }

Архитектура Jenkins в своей основе представляет собой "master+agent" (ранее - master<->slaves).
master:
  предназначен для координации и предоставления графического интерфейса и конечных точек API;

agents:
  предназначены для выполнения работы (Job Runners, Workers).

Причина в том, что рабочие нагрузки часто лучше "передавать" распределенным серверам.
Это может быть связано:
  * с масштабированием,
  * предоставлением различных инструментов
  * или сборкой на разных целевых платформах.

[+] Еще одна распространенная причина использования удаленных агентов =
    = развертывание в защищенных средах (без прямого доступа master'а).

Сегодня многие используют Jenkins в облачных средах, и существуют плагины и расширения для поддержки различных сред и облаков.
Это могут быть:
  - виртуальные машины,
  - контейнеры Docker,
  - Kubernetes (например, см. Jenkins-X),
  - EC2,
  - Azure,
  - Google Cloud,
  - VMWare и другие.

В этих случаях агенты обычно управляются за вас (и во многих случаях по требованию, по мере необходимости),
поэтому вам может не понадобиться читать содержание этого документа для таких случаев.
В этом документе описывается распределенный режим работы Jenkins и некоторые способы его настройки,
если вам нужно взять управление в свои руки (или, может быть, вам интересно)
---


****************************
* Создание агентов Jenkins *
****************************
  Агенты Jenkins - это workers (воркеры, "рабочие"), которые выполняют операции, запрашиваемые контроллером Jenkins.
  Контроллер Jenkins управляет агентами и может управлять инструментами на агентах.
  Агенты Jenkins могут быть выделены статически или динамически с помощью таких систем, как
    * Kubernetes,
    * OpenShift,
    * Amazon EC2,
    * Azure,
    * Google Cloud,
    * IBM Cloud,
    * Oracle Cloud
    и других облачных провайдеров.

---< How to Create an Agent Node in Jenkins >---
---


---< Using Jenkins agents >---

  Архитектура Jenkins предназначена для распределенных сред сборки.
  Она позволяет использовать различные среды для каждого проекта сборки,
      распределяя нагрузку между несколькими агентами, выполняющими задания параллельно.

  Контроллер Jenkins - это основной узел в установке Jenkins.
  Контроллер Jenkins управляет агентами Jenkins и организует их работу, включая планирование заданий для агентов и мониторинг агентов.
  Агенты могут быть подключены к контроллеру Jenkins с помощью локальных или облачных компьютеров.

  Агентам требуется установка Java и сетевое подключение к контроллеру Jenkins.

**************************************
* Настройка агентов с помощью Docker *
**************************************

  Агенты Jenkins можно запускать
    -> на физических машинах,
    -> на виртуальных машинах,
    -> на кластерах Kubernetes
    -> и с помощью образов Docker.

[!] Подключим агенты Docker к Jenkins с помощью SSH.

<_Окружение_>

  Для выполнения этого руководства вам понадобится машина с:
    * установленной Java
    * установленным Jenkins
    * Установленным Docker
    * Пара ключей SSH

  1) Сгенерируем пару SSH-ключей с помощью ssh-keygen
# Обратите внимание, что после этого вы должны будете иметь возможность скопировать значение ключа в контроллер и агент,
# поэтому предварительно убедитесь, что вы можете скопировать содержимое файла в буфер обмена.

  2) Создадим Jenkins SSH credential
<https://www.jenkins.io/doc/book/using/using-agents/#create-a-jenkins-ssh-credential>

    Manage Jenkins (Настроить Jenkins) -> Manage Credentials (Credentials) -> Add Credentials
[Заполним форму:]
  Kind: SSH Username with private key;
  id: jenkins
  description: The jenkins ssh key
  username: jenkins
  Private Key: select "Enter directly" and press the "Add" button to insert the content of your PRIVATE KEY file at ~/.ssh/jenkins_agent_key
  Passphrase: (+/-)


  3) Создадим наш Docker agent
<https://www.jenkins.io/doc/book/using/using-agents/#creating-your-docker-agent>

    Здесь мы будем использовать образ docker-ssh-agent для создания контейнеров агента.
    Выполните команду для запуска первого агента:
---
docker run -d --rm --name=agent1 -p 22:22 \
           -e "JENKINS_AGENT_SSH_PUBKEY=<my-public-key>" \
            jenkins/ssh-agent:alpine-jdk17
---

---< docker-compose.yml >---
services:
  jenkins:
    restart: always
    image: jenkins-ver2.441-jdk17
    container_name: jenkins-keeper
    environment:
      JENKINS_HOME: "/var/jenkins_home"
      JAVA_OPTS: "-Djavax.net.ssl.trustStore=$JENKINS_HOME/.keystore/cacerts -Djavax.net.ssl.trustStorePassword=changeit"
    ports:
      - 3268:3268
      - 3269:3269
      - 636:636
      - 8080:8080
      - 50000:50000
    volumes:
      - jenkins_home:/var/jenkins_home
      - /var/run/docker.sock:/var/run/docker.sock
    networks:
      - keeper-network

  jenkins-agent:
    restart: always
    image: <specify_chosen_agent_image>
    container_name: jenkins-agent1
    environment:
      JENKINS_AGENT_SSH_PUBKEY: ""
    ports:
      - 4444:22
    networks:
      - keeper-network
---

# (https://hub.docker.com/r/jenkins/agent)

# Значение <your-public-key> ДОЛЖНО включать полное содержимое вашего файла .pub, включая префикс ssh-XXXX.

#[!] Если на вашей машине уже есть ssh-сервер, работающий на порту 22
#    (если вы вошли на эту машину с помощью команды ssh, то так оно и есть),
#    вам следует использовать ДРУГОЙ ПОРТ для команды docker,
#    например -p 4444:22

Теперь контейнер agent1 запущен.
Подсказка: чтобы проверить, работает ли контейнер так, как ожидалось, можно использовать команду docker ps.

---
$ docker container inspect agent1 | Select-String -Pattern '"IPAddress": "\d+\.\d+\.\d+\.\d+"'
---
  -> можно использовать для просмотра хоста, который должен быть установлен в Jenkins для агента.
  (здесь "\d+\.\d+\.\d+\.\d+" == регулярное выражение для IP-адреса)
  

---< Настройка агентов Jenkins на контроллере >---

  1) Jenkins Dashboard -> Manage Jenkins -> Nodes (Manage Nodes and clouds) -> [+ New Node]
  2) Заполните имя узла/агента и выберите тип;
     (например:
       Название узла: agent1,
       Type: постоянный агент
     )

  3) Теперь заполните поля:

      Remote root directory; (напр.: /home/jenkins )
      label; (e.g.: agent1 )
      usage; (e.g.: only build jobs with label expression…​)
      Launch method; (e.g.: Launch agents by SSH )
      Host; (e.g.: localhost or your IP address )
      Credentials; (e.g.: jenkins )
      Host Key verification Strategy; (e.g.: Manually trusted key verification …​ )

---<Remote root directory>---
  Агент должен иметь директорию, выделенную для Jenkins.
  Укажите путь к этой директории на агенте.
  Лучше использовать абсолютный путь, например /var/jenkins или c:\jenkins.
  Это должен быть локальный путь НА МАШИНЕ АГЕНТА.
  Контроллеру НЕОБЯЗАТЕЛЬНО иметь доступ к этому пути.

  Агенты не содержат важных данных;
  -> все конфигурации задач, логи сборок и артефакты хранятся на контроллере, так что вы можете назначить в качестве такой директории любую временную.

[!] Однако, если назначить агенту директорию, которая НЕ УДАЛИТСЯ при перезапуске машины,
     агент может, например, кэшировать данные, такие как установленные инструменты или рабочие пространства сборок.
     Это предотвращает:
       * излишние загрузки инструментов
         <или>
       * повторную загрузку исходного кода,
     когда после перезапуска агента на нём снова будут запущены сборки.

    Если использовать относительный путь, например, ./jenkins-agent ,
    путь будет ОТНОСИТЕЛЬНО РАБОЧЕЙ ДИРЕКТОРИИ, предоставляемой выбранным способом запуска .

[SSH:] Для способов запуска, в которых Jenkins управляет запуском процесса агента, таких как SSH, текущая рабочая директория обычно будет постоянной - например, домашней директорией пользователя.

Для способов запуска, в которых Jenkins не имеет контроля над запуском процесса агента, таких как агентов с входящим подключением, запущенных из командной строки, текущая рабочая директория может меняться между запусками агента, и использование относительного пути может вызвать проблемы.

[!ATTENTION!]
  Главная проблема при использовании относительных путей с запуском по входящему подключению =>
    => размножение старых рабочих пространств и установленных инструментов на машине агента.
    Это может вызвать проблемы с местом на диске.
---

  4) Нажмите кнопку "Сохранить" ->
     -> agent1 будет зарегистрирован,
    [!] но пока в автономном режиме.
    Нажмите на него.

  5) Теперь вы должны увидеть надпись "This node is being launched".
     Если это не так, вы можете нажать кнопку 
       [Relaunch agent]
     и подождать несколько секунд.
     Теперь вы можете нажать кнопку
       [Log (Журнал)]
     слева, после чего вы должны получить сообщение:
"""
#message
Agent successfully connected and online
(Агент успешно подключен и находится в сети)
"""
     в последней строке журнала.

[!] Если контроллер Jenkins не запускает агента через ssh, проверьте порт, настроенный на агенте.
    Скопируйте его, а затем нажмите кнопку [Advanced…​]
    ([Дополнительно...])
    После этого вы сможете вставить номер порта в текстовое поле Порт.


##############################
# Jenkins Agent Docker image #
##############################

(https://hub.docker.com/r/jenkins/agent)

Это базовый образ для Docker, который включает в себя:
  -> JDK
  -> исполняемый файл агента Jenkins (agent.jar).

Этот исполняемый файл представляет собой экземпляр библиотеки Jenkins Remoting.
Версия JDK зависит от образа и платформы.

---< docker images >---
jenkins/agent:bookworm-jdk17
jenkins/agent:alpine-jdk17
jenkins/agent:jdk17
---

[Внимание!]
  Раньше этот образ публиковался как jenkinsci/slave и jenkins/slave.
  Теперь эти образы устарели,
[!] ИСПОЛЬЗУЙТЕ jenkins/agent.

---<Public_key>---
ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNTYAAAAIbmlzdHAyNTYAAABBBMPtNkZB0CAaQYIAxsuZIAmp17tG7yB38rSztRSxWeqwkKEUvVhAgouzZmQX+bTdI7jUyIFQFknQ9g5PVHlgzkU= devops@srv-cicd
---

[Использование:]

  Этот образ используется в качестве основы для образа Docker Inbound Agent.
  В этом образе контейнер запускается извне (launched externally) и подключается к Jenkins.
  Вместо этого образ можно использовать для запуска агента с помощью метода Launch
  (Запуск агента через выполнение команды на мастере).

Например, в Linux вы можете попробовать:
---
docker run -i --rm --name agent --init jenkins/agent java -jar /usr/share/jenkins/agent.jar
---
  после установки корневого каталога Remote в /home/jenkins/agent

#### Опция --init ####

  Вы можете использовать флаг --init, чтобы указать, что процесс init должен использоваться в качестве PID 1 в контейнере.
  Указание процесса init ГАРАНТИРУЕТ, что обычные обязанности системы init, такие как уничтожение зомби-процессов,
  будут выполняться внутри созданного контейнера.

  По умолчанию в качестве процесса init используется первый исполняемый файл docker-init,
  найденный в системном пути процесса демона Docker.
  Этот двоичный файл docker-init, включенный в установку по умолчанию, поддерживается tini
("Tini - A tiny but valid init for containers":-> https://github.com/krallin/tini)
####


[Рабочие директории агента:]

  Начиная с Remoting 3.8 появилась поддержка рабочих директорий,
  которая обеспечивает протоколирование по умолчанию и изменяет поведение JAR Caching.

Пример вызова для Linux:
---
docker run -i --rm --name agent1 --init -v agent1-workdir:/home/jenkins/agent jenkins/agent java -jar /usr/share/jenkins/agent.jar -workDir /home/jenkins/agent
---


[Конфигурации:]
  Образ имеет несколько поддерживаемых конфигураций, доступ к которым можно получить с помощью следующих тегов:

Образы Linux:
  latest (jdk11, bullseye-jdk11, latest-bullseye-jdk11, latest-jdk11):
  = Последняя версия с новейшей системой удаленного доступа и Java 11 
  -> (основана на debian:bullseye-${builddate})

  alpine (alpine-jdk11, latest-alpine, latest-alpine-jdk11):
  = Небольшой образ, основанный на Alpine Linux
  -> (основан на alpine:${version})

  archlinux (latest-archlinux, archlinux-jdk11, latest-archlinux-jdk11):
  = Образ на базе Arch Linux с JDK11
  -> (основан на archlinux:latest)

  bullseye-jdk17 (jdk17, latest-bullseye-jdk17, latest-jdk17):
    = Версия JDK17 с новейшей удалёнкой (remoting) 
    -> (основана на debian:bullseye-${builddate})

  Начиная с версии 4.11.2, образы alpine также маркируются по версии alpine OS
  (т.е. alpine ==> alpine3.16, alpine-jdk11 ==> alpine3.16-jdk11).

[!] Файл docker-bake.hcl определяет всю конфигурацию для образов Linux и связанных с ними тегов.

  В DockerHub также есть версионные теги, и они рекомендуются для использования в производстве.
  Полный список можно посмотреть здесь -> https://hub.docker.com/r/jenkins/agent/tags


[Часовые пояса (Timezones):]

1) Использование непосредственно образа jenkins/agent

  По умолчанию образ использует часовой пояс Etc/UTC.
  Если вы хотите использовать часовой пояс вашей машины, вы можете смонтировать
    -> файл /etc/localtime   с хоста (согласно этому комментарию)
      <и>
    -> файл /etc/timezone также с хоста.

В этом примере машина использует часовой пояс Европа/Париж:
---
ocker run --rm --tty --interactive --entrypoint=date --volume=/etc/localtime:/etc/localtime:ro --volume=/etc/timezone:/etc/timezone:ro jenkins/agent
#> Fri Nov 25 18:27:22 CET 2022
---

  Вы также можете установить переменную окружения TZ в нужный часовой пояс.
  TZ - это стандартная переменная окружения POSIX, используемая во многих образах,
  #(список допустимых значений см. в Википедии).

  Следующая команда выполняется на машине с часовым поясом Европа/Париж через несколько секунд после предыдущей:
---
docker run --rm --tty --interactive --env TZ=Asia/Shanghai --entrypoint=date jenkins/agent
#> Sat Nov 26 01:27:58 CST 2022 
---

2) Использование образа jenkins/agent в качестве базового образа

    Если вы хотите адаптировать образ jenkins/agent к вашему локальному часовому поясу и при этом создать на его основе свой собственный образ,
    вы можете воспользоваться следующей командой (вдохновленной проблемой #291):

---< Dockerfile >---
FROM jenkins/agent as agent
 [...]
ENV TZ=Asia/Shanghai
 [...]
RUN ln -snf /usr/share/zoneinfo/"${TZ}" /etc/localtime && echo "${TZ}" > /etc/timezone \
    && dpkg-reconfigure -f noninteractive tzdata \
 [...] 
---


##########################
# Параметры секции agent #
##########################

  Для того чтобы поддержать разнообразные сценарии использования, которые могут быть у авторов пайплайна,
  секция agent поддерживает несколько различных типов параметров.
  Эти параметры могут применяться:
    -> на уровне top-level
       (на верхнем уровне блока пайплайна)
       <или>
    -> внутри каждой директивы stage

Параметры:
  ● any
    Выполняет Pipeline или stage на любом доступном агенте.
    Например, `agent any`

  ● none
    При применении на верхнем уровне (top-level) блока пайплайна глобальный агент не будет выделен для всего цикла пайплайна,
    и каждая секция этапа (stage) ДОЛЖНА СОДЕРЖАТЬ СВОЮ СОБСТВЕННУЮ СЕКЦИЮ агента.
    Например, agent none

  ● label
    Выполните пайплайн или stage на агенте, доступном в среде Jenkins с указанным label.
    Например: agent { label 'my-defined-label' }

    Также можно использовать label conditions:
    Например:
      agent { label 'my-label1 && my-label2' }
        <или>
      agent { label 'my-label1 || my-label2' }

  ● node
    agent { node { label 'labelName' } } ведет себя так же,
    как и агент { label 'labelName' },
    но node позволяет использовать дополнительные опции (например, customWorkspace).

  ● docker
      Выполнение пайплайна или stage с заданным контейнером, который будет динамически размещен
      -> на node, предварительно настроенной на прием пайплайнов на базе Docker,
      <или>
      -> на node, соответствующей опционально заданному параметру label.

      docker также опционально принимает параметр args,
        -> который может содержать аргументы для передачи непосредственно в вызов docker run,
      и опцию alwaysPull,
        -> которая заставит выполнить docker pull, даже если имя образа уже присутствует.

  Например:
    agent { docker 'maven:3.9.3-eclipse-temurin-17' }
  или

---<Docker agent. Declarative Pipeline>---
agent {
    docker {
        image 'maven:3.9.3-eclipse-temurin-17'
        label 'my-defined-label'
        args  '-v /tmp:/tmp'
    }
}
---

  docker также опционально принимает параметры registryUrl и registryCredentialsId,
  которые помогут указать используемый реестр Docker и его учетные данные.

  Параметр registryCredentialsId можно ИСПОЛЬЗОВАТЬ ОТДЕЛЬНО для частных репозиториев в хабе docker.

Например:

---<Docker image in private repo for Jenkins agent>---
agent {
    docker {
        image 'myregistry.com/node'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
    }
}
---

  ● dockerfile
    Выполнение Pipeline или stage с помощью контейнера, созданного из Docker-файла, содержащегося в source reposirory.
    Для использования этой опции Jenkinsfile должен быть загружен:
      -> либо из Multibranch Pipeline,
      -> либо из Pipeline from SCM.

    Обычно это Dockerfile в корне исходного репозитория: agent { dockerfile true }.
    [Частные случаи:]
    (*) Если вы собираете Dockerfile в другой директории,
        -> используйте опцию dir:
    ---
    agent { dockerfile { dir 'someSubDir' } }
    ---

    (*) Если ваш Dockerfile имеет другое имя,
        вы можете указать имя файла с помощью опции filename.

    (*) Вы можете передать дополнительные аргументы команде `docker build ...`
        с помощью опции additionalBuildArgs,
        например:
    ---
    agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }
    ---

  ##[Пример:]
    репозиторий с файлом build/Dockerfile.build, ожидающий аргумент build version:
  ---<Declarative Pipeline>---
  agent {
    // Equivalent to "docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/
    dockerfile {
        filename 'Dockerfile.build'
        dir 'build'
        label 'my-defined-label'
        additionalBuildArgs  '--build-arg version=1.0.2'
        args '-v /tmp:/tmp'
    }
  }
  ---

  (**) dockerfile также опционально принимает параметры registryUrl и registryCredentialsId,
       которые помогут указать используемый реестр Docker и его учетные данные.
  Например:
  ---<>---
  agent {
    dockerfile {
        filename 'Dockerfile.build'
        dir 'build'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
    }
  }
  ---


  ● kubernetes


******************
*  Общие  опции  *
* Common Options *
******************

  * label
  * customWorkspace
  * reuseNode
  * args
  * 

#######################################################
# Разница между top level agents и stage level agents #
#######################################################

(https://www.jenkins.io/doc/book/pipeline/syntax/#differences-between-top-and-stage-level)

  Существуют некоторые нюансы при добавлении агента на верхний уровень (top level)
  или уровень этапа (stage level), когда применяется директива options.
{
## Дополнительную информацию см. в разделе "Опции":
## -> https://www.jenkins.io/doc/book/pipeline/syntax/#options
}

[Top Level Agents]

  Для агентов, объявленных на верхнем уровне пайплайна,
  1) выделяется агент,
  2) а затем применяется опция timeout.

---<Top Level Agent. Declarative Pipeline>---
pipeline {
    agent any
    options {
        // Timeout counter starts AFTER agent is allocated =
        //= Счетчик тайм-аута запускается ПОСЛЕ выделения агента
        timeout(time: 1, unit: 'SECONDS')
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
---

  Время выделения агента не включается в ограничение, установленное опцией timeout.
___[для справки:]___
timeout
  = установить период ожидания для запуска пайплайна,
  по истечении которого Jenkins должен прервать пайплайн.
Например:
options { timeout(time: 1, unit: 'HOURS') }

---<Global Timeout, Declarative Pipeline>---
pipeline {
    agent any
    options {
        timeout(time: 1, unit: 'HOURS')     #(1)
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
---
(1): Указание глобального таймаута выполнения в один час,
     по истечении которого Jenkins прервет запуск пайплайна.
____

[Stage Agents]

  В агентах, объявленных в рамках этапа, опции вызываются 
  ДО ВЫДЕЛЕНИЯ АГЕНТА
    и
  ДО ПРОВЕРКИ ЛЮБЫХ УСЛОВИЙ when.

  В этом случае при использовании таймаута он применяется до выделения агента.
#  before the agent is allocated
  Время выделения агента ВКЛЮЧАЕТСЯ в ограничение, установленное опцией timeout.

---<Stage Agent. Declarative Pipeline>---
pipeline {
    agent none
    stages {
        stage('Example') {
            agent any
            options {
                // Timeout counter starts BEFORE agent is allocated
                timeout(time: 1, unit: 'SECONDS')
            }
            steps {
                echo 'Hello World'
            }
        }
    }
}
---
# Этот тайм-аут включает время предоставления агента.
  Поскольку тайм-аут включает время предоставления агента,
  пайплайн может НЕ СРАБОТАТЬ в случаях, когда выделение агента задерживается.