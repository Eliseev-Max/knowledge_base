Получение вывода команды Shell в Jenkins Pipeline
(https://www.baeldung.com/ops/jenkins-pipeline-output-shell-command-variable)


Jenkins Pipeline позволяет разработчикам создать повторяемый и масштабируемый процесс,
который можно легко модифицировать по мере изменения потребностей в разработке программного обеспечения.

В этом руководстве мы рассмотрим, как получить вывод команды shell, выполненной в конвейере.


************************************
* Важность захвата вывода (Output) *
************************************

  Команда shell - это мощная функция Jenkins Pipeline,
  которая позволяет разработчикам выполнять сценарии shell внутри сценария пайплайна.

  Агент Jenkins выполняет команды shell и печатает вывод на консоли Jenkins.
  Jenkins Pipeline использует переменные для хранения данных, к которым можно обращаться и изменять в течение всего сценария.

Мы можем определять переменные
  + в верхней части сценария Pipeline (top-level),
  + в блоке stage.

[!] Захват вывода команды оболочки в переменную очень важен,
    так как позволяет разработчикам использовать вывод одной команды оболочки в качестве входных данных для другой.

Таким образом, разработчики могут использовать сценарий конвейера для хранения вывода команды оболочки.


*********************************
* Использование sh returnstdout *
*********************************

  Команда sh step - это встроенный шаг пайплайна Jenkins,
  который позволяет разработчикам
    ➝ выполнить команду shell   и
    ➝ записать ее вывод в переменную.

  Используя команды shell, мы можем присваивать переменные строкам.
  В Jenkins Pipeline мы можем использовать sh step для выполнения shell-команды внутри пайплайна.
  Давайте рассмотрим задание конвейера для выполнения команды и сохранения ее вывода:
---<Example. Declarative Pipeline>---
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                script {
                    def output = sh(returnStdout: true, script: 'pwd')
                    echo "Output: ${output}"
                }
            }
        }
    }
}
---
# Приведенная выше Job'а пайплайна определяет stage "Example" вместе с его шагами для выполнения,
# включая элемент script {}.
# Этот специальный шаг позволяет выполнять произвольный Groovy-код в рамках пайплайна.
#[!] Кроме того, он используется для определения Groovy-закрытия (Groovy closure)*,
#    которое перехватывает вывод оболочки.
(*) "Introduction to Groovy Language":https://www.baeldung.com/groovy-language

Здесь мы выполнили команду pwd внутри элемента script {} пайплайна с помощью метода sh returnStdout.
[+] Кроме того, мы сохранили результат в переменной output.

(!) Опция "returnStdout: true" указывает Jenkins возвращать стандартный вывод команды shell.
(!) Опция "script: 'pwd'" задает команду командной оболочки (shell) для выполнения.
(!) Наконец, команда `echo` выводит значение переменной "output" на консоль Jenkins с помощью step: echo.


************************************
* Использование подстановки команд *
************************************

  Подстановка команд
    - это функция shell, которая позволяет разработчикам
    ➝ выполнять команду внутри строки
    ➝ и использовать ее вывод как часть строки.

  В Jenkins Pipeline мы можем использовать подстановку команд для захвата вывода команды shell в переменную:
---<>---
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                script {
                    def output = sh(script: "echo \$(ls)", returnStdout: true)
                    echo "Output: ${output}"
                }
            }
        }
    }
}
---
# В данном случае шаг sh
  ➝ выполняет команду "echo $(ls)"
  ➝ и записывает ее вывод в переменную с помощью подстановки команд.

  Кроме того, pipeline job захватывает вывод команды "ls" в переменную "output"
  и печатает его в консоли Jenkins после выполнения.

Другие возможные случаи

  Jenkins pipeline предоставляет еще две важные опции, которые очень полезны для сохранения результата для дальнейшего использования в pipeline job.

  Метод returnStatus
    -> фиксирует статус выхода из команды оболочки,

  Метод returnStdoutTrim
    -> помогает обрезать вывод для дальнейшего использования


**************************
* Using the returnStatus *
**************************

  Шаг sh конвейера Jenkins использует опцию returnStatus для получения статуса выхода из команды shell.
  По умолчанию шаг sh возвращает стандартный вывод (standartd output) команды shell в качестве результата выполнения шага.

(!) Однако:
    если параметр returnStatus имеет значение true,
    вместо стандартного вывода возвращается статус выхода (exit status) из команды shell.

Давайте рассмотрим задание конвейера с методом returnStatus:
---
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                script {
                    def status = sh(returnStatus: true, script: 'ls /test')
                    if (status != 0) {
                        echo "Error: Command exited with status ${status}"
                    } else {
                        echo "Command executed successfully"
                    }
                }
            }
        }
    }
}
---
В этом примере шаг sh выполняет команду ls и записывает вывод в переменную status с помощью returnStatus. Поскольку каталог /test не существует, команда ls завершается с ненулевым статусом, что указывает на ошибку. Оператор if проверяет, не равна ли переменная status нулю, и если да, печатает сообщение об ошибке в консоли Jenkins.

Разработчики могут выполнять проверку ошибок, перехватывая статус выхода команд оболочки. Кроме того, они могут реализовать логику, основанную на успехе или неудаче команды.


*************************
* Using the Trim Method *
*************************

  В следующем фрагменте параметр returnStdout имеет значение true, что означает, что стандартный вывод команды будет захвачен и возвращен как результат шага. Кроме того, мы можем использовать метод trim(), чтобы получить очищенный вывод команды в переменной:
---
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                script {
                  def output = sh(returnStdout: true, script: 'echo "    hello    "').trim()
                  echo "Output: '${output}'"
                }
            }
        }
    }
}
---

Метод trim() удалит из вывода команды echo все ведущие и завершающие пробельные символы. Кроме того, консоль Jenkins будет отображать результирующий вывод, заключенный в одинарные кавычки, чтобы выделить все пробельные символы.


##################################################################
# Использование экранирования символов. Особенности языка Groovy #
##################################################################

(https://stackoverflow.com/questions/49177422/syntax-error-while-using-backslash-in-jenkinsfile/49180330#49180330)

[!] Символ '\' является специальным символом в Groovy.

  Если попытаться скомпилировать такой код:
---
sh """
    rm -r /mnt/x/some/directory/Problem\ 1.0/path
   """
---

  обычным компилятором Groovy, то он выдаст более корректное сообщение об ошибке,
  нежели консольный вывод выполнения пайплайна.
  
[*]  Самым простым способом справиться с этим будет экранирование (\\):
---
"""
  rm -r /mnt/x/some/directory/Problem\\ 1.0/path
""" 
---
