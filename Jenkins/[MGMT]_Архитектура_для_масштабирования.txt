Architecting for Scale
(https://www.jenkins.io/doc/book/scaling/architecting-for-scale/#distributed-builds-architecture)

◎ ● ☑ ☒ ➜
"""
  По мере того как организация развивается с точки зрения непрерывной доставки, растут и ее требования к Jenkins.
  Этот рост часто отражается в архитектуре Jenkins, будь то "вертикальный" или "горизонтальный" рост.

  Вертикальный рост
    - это когда нагрузка на контроллер Jenkins увеличивается за счет большего количества настроенных jobs или более частой организации сборок.
    Это также может означать, что от одного контроллера зависит больше команд.

  Горизонтальный рост
    - это создание дополнительных контроллеров Jenkins для размещения новых команд или проектов,
      а не добавление новых команд или проектов к существующему контроллеру.

  Каждый подход к масштабированию Jenkins сопряжен с потенциальными подводными камнями,
  но при тщательном планировании многих из них можно избежать или справиться с ними.
"""

Вот некоторые моменты, которые следует учитывать при выборе стратегии масштабирования контроллеров Jenkins в вашей организации:

  1. Есть ли у вас ресурсы для запуска распределенной системы сборки (distributed build system)?
     Если есть возможность, РЕКОМЕНДУЕТСЯ создать выделенные build nodes, работающие ОТДЕЛЬНО ОТ КОНТРОЛЛЕРА Jenkins.
     ПРЕИМУЩЕСТВА:
       ✓ Это освобождает ресурсы контроллера для повышения производительности планирования
       ✓ и не позволяет сборкам изменять любые потенциально важные данные в $JENKINS_HOME.
       ✓ также позволяет одному контроллеру масштабироваться гораздо более вертикально,
         чем если бы этот контроллер был одновременно
           и сборщиком заданий (job builder),
           и планировщиком (scheduler).

  2. Есть ли у вас ресурсы для поддержки нескольких контроллеров?
     Контроллеры Jenkins требуют
       - регулярного обновления плагинов,
       - полумесячного обновления ядра,
       - а также регулярного резервного копирования конфигураций и истории сборок.
     Параметры безопасности и роли (Security settings and roles) необходимо вручную настраивать для каждого контроллера.
     Отключенные контроллеры потребуют ручного перезапуска
       - контроллера Jenkins
       - и всех заданий, которые были убиты в результате отключения.

  3. Насколько важны проекты каждой команды?
     Рассмотрите возможность разделения наиболее важных проектов на отдельные контроллеры,
     чтобы минимизировать влияние одного вышедшего из строя контроллера.
     Также рассмотрите возможность преобразования всех критически важных пайплайнов проектов в Pipeline jobs,
     которые продолжают выполняться даже при потере связи агента с контроллером.

  4. Насколько важно быстрое время запуска контроллера Jenkins?
     (!) Чем больше jobs настроено в контроллере, тем больше времени требуется для загрузки Jenkins после обновления || сбоя.
     Использование folders (папок) и views (представлений) для организации заданий позволяет ограничить количество заданий,
     которые должны быть отображены при запуске.


*************************************
*  Distributed Builds Architecture  *
* Архитектура распределенных сборок *
*************************************

  Контроллер Jenkins может работать самостоятельно
  -> как управляя средой сборки
  -> так и выполняя сборки с помощью собственных исполнителей (executors) и ресурсов (resources).

/*
  Если вы будете придерживаться такой "автономной" конфигурации,
  то, скорее всего, при увеличении количества проектов или нагрузки на них у вас закончатся ресурсы.
*/

  Чтобы ВОССТАНОВИТЬ работоспособность инфраструктуры Jenkins, вам потребуется усилить контроллер
  (увеличить память, количество процессоров (CPUs) и т. д.).

  За то время, которое уйдет на обслуживание и модернизацию машины,
    - контроллер вместе со всем окружением сборки выйдет из строя,
    - задания будут остановлены,
    - и вся инфраструктура Jenkins станет непригодной для использования.

Масштабирование Jenkins при таком сценарии будет крайне болезненным и приведет к появлению множества периодов «простоя» (idle),
когда все ресурсы, выделенные для среды сборки, будут бесполезны.

[!] выполнение заданий на контроллере создает проблему «безопасности»:
    пользователь «jenkins», которого Jenkins использует для выполнения заданий,
    будет иметь ПОЛНЫЕ ПРАВА на ВСЕ РЕСУРСЫ Jenkins на контроллере.
    Это означает, что с помощью простого скрипта злоумышленник может получить прямой доступ к частной информации,
    целостность и конфиденциальность которой, таким образом, не может быть гарантирована.

#! Дополнительные сведения см. в разделе Распределенные сборки в главе Защита Jenkins:
# "Controller Isolation": https://www.jenkins.io/doc/book/security/controller-isolation/
# "Securing Jenkins": https://www.jenkins.io/doc/book/security/


=> По всем этим причинам Jenkins поддерживает агентов, где рабочая нагрузка по созданию проектов делегируется нескольким агентам.

Агент (agent) 
  = это машина, настроенная на разгрузку (offload) проектов от контроллера.
    Метод планирования сборок зависит от конфигурации, заданной для каждого проекта.

[Например:]
  некоторые проекты могут быть настроены на «ограничение места выполнения этого проекта» ( = restrict where this project is run),
  что привязывает проект к определенному агенту или набору помеченных агентов (labeled agents).

  Другие проекты, в которых эта настройка отсутствует, будут выбирать агента из доступного пула в Jenkins.

# Подробнее об агентах в разделе "Managing Nodes": https://www.jenkins.io/doc/book/managing/nodes/#creating-agents/


В распределенной среде сборки контроллер Jenkins будет использовать свои ресурсы только для
  + обработки HTTP-запросов
  + и управления средой сборки (build environment).

Фактическое выполнение сборок будет делегировано агентам.

Такая конфигурация позволяет ГОРИЗОНТАЛЬНО МАСШТАБИРОВАТЬ архитектуру,
=> что позволяет одной установке Jenkins размещать большое количество проектов и сред сборки.


************************
* Agent communications *
*   Связь с агентами   *
************************

[!] Для того чтобы машина была признана агентом, ей необходимо
    ЗАПУСТИТЬ специальную программу-агент для установления двунаправленной связи с контроллером.

Установить связь между контроллером и агентом можно разными способами:

  ● The SSH connector:
    = Настройка агента на использование SSH-коннектора является ПРЕДПОЧТИТЕЛЬНЫМ и НАИБОЛЕЕ СТАБИЛЬНЫМ СПОСОБОМ установления связи между контроллером и агентом.
      В Jenkins встроена реализация SSH-клиента.
      ==> контроллер Jenkins может легко взаимодействовать с ЛЮБОЙ МАШИНОЙ, на которой установлен SSH-сервер.
    [!] Единственное требование - открытый ключ контроллера должен входить в набор авторизованных ключей агента.

      Как только хост и SSH-ключ будут определены для нового агента,
      Jenkins установит соединение с машиной и загрузит процесс агента.

  ● The inbound connector:          # входящий коннектор
    = В этом случае связь устанавливается при запуске агента через соединение, инициированное программой-агентом.
      С помощью этого коннектора агент запускается на машине двумя разными способами:
      1) Вручную:
         = путем перехода на URL контроллера Jenkins в браузере НА АГЕНТЕ.
           После нажатия на иконку "Java Web Start" агент будет запущен на машине.

        ☒ Недостаток этого подхода:
            агенты НЕ МОГУТ ЦЕНТРАЛИЗОВАННО УПРАВЛЯТЬСЯ контроллером Jenkins,
            и каждая остановка/запуск/обновление агента должна выполняться ВРУЧНУЮ НА МАШИНЕ АГЕНТА в версиях Jenkins старше 1.611.

          Такой подход удобен, когда контроллер не может установить соединение с клиентом,
        # например: агенты, работающие в сети с брандмауэром, подключаются к контроллеру, расположенному за пределами брандмауэра.

      2) В качестве службы:
         = 1: вручную запустить агента, используя описанный выше метод.
           2: После ручного запуска в рабочем каталоге агента будут созданы файлы:
             - jenkins-slave.exe
             - и jenkins-slave.xml.
           3: Теперь перейдите в командную строку и выполните следующую команду:
-->
sc.exe create "<serviceKey>" start= auto binPath= "<path to jenkins-slave.exe>" DisplayName= "<service display name>"
<--

# <serviceKey> - это имя ключа реестра для определения этой службы агента,
# <service display name> - это метка, которая будет идентифицировать службу в интерфейсе Service Manager.

          Чтобы обеспечить автоматический перезапуск, вам нужно
            - загрузить свежий jar агента
            - и скопировать его в постоянное место на машине.
            # Файл_.jar_ можно найти по адресу: http://<your-jenkins-host>/jnlpJars/agent.jar
            # Если используется версия Jenkins новее 1.559, .jar будет обновляться при каждом подключении к контроллеру.

  ● The Inbound-HTTP connector:
    = Этот подход очень похож на подход Inbound-TCP Java Web Start,
    (!) с той лишь разницей, что агент ВЫПОЛНЯЕТСЯ БЕЗ ГОЛОВЫ,
        а соединение может быть туннелировано через HTTP(s).
    # Точную команду можно найти на странице конфигурации вашего агента Inbound:
// <см. изображение: https://www.jenkins.io/doc/book/resources/hardware-recommendations/inbound-agent.png>

  ● Custom-script:
    = Также можно создать собственный скрипт для инициализации связи между контроллером и агентом,
      если другие решения не обеспечивают достаточной гибкости для конкретного случая использования.

    [!] Единственное требование
        = чтобы скрипт запускал java-программу в виде java -jar agent.jar на агенте!

# Настройка агента Windows может соответствовать стандартным подходам SSH и входящих агентов.
# Агенты Windows имеют следующие возможности: <>


****************************
* Creating fungible agents *
* Создание сменных агентов *
****************************

Настройка расположения инструментов на агентах
(Configuring tools location on agents)

(*) На странице глобальной конфигурации Jenkins можно указать инструменты, необходимые для сборки (например, Ant, Maven, Java и т. д.).
    При определении инструмента можно создать указатель (pointer) на существующую установку,
    указав каталог, в котором программа должна находиться НА АГЕНТЕ.

    Другой вариант - позволить Jenkins позаботиться об установке определенной версии в указанном месте.

    Также можно указать более одной установки для одного и того же инструмента,
    поскольку для разных заданий могут потребоваться разные версии одного и того же инструмента.

Предварительно скомпилированная опция "Default" вызывает все, что уже установлено на агенте и существует в машинном PATH,
(!) но это приводит к ошибке:
    - если инструмент не установлен
    - и его местоположение не было добавлено в системную переменную PATH.

(!) Чтобы избежать этого сбоя, лучше всего сконфигурировать задание с предположением,
    что на целевом агенте не установлены необходимые инструменты,
    и включить установку инструментов в процесс сборки.


*******************************************
* Define a policy to share agent machines *
*******************************************

  Агенты должны быть
    + взаимозаменяемыми
    + и стандартизированными,
  => чтобы их можно было использовать совместно и оптимизировать использование ресурсов.

  Агенты НЕ ДОЛЖНЫ настраиваться
    - под конкретный набор заданий
    - или под конкретную команду.

  В последнее время Jenkins становится все более популярным не только в CI, но и в CD,
  а это значит, что он должен организовывать задания и пайплайны, в которых участвуют разные команды и технические профили:
    * разработчики,
    * QA-специалисты
    * и Dev-Ops-специалисты.

  В таком случае имеет смысл создавать специализированные агенты:
    для разных команд обычно требуются разные инструменты
    (например, Puppet/Chef для команды Ops),
    а учетные данные команд обычно хранятся на агенте, чтобы обеспечить их защиту и конфиденциальность.

Чтобы обеспечить выполнение задания только на одном/группе агентов
#(например, сборки iOS только на агентах OSX),
  можно привязать задание к агенту, указав его label на странице конфигурации задания.

(!) Обратите внимание,
    что ограничение должно быть продублировано В КАЖДОМ отдельном задании, которое нужно привязать,
    и что агент не будет защищен от использования другими командами.


***************************
* Setting up cloud agents *
***************************

  Облачные ресурсы сборки могут стать решением для случая,
  -> когда необходимо поддерживать достаточно небольшой кластер агентов в локальной сети
     и при этом предоставлять НОВЫЕ ресурсы сборки ПО МЕРЕ НЕОБХОДИМОСТИ.

  В частности, можно переложить выполнение заданий на агентов в облаке благодаря ad-hoc плагинам,
  которые будут управлять созданием облачных ресурсов и их уничтожением, когда они больше не нужны:

  * Плагин EC2 Plugin
    -> позволяет Jenkins использовать экземпляры AWS EC2 в качестве облачных ресурсов для сборки,
       когда у нее заканчиваются локальные агенты.
       Агенты EC2 будут
       ✓ ДИНАМИЧЕСКИ создаваться в сети AWS
       ✓ и удаляться, когда они не нужны.

  * Плагин Azure VM Agents Plugin
    -> динамически запускает агентов Jenkins как виртуальные машины Azure
       в соответствии с конфигурацией, предоставленной пользователем с помощью шаблонов,
       включая поддержку интеграции виртуальных сетей и размещения подсетей.
       Простаивающие агенты могут быть настроены на автоматическое отключение для снижения затрат.

  * Плагин JCloud
    -> создает возможность выполнения заданий на любом облачном провайдере,
       поддерживаемом библиотеками JCloud.



******************************
* Anatomy of a $JENKINS_HOME *
******************************

Структура папок в каталоге $JENKINS_HOME выглядит следующим образом:

--<$JENKINS_HOME>--
#JENKINS_HOME
```
 +- config.xml     (корневой конфигурационный файл Jenkins)
 +- *.xml          (другие файлы конфигурации всего сайта)
 +- identity.key   (RSA key pair that identifies an instance)
 +- secret.key     (устаревший ключ, используемый для безопасных операций некоторых плагинов)
 +- secret.key.not-so-secret  (используется для проверки даты создания _$JENKINS_HOME_)
 +- userContent    (файлы, обслуживаемые по вашему адресу https://server/userContent/)
 +- secrets        (корневой каталог для секрета+ключа (secret+key) для расшифровки учетных данных)
     +- hudson.util.Secret   (используется для шифрования некоторых данных Jenkins)
     +- master.key           (используется для шифрования ключа hudson.util.Secret)
     +- InstanceIdentity.KEY (используется для идентификации данного экземпляра)
 +- fingerprints   (хранит записи об fingerprint, если таковые имеются)
 +- plugins        (корневая директория для всех плагинов Jenkins)
     +- [PLUGINNAME]   (подкаталог для каждого плагина)
         +- META-INF       (subdirectory for plugin manifest + pom.xml)
         +- WEB-INF        (subdirectory for plugin jar(s) and licenses.xml)
     +- [PLUGINNAME].jpi   (файлы .jpi или .hpi для плагина)
 +- jobs           (корневая директория для всех Jenkins jobs)
     +- [JOBNAME]      (подкаталог для каждого задания)
         +- config.xml     (job configuration file)
         +- workspace      (рабочий каталог для системы контроля версий)
         +- latest         (символическая ссылка на последнюю успешную сборку)
         +- builds         (сохранённые записи о прошлых сборках)
             +- [BUILD_ID]     (подкаталог для каждой сборки)
                 +- build.xml      (сводка результатов сборки)
                 +- log            (log file)
                 +- changelog.xml  (change log)
     +- [FOLDERNAME]   (подкаталог для каждой папки)
         +- config.xml     (конфигурафионный файл папки)
         +- jobs           (подкаталог для всех вложенных заданий)
```