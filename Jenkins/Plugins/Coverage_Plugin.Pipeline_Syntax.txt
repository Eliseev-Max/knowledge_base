Coverage Plugin. Jenkins Pipeline integration

[sources:]
  1) "Coverage Plugin": https://www.jenkins.io/doc/pipeline/steps/coverage/
  2) "Pipeline Syntax. Steps": https://www.jenkins.io/doc/book/pipeline/syntax/#declarative-steps


recordCoverage: Record code coverage results

  ● checksAnnotationScope (optional)
    = Выберите область применения аннотаций исходного кода в проверках SCM.
      Поддерживаются следующие различные области видимости:
      > SKIP
        = Пропустить аннотации
          Не публикуйте никаких аннотаций, просто сообщите краткое содержание отчета о покрытии.

      > MODIFIED_LINES
        = Публиковать аннотации для измененных строк
          Публикуйте аннотации только для строк, которые были изменены (по сравнению с эталонной сборкой).
          Команды разработчиков могут использовать эти аннотации для улучшения качества pull || merge request'ов.

      > ALL_LINES
        = Публикация аннотаций для всех строк
          Публикуйте аннотации для существующего и нового кода.
          В зависимости от покрытия кода аннотаций может быть много.

      Values: SKIP, MODIFIED_LINES, ALL_LINES


  ● checksName : String (optional)
    = Если имя указано, и проверка публикации включена,
        -> плагин будет использовать это имя при публикации результатов на соответствующих платформах хостинга SCM.
      Если нет,
        -> будет использоваться имя по умолчанию.

  ● enabledForFailure : boolean (optional)
    = Этот переключатель определяет, нужно ли включать запись результатов покрытия кода и для НЕУДАЧНЫХ (failed) сборок.
      По умолчанию результаты покрытия кода записываются только для стабильных и нестабильных сборок (stable or unstable),
      но НЕ ДЛЯ НЕУДАЧНЫХ (failed) СБОРОК: результаты покрытия кода могут быть неточными, если сборка не удалась.


  ● failOnError : boolean (optional)
    = Этот переключатель определяет, должен ли плагин покрытия завершать шаг неудачей,
      если при обработке результатов покрытия произошла ошибка.
      Может возникнуть несколько ошибок:
        - шаблон файла не совпадает с файлами,
        - исходные файлы не удалось скопировать
          и т. д.
      По умолчанию эти ошибки регистрируются в отдельном представлении,
      НО СТАТУС сборки при этом НЕ ИЗМЕНЯЕТСЯ.
      Если вы хотите, чтобы шаг не выполнялся при таких ошибках, установите этот флажок.

  ● id : String (optional)
    = Вы можете переопределить идентификатор по умолчанию (т. е. URL), который используется для публикации результатов покрытия в этом задании.
      Этот идентификатор используется в качестве ссылки на результаты, поэтому выберите короткое и осмысленное имя.
      Допустимыми элементами являются символы, цифры, тире и подчеркивания 
      (точнее, идентификатор должен соответствовать регулярному выражению \p{Alnum}[\p{Alnum}-_]*).
      Выбранный идентификатор должен быть уникальным в задании, ( = т. е. не должен уже использоваться в других результатах).
      Если оставить поле ID пустым, то для отображения результатов будет использоваться встроенный ID по умолчанию «coverage».

  ● ignoreParsingErrors : boolean (optional)
    = Этот переключатель определяет, должен ли плагин покрытия игнорировать ошибки парсинга во время обработки отчетов о покрытии
      или же он должен быстро завершать работу с исключением.
      По умолчанию этот переключатель ОТКЛЮЧЕН, и парсеры будут быстро выходить из строя.
        Это помогает выявить ошибки в парсере или в выполнении инструмента покрытия.
      Если вы хотите ИГНОРИРОВАТЬ ОШИБКИ ПАРСИНГА => УСТАНОВИТЕ этот флажок.
      [!] в этом случае результаты работы парсера могут быть неполными или даже ошибочными.


  ● name : String (optional)
    = Вы можете переопределить отображаемое имя результатов покрытия.
      Это имя используется
        * в представлениях подробностей (details views),
        * подписях трендов,
        * гиперссылках
        * и заголовках проверок.
      Если оставить поле имени пустым, то будет использоваться встроенное имя по умолчанию "Coverage Results" («Результаты покрытия»).

  ● qualityGates (optional)
    = Добавьте один или несколько quality gates, которые будут проверяться сразу после сборки.
      Для каждых quality gates можно определить, какая метрика и базовая линия будут использоваться для выбора значения,
      которое будет сравниваться с порогом.

    ** Массив / Список вложенных объектов (Nested Object): **
      ▪ metric
        = Выберите метрику, которая должна быть оценена для этих quality gate.
          Поддерживаются следующие различные метрики:
            MODULE = покрытые и пропущенные модули (указывается в процентах)
            PACKAGE = покрытые и пропущенные пакеты - также используется для пространств имен или каталогов (дается в процентах)
            FILE = покрытые и пропущенные файлы (указывается в процентах)
            CLASS = покрытые и пропущенные классы (указывается в процентах)
            METHOD = покрытые и пропущенные методы (указывается в процентах)
            LINE =  покрытие строк (указывается в процентах)
            INSTRUCTION = покрытие инструкций (указывается в процентах)
            BRANCH = покрытие ветвей или решений (указывается в процентах)
            MUTATION = покрытие мутаций (указывается в процентах)
            MCDC_PAIR = покрытие пар MC/DC (указывается в процентах)
            FUNCTION_CALL = покрытие вызовов функций (указывается в процентах)
            TEST_STRENGTH = прочность теста (указывается в процентах)
            CYCLOMATIC_COMPLEXITY = цикломатическая сложность (приводится в виде абсолютного числа)
            COGNITIVE_COMPLEXITY = когнитивная сложность (приводится в виде абсолютного числа)
            NPATH_COMPLEXITY = Сложность N-пути (N-Path) (приводится в виде абсолютного числа)
            LOC = Строки кода (приводится в виде абсолютного числа)
            NCSS = Non Commenting Source Statements, некомментируемые исходные тексты (приводится в виде абсолютного числа)
            COHESION = сплоченность класса (указывается в процентах)
            WEIGHT_OF_CLASS = вес класса (указывается в процентах)
---
Values:
  CONTAINER,
  MODULE,
  PACKAGE,
  FILE,
  CLASS,
  METHOD,
  LINE,
  BRANCH,
  INSTRUCTION,
  MCDC_PAIR,
  FUNCTION_CALL,
  MUTATION,
  TEST_STRENGTH,
  TESTS,
  LOC,
  NCSS,
  CYCLOMATIC_COMPLEXITY,
  COGNITIVE_COMPLEXITY,
  NPATH_COMPLEXITY,
  ACCESS_TO_FOREIGN_DATA,
  COHESION,
  FAN_OUT,
  NUMBER_OF_ACCESSORS,
  WEIGHT_OF_CLASS,
  WEIGHED_METHOD_COUNT
//

      ▪ baseline (optional)             # = базовая линия
        = Выберите базовую линию, которая будет использоваться для расчета покрытия кода для этих quality gate.
          Поддерживаются следующие различные базовые линии:
            Общий проект - PROJECT
              Охват всего проекта. Это абсолютное значение, которое может не сильно меняться от сборки к сборке.

            Общий проект (разница с эталонным заданием) - PROJECT_DELTA
              Разница между покрытием проекта в текущей и эталонной сборках.
              Команды могут использовать это значение дельты, чтобы гарантировать, что общее покрытие проекта не уменьшится.

            Измененные файлы - MODIFIED_FILES
              Охват изменённых файлов
              (например, файлов, которые были затронуты в pull или merge request)
              будет сосредоточен только на НОВЫХ или ИЗМЕНЁННЫХ файлах.

            Измененные файлы (отличие от эталонного задания) - MODIFIED_FILES_DELTA
              Разница между покрытиями файлов в текущей и эталонной сборках.
              Команды могут использовать это значение дельты, чтобы гарантировать, что общее покрытие всех измененных файлов не уменьшится.
              Это также подразумевает, что общее покрытие проекта не уменьшится, что делает эту метрику более строгой, чем метрика PROJECT_DELTA

            Изменённые строки кода - MODIFIED_LINES
              Охват измененных строк (например, в пределах измененных строк pull или merge request'а) будет сосредоточен только на новом или измененном коде.

            Измененные строки кода (разница с измененными файлами) - MODIFIED_LINES_DELTA
              Разница между покрытием измененных строк и измененных файлов текущей сборки.
              Команды могут использовать это значение дельты, чтобы гарантировать, что покрытие pull requests'ов будет лучше,
              чем существующее покрытие измененных файлов.

#Values: PROJECT, PROJECT_DELTA, MODIFIED_LINES, MODIFIED_LINES_DELTA, MODIFIED_FILES, MODIFIED_FILES_DELTA, INDIRECT

      ▪ criticality
        Если ворота качества пропущены, это свойство определяет, будет ли результат связанного шага покрытия или сборки в целом помечен как нестабильный или неудачный.
        Для заданий вольного стиля возможны следующие значения перечисления:
          UNSTABLE
            Установите статус шага и сборки на нестабильный, если ворота качества были пропущены.

          FAILURE
            Провалить шаг и сборку, если пропущены ворота качества.
            Для конвейеров доступны две дополнительные тонкие опции, которые позволяют установить статус шага, не затрагивая общий статус сборки:

          NOTE
            = Установите шаг на нестабильный, если ворота качества были пропущены.

          ERROR
            = Провалите (зафэйлите) шаг, если quality gate были пропущены.

#Values: NOTE, UNSTABLE, ERROR, FAILURE

      ▪ integerThreshold : int

      ▪ threshold : double
        = Порог определяет минимальное или максимальное значение (в зависимости от metric) метрики покрытия,
          которое необходимо для прохождения или непрохождения quality gate.

  ● scm: String (optional)
    = Укажите ключ вашего репозитория (достаточно подстроки), если вы используете несколько SCM в задании.
        Если задание состоит из нескольких SCM (модулей, библиотек конвейера и т. д.),
        Jenkins хранит все эти репозитории в несортированном виде.

  ● skipPublishingChecks : boolean (optional)
    = Если эта опция не отмечена, то плагин автоматически публикует сводку отчета о покрытии на соответствующих платформах хостинга SCM. Например, если вы используете эту функцию для проекта организации GitHub, сводка покрытия будет опубликована на GitHub через Checks API. Если эта операция замедляет сборку, или вы не хотите публиковать сводку на SCM-платформах, вы можете использовать эту опцию для отключения данной функции.

  ● skipSymbolicLinks : boolean (optional)
    = При включении этой опции плагин покрытия не будет обходить символические ссылки при сканировании файлов отчетов или исходного кода.

  ● sourceCodeEncoding : String (optional)
    = Чтобы плагин корректно отображал все ваши покрытые файлы исходного кода в детальных представлениях,
      он должен открывать их с правильной кодировкой (UTF-8, ISO-8859-1 и т. д.).
      Если оставить это поле пустым, то будет использоваться кодировка платформы по умолчанию.
      Это может работать, но НЕ РЕКОМЕНДУЕТСЯ.

  ● sourceCodeRetention (optional)
      Выберите стратегию, которая будет использоваться для хранения окрашенных файлов исходного кода. Хранение затронутых файлов исходного кода вместе с информацией о покрытии (какие строки были покрыты, какие нет) занимает много места на жестком диске для больших проектов. Поэтому, если на вашем сервере недостаточно свободного места для хранения исходных текстов всех сборок, возможно, имеет смысл хранить только результаты покрытия последней сборки. В этом случае плагин автоматически удалит старые результаты, прежде чем будут сохранены новые исходники. Если вам не нужны исходные файлы вообще, вы можете отключить хранение файлов исходного кода.
      Поддерживаются следующие варианты:
        NEVER
          = никогда не хранить файлы исходного кода.
        LAST_BUILD
          хранить файлы исходного кода последней сборки, удалять старые артефакты.
        EVERY_BUILD
          хранить файлы исходного кода для всех сборок, никогда не удалять эти файлы автоматически.
        MODIFIED
          сохранять только измененные файлы исходного кода для всех сборок, никогда не удалять эти файлы автоматически

#Values: NEVER, LAST_BUILD, EVERY_BUILD, MODIFIED

  ● sourceDirectories (optional)
    = Выберите дополнительные папки, содержащие файлы исходного кода задания.
      Поскольку плагин также считывает затронутые файлы исходного кода, ему необходимо скопировать эти файлы из агента в контроллер.
      Если эти файлы не входят в состав WORKSPACE (или извлечены в подпапку WORKSPACE),
      они не будут найдены автоматически.
      Поэтому вы можете добавить один или несколько каталогов исходного кода, в которых плагин попытается найти эти файлы.
      Вы можете добавить
        - относительные пути в корне WORKSPACE,
        - абсолютные пути
        - или выражения с использованием синтаксиса glob или regexp,
          которые поддерживаются реализацией Java FileSystem#getPathMatcher.

      [Обратите внимание]
        из-за ограничений безопасности дополнительные пути за пределами workspace
        ДОЛЖНЫ БЫТЬ ЗАРЕГИСТРИРОВАНЫ в системной конфигурации Jenkins, прежде чем их можно будет использовать здесь.


** Примеры для синтаксиса и свойства pattern: **
-->
submodule/src/main/java
# = Относительный путь submodule/src/main/java в Jenkins workspace.

glob:**/src/main/java
# = glob, который расширяется до всех папок в workspace Jenkins, содержащих подпуть src/main/java.

regex:sources.*/src/main/java
# = Регулярное выражение, которое соответствует всем папкам в Jenkins workspace, начинающимся с sources и заканчивающимся текстом src/main/java.

C:\work\sources
# = Абсолютный путь на агенте, который собирает исходники.
#   Эта папка также должна быть одобрена администратором Jenkins в глобальной конфигурации Jenkins.


<--
  ** Массив / Список вложенных объектов (Nested Object): **
    - path : String
      Выберите путь к файлам исходного кода.
      Этот плагин копирует файлы исходного кода в папку сборки Jenkins, чтобы эти файлы могли отображаться в пользовательском интерфейсе вместе с результатами работы плагина. Если на эти файлы ссылаются по относительным путям, то они не могут быть найдены плагином. В этом случае вам нужно указать один или несколько относительных путей в рабочей области, по которым плагин сможет их найти. Также можно указать абсолютные пути, если файлы исходного кода хранятся вне рабочей области (в каталоге на агенте).
      Все абсолютные пути должны быть дополнительно одобрены администратором на странице глобальной конфигурации Jenkins.

  ● tools (optional)
    = Выберите один из поддерживаемых форматов отчетов о покрытии.
      Большинство инструментов покрытия поддерживают вывод отчета в формат Cobertura.
      Чтобы узнать, поддерживается ли этот формат, обратитесь к руководству вашего инструмента покрытия.

  ** Массив / Список вложенных объектов (Nested Object): **
    - parser (optional)
      = Выберите идентификатор парсера, который должен читать и разбирать ваши файлы отчетов;
        в настоящее время поддерживаются парсеры для
          Cobertura (id = COBERTURA),
          JaCoCo (id = JACOCO)
          и PIT (id = PIT).

#Values: COBERTURA, VECTORCAST, JACOCO, OPENCOVER, PIT, JUNIT, NUNIT, XUNIT, METRICS

    - pattern : String (optional)
      = шаблон определяется параметром Ant Fileset includes
        # https://ant.apache.org/manual/Types/fileset.html
        который задает файлы отчетов о покрытии для чтения.
        Разделите несколько шаблонов пробелом или запятой.
        Обратите внимание, что такой шаблон разрешается в рабочем пространстве Jenkins,
        => поэтому пути должны быть ТОЛЬКО ОТНОСИТЕЛЬНЫМИ.
        Если шаблон не указан:
          будет использован шаблон по умолчанию инструмента покрытия.