# Плагины:
Multiselect parameter  -  работа с взаимосвязанными параметрами
Git parameter  -  выбор ветки репозиторий для сборки
Copy Artifact  -  копирование артефактов из другой сборки
Test Result Analyzer  -  анализ результатов тестов
Build Pipeline  -  удобное отображение upstream/downstream сборок
Git Changelog  -  отображение информации о коммите
Docker  -  Docker-контейнеры в качестве executors
Email Extension  -  гибкая настройка отправки email
Job Configuration History  -  изменения в настройках сборок


# Jenkinsfile (Declarative Pipeline)

# В синтаксисе декларативного пайплайна блок пайплайна определяет всю работу, выполняемую во всем пайплайне. 

pipeline {
    agent any 				# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stages {
        stage('Build') { 	# Определяет стадию "Build"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Build"
            }
        }
        stage('Test') { 	# Определяет стадию "Test"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Test"
            }
        }
        stage('Deploy') { 	# Определяет стадию "Deploy"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
            }
        }
    }
}

Декларативный pipeline - это относительно недавнее дополнение к Jenkins Pipeline, которое представляет более упрощенный и
самодостаточный синтаксис поверх подсистем pipeline.

Отличия Declarative Pipeline от синтаксиса Groovy:
	• верхний уровень Pipeline должен быть блоком, а именно: pipeline { };
    • точки с запятой не используются в качестве разделителей операторов, каждое выражение должно быть на отдельной строке;
    • блоки должны состоять только из разделов (Sections), директив (Directives), шагов (Steps) или операторов присваивания.
	• оператор ссылки на свойство рассматривается как вызов метода без аргументов. Так, например, ввод обрабатывается как input(). 

!!! В настоящее время существует нерешенная проблема, которая ОГРАНИЧИВАЕТ максимальный размер кода в блоке pipeline {}
	Это ограничение не распространяется на Scripted Pipeline 

Разделы (Sections):
	Разделы в Declarative Pipeline обычно содержат одну или более директиву (Directives) или шаг (Steps)

	agent
		
		Раздел agent указывает:
			► где будет выполняться весь pipeline, если расположен на самом верхнем уровне; ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ ЗАДАН
			► где будет выполняться определённый Stage, на уровне этапа (Stage)	-	НЕОБЯЗАТЕЛЬНО ЗАДАВАТЬ

		Различия между агентами высшего уровня (Top Level Agents) и агентами уровня этапа (Stage Agents)
		Top Level Agents:		
			параметры вызываются после входа в агент.
			Например, при использовании тайм-аута он будет применяться только к выполнению внутри агента

			node("myAgent") {
				timeout(unit: 'SECONDS', time: 5) {
					stage("One"){
						sleep 10
						echo 'hello'
					}
				}
			}

		Stage Agents
		параметры вызываются перед входом в агент и перед проверкой любых условий.
		В этом случае при использовании тайм-аута он применяется до выделения агента.
		
			timeout(unit: 'SECONDS', time: 5) {
				stage("One"){
					node {
						sleep 10
						echo 'Hello'
					}
				}
			}
	
		Этот тайм-аут будет включать время подготовки агента.
		Поскольку тайм-аут включает время подготовки агента, pipeline может дать сбой в тех случаях, когда выделение агента задерживается.
		
Параметры
	Для поддержки широкого спектра вариантов использования, которые могут быть у авторов Pipeline,
	раздел агента поддерживает несколько различных типов параметров.
	Эти параметры могут применяться на верхнем уровне блока pipeline или внутри директивы каждого этапа. 
		
	• any
		выполняет Pipeline или этап на любом доступном агенте 
		pipeline {
			agent any
			...
		}
		
	• none
		при применении на верхнем уровне блока pipeline глобальный агент не будет выделен для всего запуска конвейера;
		каждый раздел этапа должен будет содержать свой собственный раздел агента
		pipeline {
			agent none
			...
		}
		
	• label
		выполненяет Pipeline или этап на агенте, доступном в окружении Jenkins с предоставленной меткой
		pipeline {
			agent  label 'my-defined-label' }
			...
		}
		
	• node
		agent { node { label 'labelName' } } 
			ведёт себя так же, как и 
		agent { label 'labelName' },
			но node позволяет использовать дополнительные параметры, такие как customWorkspace 
		
	• docker
		Выполняет Pipeline или этап с заданным контейнером, который будет динамически подготовлен на node,
		предварительно настроенном для приёма Pipelines на основе Docker или на node, соответствующем параметру метки.
		Docker также опционально может принимать параметр args, содержащий аргументы для непосредственной передачи
		в вызов docker run, и параметр alwaysPull, который принудительно выполнит команду docker pull,
		даже если имя образа уже существует.
		Пример:
			agent { docker 'maven:3.8.1-adoptopenjdk-11' }
			
			или
			
		agent {
    docker {
        image 'maven:3.8.1-adoptopenjdk-11'
        label 'my-defined-label'
        args  '-v /tmp:/tmp'
		}
	}	
	
	# !!! Имя параметра и его значение, взятое в " " или ' ' внутри директивы docker разделяются только пробелом!
	
	docker также дополнительно принимает параметры:
		♦ registryUrl,
		♦ registryCredentialsId,
	которые помогут указать используемый репозиторий Docker и его учетные данные.
	Параметр registryCredentialsId можно использовать отдельно для частных репозиториев в Docker Hub. Например: 
	
	agent {
    docker {
        image 'myregistry.com/node'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
		}
	}

	• dockerfile
		Выполняет Pipeline или этап с помощью контейнера, который собран из Dockerfile, содержащегося в исходном репозитории.
		Чтобы использовать этот параметр:
			► файл Jenkinsfile должен быть загружен либо из многоветвевого Pipeline, либо из конвейера из SCM.
		Обычно это Dockerfile в корне исходного репозитория:
		
		agent { dockerfile true }

		Параметры dockerfile:
			♦ dir						- если Dockerfile содержится не в корневом, а в другом каталоге
			♦ filename					- если файл Dockerfile имеет другое имя
			♦ additionalBuildArgs		- если требуется передать дополнительные аргументы команде docker build …​
			♦ registryUrl				- если нужно указать используемый репозиторий Docker
			♦ registryCredentialsId		- если нужно указать учетные данные репозитория Docker
		
		Примеры:
			Если Dockerfile содержится не в корневом, а в другом каталоге:

			agent { dockerfile { dir 'someSubDir' } }

		Передаём дополнительные аргументы команде docker build …​ :
		
			agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }.
		
		Пример репозитория с файлом build/Dockerfile.build, ожидающего версию аргумента сборки: 
		
			agent {
			// Equivalent to "docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/
				dockerfile {
					filename 'Dockerfile.build'
					dir 'build'
					label 'my-defined-label'
					additionalBuildArgs  '--build-arg version=1.0.2'
					args '-v /tmp:/tmp'
				}
			}
	
		Указываем используемый реестр Docker и его учетные данные:
		
			agent {
				dockerfile {
					filename 'Dockerfile.build'
					dir 'build'
					label 'my-defined-label'
					registryUrl 'https://myregistry.com/'
					registryCredentialsId 'myPredefinedCredentialsInJenkins'
				}
			}

	Общие параметры
	
	Некоторые опции, которые можно применить к 2 или более agent.
	Опции не являются обязательными, если иное не указано явно.
	
	♦ label
		Тип данных: string
		Метка или условие метки для запуска Pipeline или отдельного этапа (stage).
		Опция label валидна для
			◘ node
			◘ docker
			◘ dockerfile
		
		Опция label требуется для
			■ node
		
	♦ customWorkspace
		Тип данных: string
		Запускает Pipeline или отдельный этап (stage) к которому применяется этот agent,
		в указанной настраиваемой рабочей области, а не по умолчанию.
		Указанный путь может быть
			относительным  → в этом случае пользовательский workspace будет находиться в корневом каталоге рабочего пространства на узле;
			абсолютным
			
		Пример:
		agent {
			node {
				label 'my-defined-label'
				customWorkspace '/some/other/path'
			}
		}
		
	♦ reuseNode
		Тип данных: boolean
		Значение по умолчанию: false
		Если значение true → Pipeline запускается на узле, указанном на верхнем уровне (Top Level) pipeline, в той же Workspace,
		а не на новом узле целиком.
		Опция reuseNode валидна для
			◘ docker
			◘ dockerfile
		
		Опция reuseNode действует только в том случае, когда применена к отдельному stage
		
	♦ args
		Тип данных: string
		Аргументы времени выполнения, используемые для передачи в команду docker run
		Опция args валидна для
			◘ docker
			◘ dockerfile
		
		Пример №1: Агент Docker, синтаксис: Declarative Pipeline
		
			pipeline {
				agent { docker 'maven:3.8.1-adoptopenjdk-11' } 		# [1]
				stages {
					stage('Example Build') {
						steps {
							sh 'mvn -B clean verify'
						}
					}
				}
			}
		[1] - выполняет все шаги, определённые в этом Pipeline во вновь созданном контейнере
			  с заданным именем и тегом 3.8.1-adoptopenjdk-11
			  
		Пример №2: Pipeline с агентами уровня stage в разделах
		
			pipeline {
				agent none 												# [1]
				stages {
					stage('Example Build') {
						agent { docker 'maven:3.8.1-adoptopenjdk-11' } 	# [2]
						steps {
							echo 'Hello, Maven'
							sh 'mvn --version'
						}
					}
					stage('Example Test') {
						agent { docker 'openjdk:8-jre' } 				# [3]
						steps {
							echo 'Hello, JDK'
							sh 'java -version'
						}
					}
				}
			}

		[1] - Определение agent none на верхнем уровне Pipeline гарантирует, что исполнитель (Executor) не будет назначен без необходимости.
			  Использование agent none также делает необходимым определение собственного раздела agent в каждом этапе (stage).
			  
			* Executor (Исполнитель) - слот для выполнения работы, определенной Pipeline-ом или проектом на узле.
			На узле может быть настроено 0 или более исполнителей, что соответствует количеству одновременных проектов
			или pipeline-ов, которые могут выполняться на этом узле.
			
		[2] - Выполнить шаги на данном этапе во вновь созданном контейнере, используя этот образ
		[3] - Выполнить шаги на данном этапе во вновь созданном контейнере, используя образ, отличный от предыдущего этапа

	Раздел post
	
		Раздел post определяет один или несколько дополнительных шагов, которые выполняются после завершения Pipeline или этапа
		(в зависимости от расположения раздела post в конвейере).
		Поддерживаемые post блоки пост-условия:
		
			• always
				запускает шаги в разделе post независимо от статуса завершения Pipeline или этапа
				
			• changed
				запускает шаги в разделе post, только если текущий запуск Pipeline или этапа имеет статус завершения, отличный от предыдущего запуска.  
				<статус текущего запуска отличается от статуса предыдущего>
			• fixed
				запускает шаги в разделе post, только если
					текущий запуск Pipeline или этапа успешен (=successful)
						и 
					предыдущий запуск завершился неудачно или был нестабильным (failure | unstable)  
				
			• regression
				запускает шаги в разделе post, только если
					текущий запуск Pipeline или этапа    завершился неудачно (=failure)	или
														 был нестабильным (=unstable)	или
														 был прерван (aborted)
						и
					предыдущий запуск был успешен (=successful)
				
			• aborted
				запускает шаги в разделе post, только если выполнение текущего Pipeline или этапа было прервано (=aborted)
				обычно вручную (пользователем)
				обозначается обычно серым цветом в веб UI
				
			• failure
				запускает шаги в разделе post, только если текущий Pipeline или этап завершился неудачно (=failure)
				обозначается обычно красным цветом в веб UI
				
			• success
				запускает шаги в разделе post, только если статус выполнения текущего Pipeline или этапа был "успешно" (=success)
				обозначается обычно синим или зелёным цветом в веб UI
				
			• unstable
				запускает шаги в разделе post, только если текущее выполнение Pipeline или этапа имеет статус: «нестабильный».
				Обычно это может быть вызванно
					♦ сбоями тестирования,
					♦ нарушениями кода 
					  и т. д.
				обозначается обычно желтым цветом в веб-интерфейсе.
				
			• unsuccessful
				запускает шаги в разделе post, только если текущий запуск Pipeline или этапа НЕ ИМЕЕТ статуса "успешно" (=success)
				обозначается в веб UI в соответствии со значением статуса (см. выше)
				
			• cleanup
				запускает шаги в разделе post после того, как будут оценены все остальные условия post, независимо от состояния конвейера или этапа. 
				
		! Эти блоки условий разрешают выполнение шагов внутри каждого условия в зависимости от статуса завершения Pipeline или этапа.
		Блоки условий выполняются в следующем порядке:
		
			Необходимые (Required)
					▼
				Параметры
					▼
			   Разрешённые

########################################################################################
########################################################################################
########################################################################################

# Jenkinsfile (Scripted Pipeline)

# В синтаксисе Scripted Pipeline один или несколько узловых блоков (node {stage('nameOfStage1'){//}stage('nameOfStage2'){//}...})
# выполняют основную работу во всем пайплайне.
# Хотя это не является обязательным требованием синтаксиса Scripted Pipeline, ограничение работы вашего конвейера внутри блока узла делает две вещи:
#	1. Планирует выполнение шагов, содержащихся в блоке, путем добавления элемента в очередь Jenkins. 
# 	   Как только исполнитель освободится на узле, шаги будут запущены.
# 	2. Создает рабочую область (каталог, относящийся к конкретному конвейеру), где можно выполнять работу с файлами, извлеченными из системы управления версиями.
#      Предупреждение. В зависимости от конфигурации Jenkins некоторые рабочие области могут не очищаться автоматически после определенного периода бездействия. 

node {  					# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stage('Build') { 		# Определяет стадию "Build". Блоки stage являются необязательными в синтаксисе Scripted Pipeline. 
							# Однако реализация блоков этапов в Scripted Pipeline обеспечивает более четкую визуализацию подмножества
							# задач/шагов каждого этапа в пользовательском интерфейсе Jenkins.
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Build"
    }
    stage('Test') { 		# Определяет стадию "Test"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Test"
    }
    stage('Deploy') { 		# Определяет стадию "Deploy"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
    }
}


Пример:

#!groovy
//Check ub1 properties
properties([disableConcurrentBuilds()])		# Запретить параллельную сборку несколькими пользователями

pipeline {
	agent {
		label 'main'		# указываем, что собираем в ветке main
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: '2', artifactNumToKeepStr: '2'))
		timestamps()
	}
	stages {
		stage("Create docker image") {
			steps {
				echo " ========== start building image ========== "
				dir ('path/to/the/Dockerfile/in/repo') {
				sh 'docker build -t pipeline_tests . '
				}
			}
		}
	}
}


############################################################################
############################################################################
############################################################################
############################################################################

* Jenkinsfile — это текстовый файл, содержащий определение пайплайна Jenkins и зарегистрированный в системе управления версиями.

Предполагается, что для проекта уже настроен репозиторий системы управления версиями, а пайплайн определен в Jenkins в соответствии с этими инструкциями.


# Jenkinsfile (Scripted Pipeline)

node {						# выделяет исполнителя и рабочее пространство для конвейера;
							# без узла Pipeline не может выполнять никакой работы
    checkout scm 			# scm — это специальная переменная, которая указывает шагу проверки клонировать конкретную ревизию, которая инициировала этот запуск Pipeline 
    /* .. snip .. */
}


################################

Шаг скрипта (сцкнария) берет блок Scripted Pipeline-а и выполняет его в декларативном конвейере.
В большинстве случаев шаг сценария не нужен в декларативных конвейерах, но он может предоставить полезный «аварийный выход».
Вместо этого блоки сценариев нетривиального размера и/или сложности следует перемещать в общие библиотеки (Shared Libraries).

Scripted Pipeline, как и Declarative Pipeline, построен поверх базовой подсистемы Pipeline.
В отличие от Declarative, Scripted Pipeline фактически представляет собой DSL общего назначения [2], созданный с помощью Groovy.
Большая часть функций, предоставляемых языком Groovy, доступна пользователям Scripted Pipeline, что означает, что он может быть очень выразительным и гибким инструментом, с помощью которого можно создавать Continuous Delivery Pipeline.

Scripted Pipeline выполняется последовательно, начиная с верхней части Jenkinsfile вниз, как и большинство традиционных сценариев в Groovy или других языках. Таким образом, обеспечение управления потоком основывается на выражениях Groovy, таких как условные операторы if/else, например:

###############################


https://docs.qameta.io/allure/#_jenkins
https://docs.cloudbees.com/docs/admin-resources/latest/plugins/docker-workflow

https://www.jenkins.io/doc/pipeline/steps/allure-jenkins-plugin/
https://www.jenkins.io/doc/book/pipeline/syntax/	- Pipeline Syntax



<a class="jsmfButton icon-download mfButton" href="/pmedia/ZGA/TX2070/11619801-000-01_11619801-01.pdf" target="_blank" id="mf110105491399905659455"><div class="mfButtonConWrpIcon icon-download"></div><div> Загрузить  </div></a>