Jenkinsfile (Declarative Pipeline)

[source:]
  1) "Jenkins User Handbook. Pipeline Syntax": https://www.jenkins.io/doc/book/pipeline/syntax/


Декларативный pipeline - это относительно недавнее дополнение к Jenkins Pipeline, которое представляет более упрощенный и
самодостаточный синтаксис поверх подсистем pipeline.

ОТЛИЧИЯ Declarative Pipeline от синтаксиса Groovy:

  • верхний уровень (Top-Level) Pipeline должен быть блоком, а именно: pipeline { };
  • точки с запятой НЕ ИСПОЛЬЗУЮТСЯ в качестве разделителей выражений,
    (!) каждое выражение должно быть на отдельной строке;

  • блоки должны состоять только из
      - разделов (Sections),
      - директив (Directives),
      - шагов (Steps)
      - или операторов присваивания.

  • выражение ссылки на свойство рассматривается как вызов метода без аргументов.
    Так, например, ввод обрабатывается как input(). 

# Можно использовать генератор декларативных директив (Declarative Directive Generator),
# чтобы начать настройку в Declarative Pipeline.

Преимущества декларативного конвейера:
	+ более структурированный - ближе к традиционным разделам веб-форм Jenkins;
	+ больше возможностей объявлять то, что необходимо, так что, возможно, более читабелен;
	+ может генерироваться через графический интерфейс Blue Ocean;
	+ содержит разделы, которые соответствуют знакомым концепциям Jenkins, таким как уведомления;
	+ лучшая проверка синтаксиса и идентификация ошибок;
	+ повышенная согласованность конвейеров.

Недостатки декларативного конвейера:
	- меньше поддержки интерактивной логики (меньше похоже на программу);
	- всё ещё развивается (может не поддерживать или иметь конструкции для вещей, которые вы бы делали в традиционном Jenkins);
	- более жёсткая структура (сложнее обрабатывать пользовательский код конвейера);
	- в настоящее время не подходит для более сложных конвейеров или рабочих процессов.

!!! В настоящее время существует нерешенная проблема, которая ОГРАНИЧИВАЕТ максимальный размер кода в блоке pipeline {}
	Это ограничение не распространяется на Scripted Pipeline 

# В синтаксисе Declarative Pipeline блок 
	pipeline {}
определяет всю работу, выполняемую во всем пайплайне. 

Структура Declarative Pipeline в общем виде:

---
pipeline {
    agent any 				# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stages {
        stage('Build') { 	# Определяет стадию "Build"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Build"
            }
        }
        stage('Test') { 	# Определяет стадию "Test"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Test"
            }
        }
        stage('Deploy') { 	# Определяет стадию "Deploy"
            steps {
                // 			# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
            }
        }
    }
}

____________________________________________
Разделы (Sections):
	Разделы в Declarative Pipeline обычно содержат одну или более директиву (Directives) или шаг (Steps)

• agent
	
	Раздел agent указывает:
		► где будет выполняться весь pipeline, если расположен на самом верхнем уровне; ОБЯЗАТЕЛЬНО ДОЛЖЕН БЫТЬ ЗАДАН
		► где будет выполняться определённый Stage, на уровне этапа (Stage)	-	НЕОБЯЗАТЕЛЬНО ЗАДАВАТЬ

	Различия между агентами высшего уровня (Top Level Agents) и агентами уровня этапа (Stage Agents)
	Top Level Agents:		
		параметры вызываются после входа в агент.
		Например, при использовании тайм-аута он будет применяться только к выполнению ВНУТРИ агента

##############################################

node("myAgent") {
	timeout(unit: 'SECONDS', time: 5) {
		stage("One"){
			sleep 10
			echo 'hello'
		}
	}
}

##############################################

	Stage Agents
	параметры вызываются ПЕРЕД ВХОДОМ В АГЕНТ и ПЕРЕД проверкой любых условий.
	В этом случае при использовании тайм-аута он применяется до выделения агента.
	
##############################################
		timeout(unit: 'SECONDS', time: 5) {
			stage("One"){
				node {
					sleep 10
					echo 'Hello'
				}
			}
		}

##############################################

  Этот тайм-аут будет включать время подготовки агента.
  Поскольку тайм-аут включает время подготовки агента,
  pipeline может дать сбой в тех случаях, когда выделение агента задерживается.
	
Параметры
	Для поддержки широкого спектра вариантов использования, которые могут быть у авторов Pipeline,
	раздел agent поддерживает несколько различных типов параметров.
	Эти параметры могут применяться
      -> на верхнем уровне блока pipeline
        или
      -> внутри директивы каждого stage(''){}. 

  • any
	  выполняет Pipeline или этап на любом доступном агенте 
---
pipeline {
    agent any
    ...
}
---

  • none
      при применении на верхнем уровне блока pipeline глобальный агент не будет выделен для всего запуска Pipeline;
      каждый раздел stage должен будет содержать СВОЙ СОБСТВЕННЫЙ РАЗДЕЛ agent
---
pipeline {
    agent none
    ...
}
---

  • label
      выполненяет pipeline или stage на агенте, доступном в окружении Jenkins с предоставленной меткой
---
pipeline {
    agent { label 'my-defined-label' }
    ...
}
---

  • node
      agent { node { label 'labelName' } } 
			ведёт себя так же, как и 
		agent { label 'labelName' },
	НО node позволяет использовать дополнительные параметры,
    такие как customWorkspace 
		
  • docker
      Выполняет pipeline или stage с заданным контейнером,
      который будет динамически подготовлен
      * на node, предварительно настроенном для приёма Pipelines на основе Docker
        <или>
      * на node, соответствующем параметру метки.

      Docker также опционально может принимать параметр args, содержащий аргументы для непосредственной передачи
      в вызов docker run, и параметр alwaysPull, который принудительно выполнит команду docker pull,
      даже если имя образа уже существует.
---
#Пример:
    agent { docker 'maven:3.8.1-adoptopenjdk-11' }
##или
			
    agent {
        docker {
            image 'maven:3.8.1-adoptopenjdk-11'
            label 'my-defined-label'
            args  '-v /tmp:/tmp'
        }
    }
	
# !!! Имя параметра и его значение, взятое в " " или ' ' внутри директивы docker разделяются ТОЛЬКО ПРОБЕЛОМ!

  docker также дополнительно принимает параметры:
    ♦ registryUrl,
    ♦ registryCredentialsId,
	которые помогут указать используемый репозиторий Docker и его учетные данные.
	Параметр registryCredentialsId можно использовать отдельно для частных репозиториев в Docker Hub.

[Например:]
---
agent {
    docker {
        image 'myregistry.com/node'
        label 'my-defined-label'
        registryUrl 'https://myregistry.com/'
        registryCredentialsId 'myPredefinedCredentialsInJenkins'
		}
    }
---

  • dockerfile
	  Выполняет pipeline или stage с помощью контейнера, который собран из Dockerfile, содержащегося в исходном репозитории.
		Чтобы использовать этот параметр:
			► файл Jenkinsfile должен быть загружен либо из многоветвевого Pipeline, либо из конвейера из SCM.
		Обычно это Dockerfile в корне исходного репозитория:
		
		agent { dockerfile true }

	[Параметры dockerfile:]
	  ♦ dir						- если Dockerfile содержится не в корневом, а в другом каталоге
	  ♦ filename					- если файл Dockerfile имеет другое имя
	  ♦ additionalBuildArgs		- если требуется передать дополнительные аргументы команде docker build …​
	  ♦ registryUrl				- если нужно указать используемый репозиторий Docker
	  ♦ registryCredentialsId		- если нужно указать учетные данные репозитория Docker

		Примеры:
			Если Dockerfile содержится не в корневом, а в другом каталоге:

			agent { dockerfile { dir 'someSubDir' } }

		Передаём дополнительные аргументы команде docker build …​ :
		
			agent { dockerfile { additionalBuildArgs '--build-arg foo=bar' } }.
		
		Пример репозитория с файлом build/Dockerfile.build, ожидающего версию аргумента сборки: 
		
			agent {
			// Equivalent to "docker build -f Dockerfile.build --build-arg version=1.0.2 ./build/
				dockerfile {
					filename 'Dockerfile.build'
					dir 'build'
					label 'my-defined-label'
					additionalBuildArgs  '--build-arg version=1.0.2'
					args '-v /tmp:/tmp'
				}
			}
	
		Указываем используемый реестр Docker и его учетные данные:
		
			agent {
				dockerfile {
					filename 'Dockerfile.build'
					dir 'build'
					label 'my-defined-label'
					registryUrl 'https://myregistry.com/'
					registryCredentialsId 'myPredefinedCredentialsInJenkins'
				}
			}


*******************
* Общие параметры *
*******************
	
Некоторые опции, которые можно применить к 2 или более agent.
Опции не являются обязательными, если иное не указано явно.

    ♦ label
        - тип данных: string
        - Метка или условие метки для запуска Pipeline или отдельного этапа (stage).
        - Опция label валидна для:>-
            node
            docker
            dockerfile

        - Опция label требуется для
            node

    ♦ customWorkspace
        - тип данных: string
        - Запускает Pipeline или отдельный этап (stage) к которому применяется этот agent,
		  в указанном настраиваемом workspace'е, а не по умолчанию.
        Указанный путь может быть:
          - относительным
            → в этом случае пользовательский workspace будет находиться в корневом каталоге рабочего пространства на узле;
          - абсолютным

##Пример:
```
agent {
    node {
        label 'my-defined-label'
        customWorkspace '/some/other/path'
    }
}
```

    ♦ reuseNode
        - тип данных: boolean
        - Значение по умолчанию: false
          Если значение true → Pipeline запускается
            на узле, указанном на верхнем уровне (Top Level) pipeline,
            в том же Workspace, а не на новом узле целиком.

        Опция reuseNode валидна для:
          - docker
          - dockerfile

		Опция reuseNode действует ТОЛЬКО В ТОМ СЛУЧАЕ, когда применена К ОТДЕЛЬНОМУ stage

    ♦ args
        - тип данных: string
        - Аргументы времени выполнения, используемые для передачи в команду docker run

        Опция args валидна для:
          - docker
          - dockerfile


##[Пример №1: Агент docker, синтаксис: Declarative Pipeline]

```
pipeline {
    agent { docker 'maven:3.8.1-adoptopenjdk-11' } 		# [1]
    stages {
        stage('Example Build') {
            steps {
                sh 'mvn -B clean verify'
            }
        }
    }
}
```
#[1]:= выполняет ВСЕ ШАГИ (steps), определённые в этом Pipeline во вновь созданном контейнере с заданным именем и тегом 3.8.1-adoptopenjdk-11


##[Пример №2: Pipeline с агентами уровня stage в разделах]

```
pipeline {
    agent none 												# [1]
    stages {
        stage('Example Build') {
            agent { docker 'maven:3.8.1-adoptopenjdk-11' } 	# [2]
            steps {
                echo 'Hello, Maven'
                sh 'mvn --version'
            }
        }
        stage('Example Test') {
            agent { docker 'openjdk:8-jre' } 				# [3]
            steps {
                echo 'Hello, JDK'
                sh 'java -version'
            }
        }
    }
}

```

#[1]:= Определение agent none на верхнем уровне Pipeline ГАРАНТИРУЕТ,
#    что исполнитель (Executor) не будет назначен без необходимости.
#    Использование `agent none` также делает НЕОБХОДИМЫМ ОПРЕДЕЛЕНИЕ собственного раздела agent В КАЖДОМ этапе (stage).

--->
(*) Executor (Исполнитель) - слот для выполнения работы, определенной Pipeline-ом или проектом на Node.
     На Node может быть настроено 0 или более исполнителей,
     что соответствует количеству одновременных проектов или pipeline-ов, которые могут выполняться на этом Node.
<---

[2]:= Выполнить шаги на данном этапе во вновь созданном контейнере, используя этот образ
[3]:= Выполнить шаги на данном этапе во вновь созданном контейнере, используя образ, отличный от предыдущего этапа





