Jenkinsfile. Scripted Pipeline
# [Сценарный конвейер]

  В синтаксисе Scripted Pipeline один или несколько узловых блоков (node {stage('nameOfStage1'){//}stage('nameOfStage2'){//}...})
  выполняют основную работу во всем пайплайне.
  Хотя это не является обязательным требованием синтаксиса Scripted Pipeline, ограничение работы вашего конвейера внутри блока узла делает две вещи:
    1. Планирует выполнение шагов, содержащихся в блоке, путем добавления элемента в очередь Jenkins. 
       Как только исполнитель освободится на узле, шаги будут запущены.
    2. Создает рабочую область (каталог, относящийся к конкретному конвейеру), где можно выполнять работу с файлами, извлеченными из системы управления версиями.
      (!) Предупреждение:
        В зависимости от конфигурации Jenkins некоторые рабочие области могут не очищаться автоматически после определенного периода бездействия.


[Преимущества сценарного конвейера:]
  + как правило, требуется меньше разделов и меньше спецификаций;
  + возможность использовать более процедурный код;
  + больше похож на создание программы;
  + традиционная модель конвейерного кода, более знакомая и обратно совместимая;
  + больше гибкости для выполнения пользовательских операций при необходимости;
  + возможность моделировать более сложные рабочие процессы и конвейеры


[Недостатки сценарного конвейера:]
	- в общем, требуется больше программирования;
	- проверка синтаксиса ограничена языком и средой Groovy;
	- далёк от традиционной модели Jenkins;
	- потенциально более сложный для того же рабочего процесса,
	  если это можно сделать аналогичным образом в декларативном конвейере.

node {  					# Исполнить этот Pipeline или любой из его этапов, на любом доступном агенте
    stage('Build') { 		# Определяет стадию "Build". Блоки stage являются необязательными в синтаксисе Scripted Pipeline. 
							# Однако реализация блоков этапов в Scripted Pipeline обеспечивает более четкую визуализацию подмножества
							# задач/шагов каждого этапа в пользовательском интерфейсе Jenkins.
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Build"
    }
    stage('Test') { 		# Определяет стадию "Test"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Test"
    }
    stage('Deploy') { 		# Определяет стадию "Deploy"
        // 					# Выполнить некоторые шаги, относящиеся к стадии "Deploy"
    }
}


Пример:

#!groovy
//Check ub1 properties
properties([disableConcurrentBuilds()])		# Запретить параллельную сборку несколькими пользователями

pipeline {
	agent {
		label 'main'		# указываем, что собираем в ветке main
	}
	options {
		buildDiscarder(logRotator(numToKeepStr: '2', artifactNumToKeepStr: '2'))
		timestamps()
	}
	stages {
		stage("Create docker image") {
			steps {
				echo " ========== start building image ========== "
				dir ('path/to/the/Dockerfile/in/repo') {
				sh 'docker build -t pipeline_tests . '
				}
			}
		}
	}
}


--<Jenkinsfile (Scripted Pipeline)>--

node {						# выделяет исполнителя и рабочее пространство для конвейера;
							# без узла Pipeline не может выполнять никакой работы
    checkout scm 			# scm — это специальная переменная, которая указывает шагу проверки клонировать конкретную ревизию, которая инициировала этот запуск Pipeline 
    /* .. snip .. */
}

//##//

################################

Step `script` берет блок Scripted Pipeline-а и выполняет его в декларативном конвейере.

В большинстве случаев step `script` не нужен в декларативных конвейерах, но он может предоставить полезный «аварийный выход».

(*) Вместо этого блоки сценариев нетривиального размера и/или сложности следует ПЕРЕМЕЩАТЬ В ОБЩИЕ БИБЛИОТЕКИ (Shared Libraries).

Scripted Pipeline, как и Declarative Pipeline, построен поверх базовой подсистемы Pipeline.

В отличие от Declarative, Scripted Pipeline фактически представляет собой DSL общего назначения [2], созданный с помощью Groovy.
Большая часть функций, предоставляемых языком Groovy, доступна пользователям Scripted Pipeline,
что означает, что он может быть очень выразительным и гибким инструментом,
с помощью которого можно создавать Continuous Delivery Pipeline.

Scripted Pipeline выполняется ПОСЛЕДОВАТЕЛЬНО, начиная с верхней части Jenkinsfile вниз,
как и большинство традиционных сценариев в Groovy или других языках.
Таким образом, обеспечение управления потоком основывается на выражениях Groovy, таких как условные операторы if/else, например: