Jenkins Clouds. Cloud Configurations

# для настроенного мной облака docker-agents
[Docker Cloud details]

  Docker Host URI
  (#from Docker Commons plugin: https://plugins.jenkins.io/docker-commons/)
    = URI используемого вами хоста Docker.
      Может быть оставлен пустым, чтобы использовать Docker по умолчанию
      (определяется переменной окружения DOCKER_HOST)
      (обычно unix:///var/run/docker.sock или tcp://127.0.0.1:2376).
    #{Значение:  unix:///var/run/docker.sock}

  Server credentials
    
    #{Значение:  -none-

  Расширенные (Advanced)

    Docker API Version
    (#from Docker plugin)
      = API apiVersion.
      Добавляет путь в формате "/v${VERSION}" к api url для коннектора,
      где ${VERSION} - вводимая строка.
      По умолчанию используется последняя версия apiVersion с сервера Docker.

    Connection Timeout
    (#from Docker plugin)
      = Таймаут в секундах для открытия соединения с Docker API.
      0 означает отсутствие ограничения по времени.
      #{Значение:  60}
  
    Read Timeout
    (#from Docker plugin)
      = Таймаут (в секундах), который следует применять при ожидании данных от Docker API.
        0
        = означает отсутствие ограничений по времени, но это не рекомендуется
          (если ваш docker API заблокируется, некоторые аспекты Jenkins также могут заблокироваться).

      ПРИМЕЧАНИЕ: Этот таймаут применяется НЕ КО ВСЕМ действиям docker API.
      Для Docker pull requests (которые могут занимать некоторое время) в шаблоне указывается собственное значение.
      Сборки образов Docker вообще не имеют таймаута
      (если вам нужен таймаут, используйте таймаут бездействия для сборки в целом).
      То есть, скорее всего, вам нужно установить это значение на несколько секунд,
      например, столько, сколько потребуется вашему сервису docker для ответа на запрос "container start".

    Docker Hostname or IP address
    (#from Docker plugin)
      = Имя хоста Docker (или IP), которое будет использоваться для доступа к вашему хосту Docker из внутренней или внешней сети.
      (!) Требуется при использовании сокетов с unix-доменом,
      в противном случае автоматически устанавливается в качестве части хоста в URL сервера.
      [Значение:] имя контейнера Jenkins || внешний IP

  ☑ Enabled
      = Если флажок не установлен, эта функция будет отключена.
        Это можно использовать, например, чтобы вывести облако или шаблон из работы для обслуживания и т. д.
      Примечание:
        При возникновении проблем эта функция может быть отключена автоматически.
        Если это произойдет, то это будет показано здесь.
        В этой ситуации отключенное состояние является преходящим и автоматически снимается по истечении указанного периода.

  Error Duration
  
    = Продолжительность (в секундах), в течение которой плагин будет ЗАПОМИНАТЬ ОШИБКИ, возникшие ПРИ ИНИЦИАЛИЗАЦИИ.
      Если при инициализации контейнера из шаблона Docker (Docker Template) произошла ошибка,
      => то этот шаблон будет игнорироваться в течение этого времени,
      что позволит Jenkins при последующих попытках инициализации использовать другие (надеюсь, рабочие) шаблоны
      (возможно, на других облаках, если они настроены).
      Если при взаимодействии с сервисом Docker возникнет ошибка, не связанная напрямую с конкретным шаблоном Docker
      (например, при запросе облака о количестве запущенных контейнеров),
      то на это время будет проигнорировано все облако,
      что фактически приведет К ОТКЛЮЧЕНИЮ ВСЕХ ШАБЛОНОВ В ЭТОМ ОБЛАКЕ на это время.

    Общее руководство:
      ● Высокие значения (например, минуты)
        ➜ хорошо работают, когда настроено несколько облаков/шаблонов
        (т. е. Jenkins не ограничивается только одним источником исполнителей сборок),
        позволяя другим облакам/шаблонам предоставлять средства для запуска сборок.

      ● Средние значения длительности (например, одна минута)
        ➜ хорошо работают в тех случаях, когда служба Docker обслуживает БОЛЕЕ ОДНОГО СЕРВЕРА Jenkins,
         так как это предотвратит "спам" Jenkins на общий ресурс Docker неудачными запросами.

      ● Низкая (или нулевая) продолжительность
        ➜ должна использоваться только в тех случаях, когда сервис Docker не является общим,
         не всегда надежен и когда нет альтернатив настроенным шаблонам Docker.
         т. е. когда Jenkins должен просто повторить попытку отказавших шаблонов, пока они не заработают.

      По умолчанию 300 (5 минут), если не задано (или задано неверное значение).
      Значение 0 отключает эту функциональность
      => (таким образом, недавние ошибки не будут учитываться при инициализации).


  [] Expose DOCKER_HOST
  (#from Docker plugin)
       = Раскрыть URL-адрес хоста docker как переменную окружения DOCKER_HOST внутри контейнера.
       Это предполагает, что IP/имя хоста docker видно из контейнера и не требует аутентификации,
       или что адекватные TLS-ключи вводятся внутрь контейнера другим механизмом.

  Container Cap
  (#from Docker plugin)
    = Максимальное количество контейнеров, которые этот провайдер может запустить в целом
    (значение не зависит от  template/image).
    (!ОБРАТИТЕ ВНИМАНИЕ!)
      контейнеры, которые не были созданы Jenkins, НЕ ВКЛЮЧАЮТСЯ в это общее количество.

    - отрицательное значение, |
    - или ноль,               |=> "нет ограничений" для провайдера в целом,
    - или 2147483647          |   # хотя ограничения для КАЖДОГО ЭКЗЕМПЛЯРА шаблона (если таковые имеются) будут по-прежнему применяться.

    По умолчанию равно 100.


##########################
# Docker Agent templates #
##########################

  Labels
    = Метки для присвоения этим нодам (для ограничения ваших сборок)
    #{Значение: agent-deb-std remote remote-agent }

  ☑ Enabled
       = Если флажок не установлен, эта функция будет отключена.
       Это можно использовать, например, чтобы вывести облако или шаблон из работы для обслуживания и т.д.
       Примечание: При возникновении проблем эта функция может быть отключена автоматически.
       Если это произойдет, то это будет показано здесь.
       В этой ситуации отключенное состояние является преходящим и автоматически снимается по истечении указанного периода.

  Name
    = Префикс имени, который будет использоваться для всех узлов Jenkins, созданных по этому шаблону.
      Jenkins добавит уникальный ID к этому имени, чтобы создать индивидуальные имена узлов.
      (!) Если имя пустое или просто пробел, по умолчанию будет использоваться "docker".
    #{Значение: agent-deb-jdk17 }

  Docker Image
    = Хеш или тегированное имя образа, который вы хотите, чтобы docker запустил
      (например, "docker run -i -t <id> /bin/bash").
    #{Значение: jenkins/agent:bookworm-jdk17}

--->
  [Registry Authentication:]
  
  Credentials
    = 
    #{Значение: -none-}
    [+ Add ]
<---

--->
  [Container settings:]
  
  Docker Command
    = Указывает команду, которая будет выполняться при запуске контейнера.
      (!ОБРАТИТЕ ВНИМАНИЕ!)
        этот параметр МОЖЕТ ПОВЛИЯТЬ НА МЕХАНИЗМ ЗАПУСКА,
        (например:
          SSH Launcher настраивает sshd с аутентификацией по введенным ключам,
          переопределение этой команды может помешать запуску агента!
        )
      Пожалуйста, обратитесь к документации по docker для получения более подробной информации.
      (https://docs.docker.com/engine/reference/run/#cmd-default-command-or-options)
      Введенная команда должна поддерживать контейнер в рабочем состоянии,
      чтобы Jenkins мог установить удаленное соединение в любое время.

      Если команда не задана, Jenkins сконфигурирует команду общего назначения, которая будет просто ждать stdin.

      Если вам нужно, чтобы образ запускал дополнительные сервисы,
      следует использовать точку входа (ENTRYPOINT) и следовать лучшим практикам:
      (https://docs.docker.com/build/building/best-practices/#entrypoint)
      чтобы команда в конечном итоге выполнялась скриптом точки входа.

  Hostname

  User
    = Запуск контейнера с указанным пользователем (например, "docker run --user ...").
      Обратитесь к справочнику по командам docker run, чтобы узнать правильный синтаксис.
      (https://docs.docker.com/engine/reference/run/#user)
    ************************************************************************************************
    *                                   (!ОБРАТИТЕ ВНИМАНИЕ!)                                      * 
    *   необходимо указать числовой UID, если вы хотите запустить контейнер от имени пользователя, *
    *   который существует на хост-машине, но не существует внутри контейнера.                     *
    ************************************************************************************************
    #{аналог $ docker run -u (||--user) <username>}
    # --user=[ user | user:group | uid | uid:gid | user:gid | uid:group ]
  
  Extra Groups
    = Запустите контейнер с указанными дополнительными группами
      (например, "docker run --group-add ...").
      Обратитесь к справочнику по командам docker run, чтобы узнать правильный синтаксис:
      (https://docs.docker.com/engine/reference/run/#additional-groups)

  
  DNS
    = Установите DNS-серверы для использования в образах;
      если они не заданы, Docker будет использовать DNS-настройки хоста.

  Network
  
  Mounts
    = Новый список монтирования хостов, разделенный строками :
      type=volume|bind|tmpfs|npipe
      [,src|source=<some source>],
      dst|destination|target=<some target>
      [,<key>=<value>]*
      См. официальную документацию:
      (https://docs.docker.com/reference/cli/docker/service/create/#mount)
  
  Volumes From
    = Новый список томов, разделенных строками, который нужно унаследовать от другого контейнера.
      Указывается в виде:  <имя контейнера>[:<ro|rw>]
      Если режим доступа не указан, то по умолчанию будет использоваться rw.
      См. официальную документацию:
      (https://docs.docker.com/reference/cli/docker/container/run/#volumes-from)

  Devices
    = Новый список устройств для сопоставления (например: /dev/fuse), разделенный строками.
      Полная схема - origin:destination:permissions, хотя достаточно указать только origin.
      Документация по Docker:
      (https://docs.docker.com/reference/cli/docker/container/run/#device)

  Environment
    = Ноль или более переменных окружения, которые устанавливаются в контейнере docker.
    Это многострочное текстовое поле.
    Каждая строка:
      * должна иметь вид key=value
      * и указывать одно имя переменной и ее значение.
    Обратите внимание, что КАВЫЧКИ НЕ ИНТЕРПРЕТИРУЮТСЯ.
    (Например:
  ---<Example>---
  foo="bar"
  # приведет к тому, что кавычки станут частью значения foo
  ---
    (!ОБРАТИТЕ ВНИМАНИЕ!)
      пробельные символы легко нарушаются.
      Редактирование этого поля без предварительного расширения поля до многострочной формы приведет к тому,
      что любые пробельные символы в строке будут превращены в коды конца строки,
      разрывая строку и тем самым изменяя ее смысл.
    (Например:
      Одиночная настройка:
  ---
    JENKINS_AGENT_SSH_PUBKEY=ssh-rsa MyPubKey jenkins@hostname
    # может (случайно) превратиться в три отдельные настройки:
    JENKINS_AGENT_SSH_PUBKEY=ssh-rsa
    MyPubKey
    jenkins@hostname
    # тем самым не позволяя конфигурации работать так, как было задумано.
  ---


  Port bindings
    = Связывает порты внутри контейнера с внешними портами хоста,
      схема - hostport:containerport.
      Действует так же, как опция "-p" или "-P" в CLI.
      Документация по Docker: https://docs.docker.com/reference/run/#expose-incoming-ports

  ☑ Bind all declared ports


  Memory Limit in MB
    = Оператор может ограничить объем памяти, доступный контейнеру.
      Если хост поддерживает память подкачки (swap memory),
      то значение может быть больше, чем физическая оперативная память.
      Когда процессы внутри контейнера превышают лимит памяти, последствия зависят от вашей установки,
      например:
        > могут возникнуть ошибки, связанные с нехваткой памяти,
        > или операционная система может начать убивать процессы.
      #(Аналог опции -m ||--memory)  
      (https://docs.docker.com/engine/reference/run/#runtime-constraints-on-resources)
      (!ОБРАТИТЕ ВНИМАНИЕ!)
        в большинстве установок Docker ограничение памяти НЕ ПОМЕШАЕТ Jenkins/Docker породить такое количество контейнеров,
        что ОБЩАЯ ДОСТУПНАЯ ПАМЯТЬ машины будет ПРЕВЫШЕНА.
        Однако некоторые установки Docker могут автоматически ограничивать количество контейнеров с помощью лимита памяти.
    #{Значение: 1024}

  Swap Memory Limit in MB
    = Оператор может ограничить объем памяти подкачки (swap memory), доступной контейнеру.
      Это значение представляет собой ОБЩУЮ ПАМЯТЬ, доступную контейнеру (своп + память).
      Чтобы ОТКЛЮЧИТЬ ОГРАНИЧЕНИЕ свопа, можно установить значение "-1".
    #{Значение: 1024}
  
  CGroup Parent
    = Это позволяет агентам работать в группе cgroup, отличной от группы daemon/system по умолчанию.
    Доп. информация:
    "Specify custom cgroups": https://docs.docker.com/reference/cli/docker/container/run/#cgroup-parent
  
  CPU resources
    = Укажите, сколько ресурсов ЦП может использовать контейнер,
      в виде числа с плавающей точкой.
      #(Аналог опции --cpus=)
      По умолчанию не задано.
    #(https://docs.docker.com/engine/reference/run/#cpu-period-constraint)

# Чтобы понять, как правильно работать со следующими параметрами, ознакомиться со статьёй:
# "CFS Bandwidth Control"
#(https://www.kernel.org/doc/Documentation/scheduler/sched-bwc.txt)
  CPU Period in us
  (! Not a positive integer)
    = Установите период CPU для ограничения использования процессора контейнером.
      Период CPU CFS (Completely Fair Scheduler) по умолчанию составляет 100000us.
      #(Аналог опции --cpu-period=)
      Для получения дополнительной информации:
      https://docs.docker.com/engine/reference/run/#cpu-period-constraint
  
  CPU Quota in us
  (! Not a positive integer)
    = Ограничивает использование контейнером процессора.
      Значение по умолчанию 0 позволяет контейнеру занимать 100% ресурса процессора.

  
  CPU Shares
    = Аналогичным образом оператор может повысить приоритет этого контейнера.
      По умолчанию (без значения) все контейнеры
        ✓ работают с одинаковым приоритетом
          и
        ✓ получают одинаковую долю циклов ЦП
      НО вы можете указать ядру выделить БОЛЬШЕ ДОЛЕЙ ПРОЦЕССОРНОГО ВРЕМЕНИ одному или нескольким контейнерам при их запуске через Docker.

  Shared Memory Size in MB
    = Размер /dev/shm в МБ. Если не указывать размер полностью (или использовать значение 0),
      система будет использовать 64 МБ.
    https://docs.docker.com/reference/run/
    #(Аналог $ docker run --shm-size="")

  [] Run container privileged
  (!)at your own risk


  Security Options
    = Список опций безопасности, разделенных новыми строками.
      Каждая строка представляет собой опцию для параметра --security-opt, отправляемого на сервер docker.
      Опции имеют формат ключ=значение.
  #("Docker Security": https://docs.docker.com/engine/security/)


  Capabilities to add
    = Список новых возможностей, разделенных строками.
      Каждая строка представляет собой опцию для параметра --cap-add, отправляемого на сервер docker.
      Каждая из них должна быть известной возможностью "Key" в соответствии с документацией docker.
    #(https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)


  Capabilities to drop
    = Список новых возможностей, разделенных строками.
      Каждая строка представляет собой опцию для параметра --cap-drop, отправляемого на сервер docker.
      Каждая из них должна быть известной возможностью "Key" в соответствии с документацией docker.
    #(https://docs.docker.com/engine/reference/run/#runtime-privilege-and-linux-capabilities)

  [] Allocate a pseudo-TTY
  
  MAC-address
    = MAC-адрес контейнера (например, 92:d0:c6:0a:29:33)

  Extra Hosts
    = Список новых сопоставлений имен хостов/IP, разделенных строками,
      которые будут добавлены в файл /etc/hosts контейнера.
      Задается в форме "имя хоста:IP".
  
  Extra Docker Labels
    = Список новых меток docker, разделенных строками, которые нужно установить для контейнера,
      заданный в форме "label_name=value".
      (!) Это НЕ ВЛИЯЕТ на функциональность Jenkins
          и не связано с метками, используемыми Jenkins для сопоставления заданий с узлами агента.
      Эти метки представляют собой метаданные, прикрепленные к самому контейнеру docker
      (опять же, не к агенту jenkins), которые обычно можно прочитать с помощью команды docker inspect.
      Это может быть полезно при использовании кластера docker (например, docker swarm)
      для передачи информации планировщику в сочетании с ограничениями;
      или чтобы другие службы (portainer, prometheus...) знали,
      как они должны классифицировать или иначе обращаться с этим конкретным контейнером.
    Примечания:
      * пробелы в начале и конце имени и значения метки БУДУТ УДАЛЕНЫ,
      * недействительные строки будут игнорироваться.
    
<---

  Instance Capacity
    = Максимальное количество контейнеров на основе данного шаблона, которое может запустить данный провайдер в целом.
      - отрицательное значение, |
      - ноль                    |=> на этот шаблон не накладывается ограничение,
      - или 2147483647          |   # хотя общее ограничение на количество облачных экземпляров (если оно есть) все равно будет действовать.

      (!ОБРАТИТЕ ВНИМАНИЕ!)
        контейнеры, которые НЕ БЫЛИ СОЗДАНЫ Jenkins, НЕ ВКЛЮЧАЮТСЯ в это общее количество.

      В качестве альтернативы некоторые установки Docker могут автоматически определять максимальное количество контейнеров,
      используя ограничения по памяти/процессору.

  Remote File System Root
    = Корневой каталог в вашем образе для пользователя Jenkins
    #(например, /home/jenkins/agent)
  
  Использование (Usage)
    = Контролирует планирование сборок на сервере.
      * Загружать этот узел настолько, насколько возможно
          = Это обычное поведение по умолчанию.
            В этом режиме Jenkins свободно распоряжается ресурсами узла.
            Как только возникает необходимость в сборке,
            которая может быть выполнена этим узлом, Jenkins его использует.

      * Собирать только проекты с метками, совпадающими с этим узлом
          = В этом режиме Jenkins будет выполнять на этом узле сборки тех проектов,
            которые ограничены для определённых узлов с помощью выражения метки,
            и имя и/или метки узла совпадают с этим выражением.
            Это позволяет узлу быть зарезервированным для определенных групп проектов.
            (Например:
              если у вас есть проекты, выполняющие тесты производительности, используя Jenkins,
              вам может понадобиться:
                ✓ запускать их на специально настроенной для этого машине,
                ✓ не давать другим проектам использовать эту машину.
              Для этого вы можете ограничить, где могут запускаться проекты с тестами,
              назначив им метку, совпадающую с этой машиной.
            )
            [+] если вы установите количество исполнителей = 1,
                вы можете гарантировать, что ТОЛЬКО ОДИН ПРОЦЕСС теста производительности будет запускаться на этой машине в каждый момент времени,
                и никакая другая сборка ему не помешает.

  Idle timeout
    = Количество минут простоя, после которого следует убить агента;
      служит резервным вариантом на случай, если стратегия не сможет определить окончание задания

******************
* Connect method *
******************
---
    = Для всех методов подключения Jenkins начнет с запуска docker run.
      Затем, после этого шага (по желанию) будут выполнены дополнительные шаги ДЛЯ УСТАНОВЛЕНИЯ СОЕДИНЕНИЯ.
      В настоящее время существует 3 альтернативных способа подключения Jenkins master (Controller)
      к ДИНАМИЧЕСКИ создаваемым агентам Docker.
      У каждого способа подключения есть свои плюсы и минусы.
      В зависимости от вашего окружения, выбирайте тот, который соответствует вашим потребностям.
      Более подробные предварительные условия будут предоставлены после того, как вы выберете тот или иной способ.

[Attach Docker container]
(Подключить контейнер Docker)
  Этот метод:
    1) запускает контейнер,
    2) затем подключается к нему с помощью docker exec, используя API Docker.
  Агенту не нужно иметь возможность связаться с мастером через сетевые уровни для взаимодействия;
  все будет происходить через Docker API.

  Prerequisites:
    ● В образе Docker должна быть установлена Java*.
      #(*)https://go.java/
    ● CMD образа Docker должен быть либо пустым, либо просто ождать вечно,
       например. /bin/bash.
    #=> Код удаленного агента Jenkins (remote agent) будет скопирован в контейнер,
        а затем запущен с помощью Java, установленной в контейнере.

    (В качестве примера можно рассмотреть:
        -> контейнер, запущенный из образа jenkins/agent (https://hub.docker.com/r/jenkins/agent)
        -> источник jenkinsci/docker-agent (https://github.com/jenkinsci/docker-agent)
    )

---{Form:
  User:
    = Пользователь, от имени которого будет запущен код агента Jenkins.
      Если оставить это значение пустым, будет использоваться пользователь по умолчанию контейнера
      (пользователь, определённый директивой USER в Dockerfile)
      (обычно "root").

  Java Executable:
    = Команда java, которая должна быть выполнена на контейнере для запуска кода удаленного агента.
      Если это не абсолютное имя пути, то исполняемый файл должен быть в PATH контейнера.
      По умолчанию PATH = "java", если не задано.

    ПРИМЕЧАНИЕ:
      Это устанавливает значение переменной JAVA_EXE в команде точки входа.
      Если вы переопределите команду точки входа (entry point),
      но НЕ БУДЕТЕ ИСПОЛЬЗОВАТЬ эту переменную,
      (!) то этот параметр НЕ БУДЕТ ИМЕТЬ НИКАКОГО ЭФФЕКТА.

  JVM Argumments:
    = Любые аргументы, передаваемые исполняемому модулю JVM.
      По умолчанию принимает значение "", если не задано.

    ПРИМЕЧАНИЕ:
      Это устанавливает значение переменной JVM_ARGS в команде точки входа.
      Если вы переопределите команду точки входа, но не будете использовать эту переменную,
      то этот параметр не будет иметь никакого эффекта.

  EntryPoint Cmd:
    = Устанавливает команду, передаваемую docker exec при запуске кода удаленного агента на контейнере.

    ПРИМЕЧАНИЕ:
      Это поле представляет собой многострочную строку.
      Каждая (непустая) строка определяет ОТДЕЛЬНЫЙ аргумент.
      Если вам требуется более одного аргумента
      (например, копирование одного из примеров ниже),
      то вам нужно будет расширить поле, иначе вместо нескольких строк получится одна длинная.
      Ограниченная подстановка переменных (с использованием синтаксиса ${VARIABLE_NAME}) выполняется для настроенных строк перед запуском контейнера.
      В дополнение к любым глобально настроенным переменным окружения здесь можно использовать следующие переменные:
      Если это поле оставлено пустым, то по умолчанию используются аргументы,
      подходящие для стандартного образа Jenkins Agent Docker, jenkins/agent, а именно:
---<Аргументы>---
${JAVA_EXE}
${JVM_ARGS}
-jar
${FS_DIR}/${JAR_NAME}
-noReconnect
-noKeepAlive
-agentLog
${FS_DIR}/agent.log
---
}---


[Connect with JNLP>]
(Подключение с помощью JNLP)
  Контейнеру будет передана только начальная команда docker run с правильным секретом.
  А агент удаленного доступа будет устанавливать соединение с мастером через сеть.
  Следовательно, агент должен иметь возможность доступа к мастеру через его адрес и порт.

Prerequisites:
  ● Master Jenkins должен быть доступен по сети из контейнера.
  ● В докер-образе должна быть установлена Java.
  ● Образ Docker должен запускать agent.jar самостоятельно или с помощью аргументов EntryPoint,
  приведенных ниже:

---{Form:
  User:
    = Пользователь, от имени которого будет запущен процесс агента jenkins.
      Если он не указан, то это пользователь по умолчанию (обычно "root").

  Jenkins URL:
    = При необходимости URL Jenkins может быть перезаписан с помощью этого свойства
      (например, для поддержки других конечных точек HTTP(S) из-за обратных прокси-серверов или брандмауэров).
      По умолчанию используется URL из глобальной конфигурации Jenkins.

  EntryPoint Argumments:
    = Аргументы, передаваемые точке входа контейнера.

    ПРИМЕЧАНИЕ:
      = Это поле представляет собой многострочную строку.
        Каждая (непустая) строка определяет отдельный аргумент.
        Если вам требуется более одного аргумента
        (например, копирование одного из примеров ниже),
        то вам нужно расширить поле, иначе в итоге вы получите одну длинную строку вместо нескольких строк.
        Ограниченная подстановка переменных (с использованием синтаксиса ${VARIABLE_NAME})
        выполняется для настроенных строк перед запуском контейнера.
        Помимо глобально настроенных переменных окружения, здесь можно использовать следующие переменные:
        Например, если вы используете пользовательский контейнер, в котором установлены java и wget, но нет предустановленного agent.jar,
        то вместо этого можно использовать следующее:
---
  sh
  -c
  wget ${JENKINS_URL}jnlpJars/agent.jar && java -jar agent.jar -url ${JENKINS_URL} -secret ${JNLP_SECRET} -name ${NODE_NAME}
---
Если это поле оставить пустым, то по умолчанию будут использоваться аргументы, подходящие для стандартного образа Jenkins JNLP Agent Docker, jenkins/inbound-agent, а именно:
---
-url
${JENKINS_URL}
${JNLP_SECRET}
${NODE_NAME}
---
}---



[Connect with SSH]
(Подключение с помощью SSH)
  Предполагается, что НА УКАЗАННОМ ОБРАЗЕ будет запущен SSH-СЕРВЕР.
  Тогда он будет обращаться с этим компьютером так, как это обычно происходит с любым агентом, подключенным по SSH:
    1) master подключится к ssh-agent'у,
    2) скопирует агент удаленного доступа,
    3) а затем запустит его.

Prerequisites:
  ● Порт SSH докер-контейнера (обычно порт на хосте докера) должен быть доступен по сети для master'а.
  ● В docker-образе должен быть установлен sshd.
  ● В docker-образе должна быть установлена Java.
  ● Данные для входа в систему настроены в соответствии с плагином ssh-slaves (SSH Build Agents);
    #(см. [Plugins]_SSH-Build-Agents_(ssh-slaves).txt)

---{Form:
  SSH key:
    = Определите, как настраивается пара ключей SSH для аутентификации ssh в контейнере.

    1) Inject SSH key
       -> Выделенный SSH-ключ (основанный на уникальном идентификаторе мастера Jenkins) будет введен в контейнер,
          а sshd настроен соответствующим образом.
       ПРИМЕЧАНИЕ: Если вы
         ● используете нестандартный sshd
         ● или задаете пользовательскую команду контейнера,
       => это может не сработать.
          User:
            - Введенный SSH-ключ позволит агенту запускаться в контейнере от имени root.
              Если вы хотите использовать другого пользователя, укажите его имя здесь.
              Обратите внимание, что такой пользователь должен УЖЕ СУЩЕСТВОВАТЬ В ОБРАЗЕ контейнера.
            (default: root)
    2) Use configured SSH credentials:
         ● SSH Credentials:
           # Выбрать установленные credentials
           [+ Add]

         ● Host Key Verification Strategy:
           - Known hosts file Verification Strategy
           - Manually provided key Verification Strategy
             (поле ввода SSH Key)
           - Manually trusted key Verification Strategy
             # [] Require manual verification of initial connection
               = Требуется, чтобы пользователь с правами Computer.CONFIGURE авторизировал ключ,
                 представленный при первом подключении к этому хосту, прежде чем соединение будет разрешено.
                 Если эта опция не включена, то ключ, представленный при первом подключении к этому хосту,
                 будет автоматически доверен и разрешен для всех последующих подключений без какого-либо ручного вмешательства.
                 (from SSH Build Agents plugin)
           - Non verifying Verification Strategy
             Расширенные:
               * Port
               * JavaPath
               * JVM Options
               * Prefix Start Slave Command
               * Suffix Start Slave Command
               * Connection Timeout in Seconds
               * Maximum Number of Retries
               * Seconds To Wait Between Retries

}---


  Stop timeout
    = Таймаут (в секундах), применяемый при остановке контейнера после завершения задания.
      Значение по умолчанию, равное 10 с, подходит для большинства случаев.
      Однако если контейнеру необходимо произвести очистку после остановки агента, вы можете увеличить таймаут.
      Если контейнеру не удастся изящно (gracefully) остановиться до истечения тайм-аута,
      он будет уничтожен.

  [] Remove volumes
    = Удалите тома, связанные с контейнером, во время удаления контейнера.

  Pull strategy
    = Стратегия Pull во время инициализации перед запуском образа.
      * Never pull
      * Pull all images every time
      * Pull once and update latest

  Pull timeout
    = Таймаут (в секундах), который должен применяться при ожидании данных от Docker API при выполнении операции docker pull.
      0 = отсутствие ограничений по времени, но это НЕ РЕКОМЕНДУЕТСЯ
          (если ваш docker API заблокируется, некоторые аспекты Jenkins также могут заблокироваться).
          т. е. вы, вероятно, захотите установить это значение на время,
          необходимое для извлечения всего образа на свежий docker-сервер.
          например, на несколько минут.
      Примечание:
        Это ОТМЕНЯЕТ таймаут чтения, указанный для облака,
        НО ТОЛЬКО для операции docker pull
        (поскольку ожидается, что эта операция займет больше времени, чем большинство операций docker).
    (default: 300)

  Node Properties:
    * Disable deferred wipeout on this node
      (Отключить отложенное уничтожение на этом узле)
        = Во время очистки рабочего пространства отключите улучшенный метод отложенного стирания.
          По умолчанию отложенное удаление используется по желанию.

    * Disk Space Monitoring Thresholds
      (Пороги мониторинга дискового пространства)

    * Keep Swarm client node after agent disconnect
      (Сохранение узла клиента Swarm после отключения агента)

    * Переменные среды
    * Расположения инструментов