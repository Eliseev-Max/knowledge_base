[sources:]
CloudBeesTV.
"How to Create an Agent Node in Jenkins": https://youtu.be/99DddJiH7lM

Если директория, указанная в Remote root directory, не существует на агенте, она будет создана.

Таким образом, все, что связано с агентом с точки зрения программного обеспечения, устанавливается в каталог агента.

Методы запуска (по умолчанию):
  * Launch agent by connecting it to the master
  * Launch agent via execution of command on the controller
  * Launch agents via SSH
      = контроллер инициирует соединение с агентом.

Launch agent by connecting it to the master:
  = встречается часто, особенно когда мы подключаем агенты Windows, у которых нет доступного SSH.
  При таком методе (агент запускается, подключаясь к контроллеру) 
  сначала запускается процесс агента,
  а затем агент подключается обратно к контроллеру.
  Таким образом, это поток: "агент -> контроллер" для установления первоначального соединения.

Host Key Verification Strategy: Non verifying Verification Strategy

Дополнительные настройки, такие как:
  * JavaPath,
  * JVM Options,
  * Prefix Start Agent Command,
  * Suffix Start Agent Command,
  * Connection Timeout in Seconds
  нужны для соединения непосредственно контроллера с агентом,
  это ЕДИНСТВЕННОЕ, на что влияют эти настройки!
  Они не влияют непосредственно на работу контроллера

На контроллере и агенте устанровлен openjdk одной версии.
Это предотвращает возможность неполадок по причинам несовместимости JDK
Это JDK, с помощью которого был запущен процесс jenkins на контроллере.
На контроллере и агенте установлены JAVA_HOME и установлен путь к $JAVA_HOME/bin

Анализ логов агента при подключении по SSH
[SSH] WARNING: SSH Host Key are not being verified. Man-in-the-middle attacks may be possible against this connection.
[SSH] Authentication successful
(в логах соединения с агентом выводятся все переменные окружения, такие как
OSTYPE, PATH (содержит пути до исполняемых файлов Maven, openjdk (bin), Gradle)
и др.).


Позаботимся о безопасности соединения: Jenkins Controller <--> ssh-agent
( = избавимся от предупрежждения WARNING:...)

Настроим стратегию верификации ключей SSH, основанную на проверке файла known_hosts:

  1. Выбираем в меню настройки агента Jenkins:
     Host Key Verification Strategy = Known hosts file Verification Strategy
  2. Выбираем заранее созданные для агента Credentials из выпадающего списка
  3. Отключаемся от SSH-агента (disconnect) и подключаемся повторно (reconnect) => Launch agent
     чтобы инициировать known-host верификацию.
  # Происходит попытка открытия SSH-соединения контроллера с агентом по заданному порту.
  # Происходит поиск файла ${JENKINS_HOME}/.ssh/known_hosts
  # Файл с таким именем не обнаружен.
  # Происходит попытка повторного подключения (в рамках заданного количества попыток).

  4. На контроллере Jenkins переходим в директорию ${JENKINS_HOME}
  ## (/var/lib/jenkins = on host || /var/jenkins_home = into the docker container)
    и создаём директорию .ssh (под пользователем jenkins - предпочтительно. Можно также под root)

  5. Запускаем команду:
---
$ ssh-keyscan -H agent1 >> /var/lib/jenkins/.ssh/known_hosts
# agent1 = hostname of the jenkins agent
# проверим содержимое файла known_hosts
$ cat .ssh/known_hosts
# видим запись
  6. Проконтролировать, что UID:GID директории .ssh = jenkins:jenkins


---{ssh-keyscan}---
  = собирает публичные ключи SSH

[Синтаксис:]

ssh-keyscan [-46Hv] [-f file] [-p port] [-T timeout] [-t type] [host | addrlist namelist] ...

[Описание:]
ssh-keyscan - это утилита для сбора открытых ключей ssh-хостов нескольких хостов.
(!) Она была разработана для помощи в создании и проверке файлов ssh_known_hosts.

ssh-keyscan предоставляет минимальный интерфейс, пригодный для использования сценариями shell и perl.
Утилита ssh-keyscan использует НЕБЛОКИРУЮЩИЙ СОКЕТНЫЙ ВВОД-ВЫВОД для параллельного обращения к максимальному количеству хостов,
поэтому она очень эффективна.

(!) Ключи от домена из 1 000 хостов могут быть собраны за десятки секунд,
    даже если некоторые из них не работают или не используют ssh.

Для сканирования не нужен доступ к сканируемым машинам, а сам процесс сканирования не требует шифрования.

[Опции:]

  -f <file>
    = Чтение пар именных списков hosts или addrlist из этого файла, по одной в строке.
      Если вместо имени файла указано `-` , ssh-keyscan будет читать hosts или пары addrlist namelist из стандартного ввода.

  -H
    = Хеширование всех имен хостов и адресов в выходных данных.
      Хешированные имена могут нормально использоваться ssh и sshd,
      но они не раскрывают идентификационную информацию, если содержимое файла будет раскрыто.

  -p <port>
    = Порт для подключения к удаленному хосту

  -T <timeout>
    = Устанавливает таймаут для попыток подключения.
      Если с момента установления соединения с хостом или с момента последнего считывания информации с этого хоста прошло несколько секунд,
      соединение закрывается, а хост считается недоступным.
      По умолчанию - 5 секунд.

  -t <type>
    = Указывает тип ключа, который нужно получить от сканируемых узлов.
      Возможные значения:
        * ''rsa1'' для протокола версии 1
        * ''rsa'' или ''dsa'' для протокола версии 2.
      Можно указать несколько значений, разделив их запятыми.
      По умолчанию используется значение ''rsa''.

[Безопасность:]

  Если файл ssh_known_hosts создается с помощью ssh-keyscan без проверки ключей,
  пользователи будут уязвимы для атак типа "человек посередине" (MITM).

  С другой стороны, если модель безопасности допускает такой риск,
  ssh-keyscan может помочь в обнаружении ПОДДЕЛЬНЫХ ФАЙЛОВ КЛЮЧЕЙ или атак MITM,
  которые начались после создания файла ssh_known_hosts.
