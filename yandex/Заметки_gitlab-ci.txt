#. gitlab-ci.yml

Разделение backend и frontend сборок:

stages:
  - triggers
 
trigger_backend:
  stage: triggers
  trigger:
    include: backend/.gitlab-ci.yml
  rules:
    - changes:
        - backend/*
 
trigger_frontend:
  stage: triggers
  trigger:
    include: frontend/.gitlab-ci.yml
  rules:
    - changes:
        - frontend/*
		

dependencies
  Используйте ключевое слово dependencies, чтобы определить список заданий, из которых будут браться артефакты.
  Вы также можете задать задание, которое вообще не будет загружать артефакты.

  Если вы не используете зависимости, все артефакты с предыдущих этапов передаются каждому заданию.
  Возможные входы:
    • имена заданий, из которых нужно получить артефакты.
    • пустой массив ([]), чтобы настроить задание на отсутствие загрузки артефактов.


cache
{"Caching in GitLab CI/CD":
  https://docs.gitlab.com/ee/ci/caching/#availability-of-the-cache}
  
После определения кэша в файле .gitlab-ci.yml доступность кэша зависит от:
    Типа исполнителя runner.
    Используются ли разные исполнители для передачи кэша между заданиями.

Где хранятся кэши

	Все кэши, определенные для задания, архивируются в одном файле cache.zip.
	Конфигурация ранера (runner) определяет, где хранится этот файл.
	По умолчанию кэш хранится на машине, где установлен GitLab Runner.
	Расположение также зависит от типа исполнителя.

‼ Если вы используете кэш и артефакты для хранения одного и того же пути в заданиях,
кэш может быть перезаписан, поскольку кэш восстанавливается раньше артефактов.

Имена ключей кэша
	К ключу кэша добавляется суффикс, за исключением ключа резервного кэша.
	В качестве примера предположим, что cache.key установлен в $CI_COMMIT_REF_SLUG, и что у нас есть две ветви main и feature, тогда в следующей таблице представлены результирующие ключи кэша:
	Branch name						Cache key
	main							main-protected
	feature							feature-non-protected
	
	Разделение кэша с помощью имен ключей кэша является функцией безопасности

Использовать один и тот же кэш для всех ветвей
	Если вы не хотите использовать имена ключей кэша, вы можете заставить все ветви (защищенные и незащищенные) использовать один и тот же кэш.
	Разделение кэша с помощью имен ключей кэша является функцией безопасности и должно быть отключено только в среде,
	где все пользователи с ролью Developer имеют высокий уровень доверия.

  Чтобы использовать один и тот же кэш для всех веток:
    1. На верхней панели выберите Главное меню > Проекты и найдите свой проект.
    2. На левой боковой панели выберите Настройки > CI/CD.
    3. Разверните Общие конвейеры.
    4. Снимите флажок Использовать отдельные кэши для защищенных ветвей.
    5. Выберите Сохранить изменения

Как работает архивирование и извлечение

# .gitlab-ci.yml example

stages:
  - build
  - test

before_script:
  - echo "Hello"

job A:
  stage: build
  script:
    - mkdir vendor/
    - echo "build" > vendor/hello.txt
  cache:
    key: build-cache
    paths:
      - vendor/
  after_script:
    - echo "World"

job B:
  stage: test
  script:
    - cat vendor/hello.txt
  cache:
    key: build-cache
    paths:
      - vendor/

Если на одной машине установлен один runner, то все задания для вашего проекта выполняются на одном хосте:
Последовательность действий:
  1. Запускается конвейер.
  2. запускается задание A.
  3. выполняется before_script.
  4. выполняется скрипт.
  5. выполняется after_script.
  6. запускается cache, и каталог vendor/ запечатывается в файл cache.zip. Затем этот файл сохраняется в директории в соответствии с настройками бегунка и ключом cache:.
  7. Запускается задание B.
  8. Кэш извлекается (если найден).
  9. выполняется before_script.
  10. выполняется скрипт.
  11. Конвейер завершается.

Используя один runner на одной машине, вы не столкнетесь с проблемой, когда задание B может выполняться на runner, отличном от задания A. Такая установка гарантирует возможность повторного использования кэша между этапами. Она работает только в том случае, если выполнение проходит от этапа сборки до этапа тестирования на одном и том же runner/машине. В противном случае кэш может быть недоступен.

В процессе кэширования также необходимо учитывать несколько моментов:

    Если какое-то другое задание с другой конфигурацией кэша сохранило свой кэш в том же zip-файле, он будет перезаписан. Если используется общий кэш на базе S3, файл дополнительно загружается в S3 в объект, основанный на ключе кэша. Таким образом, два задания с разными путями, но одинаковым ключом кэша, перезаписывают свой кэш.
При извлечении кэша из cache.zip все, что находится в zip-файле, извлекается в рабочую директорию задания (обычно это хранилище, которое снесено вниз), и runner не возражает, если архив задания A перезапишет что-то в архиве задания B.

Это работает так, потому что кэш, созданный для одного runner'а, часто не действителен при использовании другим runner'ом. Другая программа может работать на другой архитектуре (например, если кэш включает двоичные файлы). Кроме того, поскольку различные шаги могут выполняться бегунами, работающими на разных машинах, безопасным по умолчанию является следующий вариант