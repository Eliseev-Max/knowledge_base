systemd.service — Service unit configuration
(https://www.freedesktop.org/software/systemd/man/latest/systemd.service.html)

---</lib/systemd/system/>---
[Unit]
Description=Docker Application Container Engine
Documentation=https://docs.docker.com
After=network-online.target docker.socket firewalld.service containerd.service time-set.target
Wants=network-online.target containerd.service
Requires=docker.socket

[Service]
Type=notify
# the default is not to use systemd for cgroups because the delegate issues still
# exists and systemd currently does not support the cgroup feature set required
# for containers run by docker (1)
ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock
ExecReload=/bin/kill -s HUP $MAINPID
TimeoutStartSec=0
RestartSec=2
Restart=always

# Note that StartLimit* options were moved from "Service" to "Unit" in systemd 229.
# Both the old, and new location are accepted by systemd 229 and up, so using the old location
# to make them work for either version of systemd. (2)
StartLimitBurst=3

# Note that StartLimitInterval was renamed to StartLimitIntervalSec in systemd 230.
# Both the old, and new name are accepted by systemd 230 and up, so using the old name to make
# this option work for either version of systemd. (3)
StartLimitInterval=60s

# Having non-zero Limit*s causes performance problems due to accounting overhead
# in the kernel. We recommend using cgroups to do container-local accounting.
LimitNPROC=infinity
LimitCORE=infinity

# Comment TasksMax if your systemd version does not support it.
# Only systemd 226 and above support this option. (5)
TasksMax=infinity

# set delegate yes so that systemd does not reset the cgroups of docker containers (6)
Delegate=yes

# kill only the docker process, not all processes in the cgroup (7)
KillMode=process
OOMScoreAdjust=-500

[Install]
WantedBy=multi-user.target
---

#(1) По умолчанию не следует использовать systemd для cgroups, поскольку проблемы с делегатами все еще существуют,
#    и systemd в настоящее время не поддерживает набор функций cgroup, необходимых для контейнеров, запускаемых docker

#(2) Обратите внимание, что опции StartLimit* были перенесены из «Service» в «Unit» в systemd 229.
#    И старое, и новое расположение принимаются systemd 229 и выше,
#    поэтому используйте старое расположение, чтобы они работали в любой версии systemd.

#(3) Обратите внимание, что StartLimitInterval был переименован в StartLimitIntervalSec в systemd 230.
#  И старое, и новое имя принимаются systemd 230 и выше,
#  так что использование старого имени позволяет использовать эту опцию в любой версии systemd.

#(4) Наличие ненулевых Limit*s приводит к проблемам с производительностью из-за накладных расходов на учет в ядре.
#  Мы рекомендуем использовать cgroups для локального учета контейнеров.

#(5) Закомментируйте TasksMax, если ваша версия systemd его не поддерживает.
#  Только systemd 226 и выше поддерживает эту опцию.

#(6) установите Delegate yes, чтобы systemd не сбрасывала cgroups контейнеров docker

#(7) убить только процесс docker (запущенный контейнер), а не все процессы в группе cgroup

---
ExecStart=

  Команды, которые выполняются при запуске этой службы.
  Значение разбивается на ноль или более командных строк в соответствии с правилами, описанными в разделе «Командные строки» ниже.

  Если Type= не является oneshot, должна быть указана ровно одна команда.
  При использовании Type=oneshot может быть указано ноль или более команд.

  Команды могут быть указаны:
  * путем предоставления нескольких командных строк в одной директиве,
    <или, наоборот>
  * эта директива может быть указана более одного раза с тем же эффектом.

  Если этой опции присвоена ПУСТАЯ СТРОКА,
    список команд для запуска СБРАСЫВАЕТСЯ, предыдущие назначения этой опции не имеют эффекта.

(!) Если параметр ExecStart= не указан,
    то служба должна иметь RemainAfterExit=yes и хотя бы одну строку ExecStop=.

[!] (Службы, в которых отсутствуют и ExecStart=, и ExecStop=, НЕДЕЙСТВИТЕЛЬНЫ).

  Если указано более одной команды,
    то они вызываются последовательно в порядке их появления в файле блока.

  Если одна из команд не выполняется (и не имеет префикса «-»),
    другие строки НЕ ВЫПОЛНЯЮТСЯ, и блок считается неудачным.

  Если не задан Type=forking,
    процесс, запущенный через эту командную строку, будет считаться главным процессом демона.

---
Command lines
  В этом разделе описывается разбор командной строки и замена переменных и спецификаторов для опций
    ExecStart=,
    ExecStartPre=,
    ExecStartPost=,
    ExecReload=,
    ExecStop=,
    ExecStopPost=
    и ExecCondition=.

  Несколько командных строк можно объединить (may be concatenated) в одну директиву, разделив их точками с запятой
  (эти точки с запятой должны быть переданы как отдельные слова).
  Одиночные точки с запятой могут быть экранированы как «\;».

  Каждая командная строка раскрывается в кавычки (unquoted) по правилам, описанным в разделе «Кавычки» в systemd.syntax(7).
  Первый элемент становится командой для выполнения, а последующие - аргументами.

  Этот синтаксис вдохновлен синтаксисом оболочки,
  но понимаются только метасимволы и расширения, описанные в следующих параграфах, а расширение переменных отличается.
(!)  В частности, НЕ ПОДДЕРЖИВАЕТСЯ:
    * перенаправление с помощью символов «<», «<<», «>» и «>>»,
    * использование пайпов с помощью «|»,
    * запуск программ в фоновом режиме с помощью «&»
    и другие элементы синтаксиса shell.

  Команда для выполнения может содержать пробелы, но УПРАВЛЯЮЩИЕ СИМВОЛЫ НЕ ДОПУСКАЮТСЯ.

  Каждая команда может иметь префикс из нескольких специальных символов:
(см. таблицу)
---
"@"
  = Если путь к исполняемому файлу имеет префикс «@»,
    вторая указанная лексема будет передана в качестве argv[0] выполняемому процессу
    (вместо фактического имени файла), а затем последующие указанные аргументы.

"-"
  = Если путь к исполняемому файлу имеет префикс «-», то код выхода команды, обычно считающийся неудачей
    (т. е. НЕНУЛЕВОЙ СТАТУС выхода или аномальный выход из-за сигнала) записывается,
    но не имеет дальнейшего эффекта и считается эквивалентным успеху.

":"
  = Если путь к исполняемому файлу имеет префикс «:»,
    подстановка переменных окружения (как описано ниже в этой таблице) не применяется.

"+"
  = Если путь к исполняемому файлу имеет префикс «+», то процесс выполняется с полными привилегиями.
    В этом режиме ограничения привилегий, настроенные с помощью
    * User=,
    * Group=,
    * CapabilityBoundingSet=
    или различных опций расстановки имен файловой системы (например, PrivateDevices=, PrivateTmp=),
    НЕ ПРИМЕНЯЮТСЯ к вызываемой командной строке
    (НО по-прежнему влияют на любые другие строки ExecStart=, ExecStop=, ...).
    Однако обратите внимание,
      что это НЕ ОБХОДИТ ОПЦИИ, которые применяются ко всей группе управления, такие как DevicePolicy=,
    # полный список см. в systemd.resource-control(5).

"!"
  = Как и символ «+», рассмотренный выше, он позволяет вызывать командные строки с повышенными привилегиями.
  Однако, в отличие от «+», символ «!» изменяет исключительно действие User=, Group= и SupplementaryGroups=, то есть только те строфы, которые влияют на полномочия пользователей и групп. Обратите внимание, что этот параметр можно комбинировать с DynamicUser=,
  в этом случае динамическая пара пользователь/группа назначается перед вызовом команды, но изменение учетных данных остается на усмотрение самого выполняемого процесса.

"!!"
  = Этот префикс очень похож на «!», однако он действует только в системах без поддержки возможностей окружающего процесса,
  т.е. без поддержки AmbientCapabilities=.
  Он предназначен для файлов модулей, использующих возможности ambient, чтобы запускать процессы с минимальными привилегиями, где это возможно, оставаясь совместимыми с системами, в которых отсутствует поддержка ambient capabilities.
  Обратите внимание, что при использовании «!!!» и обнаружении системы, не поддерживающей окружающие возможности, все настроенные строфы SystemCallFilter= и CapabilityBoundingSet= неявно изменяются, чтобы позволить порожденным процессам самостоятельно сбрасывать полномочия и возможности, даже если это настроено как запрещенное.
  Более того, при использовании этого префикса и обнаружении системы без поддержки окружающих возможностей AmbientCapabilities= будет пропущен и не будет применен.
  В системах, поддерживающих окружающие возможности, «!!!» не имеет никакого эффекта и является избыточным.
---


"@", "-", ":", and one of "+"/"!"/"!!" могут использоваться вместе, и они могут появляться в любом порядке.
(!) Однако одновременно можно использовать ТОЛЬКО ОДИН из символов «+», «!», «!!».

  Для каждой команды первым аргументом должен быть
    - либо абсолютный путь к исполняемому файлу,
    - либо просто имя файла без косых черт.
  Если команда не является полным (абсолютным) путем,
  она будет преобразована в полный путь с использованием фиксированного пути поиска, определенного во время компиляции.

  В поиск включаются каталоги:
    /usr/local/bin/
    /usr/bin/
    /bin/ в системах с разделенными каталогами /usr/bin/ и /bin/
    а также их аналоги sbin/ в системах с разделенными bin/ и sbin/.

  Таким образом, в случае исполняемых файлов, расположенных в любом из «стандартных» каталогов,
  безопасно использовать ТОЛЬКО ИМЯ ИСПОЛНЯЕМОГО ФАЙЛА,
  а в остальных случаях необходимо использовать АБСОЛЮТНЫЙ ПУТЬ.

(*) Подсказка: этот путь поиска можно запросить с помощью systemd-path search-binaries-default.

В командной строке принимаются спецификаторы «%», как описано в systemd.unit(5).

Поддерживается базовая подстановка переменной окружения.
  Используйте «${FOO}» как часть слова или как самостоятельное слово в командной строке,
  => в этом случае оно будет стерто и заменено точным значением переменной окружения (если таковая имеется),
     включая все пробельные символы, которые она содержит, что всегда приводит к единственному аргументу.

  Используйте «$FOO» как отдельное слово в командной строке,
  => в этом случае оно будет заменено значением переменной окружения, разделенным на пробелы,
     что приведет к нулю или более аргументов.

  Для этого типа расширения кавычки соблюдаются при разбиении на слова, а затем удаляются.

---<Example:>---

Environment="ONE=one" 'TWO=two two'
ExecStart=echo $ONE $TWO ${TWO}
This will execute /bin/echo with four arguments: "one", "two", "two", and "two two".

Example:

Environment=ONE='one' "TWO='two two' too" THREE=
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}
ExecStart=/bin/echo $ONE $TWO $THREE


# В результате /bin/echo будет вызван дважды:
# первый раз с аргументами «„one“», «„two two“ too», «»,
# а второй раз с аргументами «one», «two two», «too».

#[!] Чтобы передать буквальный знак доллара, используйте «$$».
# Переменные, значение которых неизвестно на момент расширения, рассматриваются как пустые строки.
#[!ОБРАТИТЕ ВНИМАНИЕ!]:
##  первый аргумент (т. е. программа для выполнения) НЕ МОЖЕТ БЫТЬ ПЕРЕМЕННОЙ.

# Переменные, которые будут использоваться таким образом, могут быть определены через Environment= и EnvironmentFile=.
# Кроме того, могут использоваться переменные, перечисленные в разделе «Переменные окружения в порожденных процессах»
# ("Environment variables in spawned processes") в systemd.exec(5),
# которые считаются «статической конфигурацией» (сюда входит, например, $USER, но не $TERM).

#[!ОБРАТИТЕ ВНИМАНИЕ!]
  командные строки shell напрямую не поддерживаются.
  Если shell command lines должны использоваться, их необходимо явно передавать в какую-либо реализацию оболочки.

Пример:
ExecStart=sh -c 'dmesg | tac'

Example:
---
ExecStart=echo one ; echo "two two"
---
# Это приведет к выполнению echo два раза, каждый раз с одним аргументом: «один» и „два два“, соответственно.
# Поскольку заданы две команды, необходимо использовать Type=oneshot.


Example:
---
Type=oneshot
ExecStart=:echo $USER ; -false ; +:@true $TEST
---
# Это приведет к выполнению /usr/bin/echo с литеральным аргументом «$USER»
# («:» подавляет расширение переменной),
# затем /usr/bin/false (возвращаемое значение будет проигнорировано, поскольку «-» ПОДАВЛЯЕТ ПРОВЕРКУ ВОЗВРАЩАЕМОГО ЗНАЧЕНИЯ),
# и /usr/bin/true (с повышенными привилегиями, с «$TEST» в качестве argv[0]).

Example:
---
ExecStart=echo / >/dev/null & \; \
ls
---
# 
Это позволит выполнить команду echo с пятью аргументами:
«/»,
„>/dev/null“,
„&“,
„;“
и „ls“.


---</lib/systemd/system/docker.socket>---
Если /var/run не реализована как симлинк на /run, вам может потребоваться указать ListenStream=/var/run/docker.sock вместо этого.
---