nginx
{ sources:
  1. https://nginx.org/ru/docs/beginners_guide.html
  2. https://www.youtube.com/playlist?list=PLhgRAQ8BwWFa7ulOkX0qi5UfVizGD_-Rc
  3. https://www.youtube.com/watch?v=ixfnxLqcLOs
[+]
# Embedded Variables (встренные переменные): 
# https://nginx.org/en/docs/http/ngx_http_core_module.html?&_ga=2.166474046.1839600882.1730115003-1073240226.1730115003#variables

}

[Рассматриваемые вопросы:]
  • запуск и останов nginx;
  • перезапуск конфигурации;
  • устройство конфигурационного файла;
  • настройка nginx для раздачи статического содержимого;
  • настройка прокси-сервера на nginx;
  • как связать nginx с приложением FastCGI.


*******************
* Процессы nginx: *
*******************
  • главный
    - один
    - основные задачи:
      → чтение и проверка конфигурации,
      → управление рабочими процессами

  • рабочие
    - обычно несколько
    - основная задача: выполняют фактическую обработку запросов;
    - количество процессов задаётся в конфигурационном файле;
    - количество процессов может быть 
      * фиксированным для данной конфигурации 
      * автоматически устанавливаться равным числу доступных процессорных ядер
        (https://nginx.org/ru/docs/ngx_core_module.html#worker_processes)

  nginx использует:
    - модель, основанную на событиях;
    - зависящие от операционной системы механизмы для эффективного распределения запросов между рабочими процессами.

  Конфигурационный файл nginx: nginx.conf (по умолчанию)
  → определяет, как будут работать nginx и его модули;
  → расположен в каталоге:
    /usr/local/nginx/conf
    /etc/nginx
    /usr/local/etc/nginx


************************************************
* Запуск, остановка, перезагрузка конфигурации *
************************************************
  Чтобы запустить nginx, нужно выполнить исполняемый файл.
  Когда nginx запущен, им можно управлять, вызывая исполняемый файл с параметром -s.
---
$ nginx -s <сигнал>
---

  Сигналы могут иметь значения:
    • stop — быстрое завершение
    • quit — плавное завершение (с ожиданием окончания обслуживания текущих запросов рабочими процессами)
    • reload — перезагрузка конфигурационного файла
    • reopen — переоткрытие лог-файлов

[‼]  Команда должна быть выполнена ПОД ТЕМ ЖЕ ПОЛЬЗОВАТЕЛЕМ, под которым был ЗАПУЩЕН nginx
  
[!]  Изменения, сделанные в конфигурационном файле, НЕ БУДУТ ПРИМЕНЕНЫ, пока
    -> команда ПЕРЕЗАГРУЗИТЬ КОНФИГУРАЦИЮ не будет ВРУЧНУЮ ОТПРАВЛЕНА nginx’у
    <или>
  nginx не будет перезапущен.
    $ nginx -s reload      # перезагрузка конфигурации
  
  Получив сигнал, главный процесс:
    - проверяет правильность синтаксиса нового конфигурационного файла;
    - пытается применить конфигурацию, содержащуюся в нём.
  <если удаётся>:
    + главный процесс запускает новые рабочие процессы,
    + отправляет сообщения старым рабочим процессам с требованием завершиться.

  <если не удалось>:
      - главный процесс откатывает изменения и продолжает работать со старой конфигурацией.
    
  Старые рабочие процессы, получив команду ЗАВЕРШИТЬСЯ:
    - прекращают принимать новые запросы
    - продолжают обслуживать текущие запросы до тех пор, пока все такие запросы не будут обслужены.
    - после этого старые рабочие процессы завершаются.

[Дополнительный способ послать сигнал nginx-у:]
  Посылать сигналы процессам nginx можно также средствами Unix (= утилита kill).
    [сигнал] -(напрямую)-> процесс с данным ID.
    ID главного процесса nginx записывается по умолчанию в файл nginx.pid в каталоге
      /usr/local/nginx/logs
        или
      /var/run
    
    Пример:
---
$ kill -s QUIT 1628
# 1628 - PID главного процесса nginx
---

  $ ps -ax | grep nginx      # просмотр списка всех запущенных процессов

## (отправка сигналов и управление nginx: https://nginx.org/ru/docs/control.html)


*************************************
* Структура конфигурационного файла *
*************************************

  -> nginx состоит из модулей
  --> модули настраиваются директивами
  ---> директивы указаны в конфигурационном файле.

  Виды директив:
    • простая
      - состоит из имени и параметров, разделённых пробелами,
      - оканчивается точкой с запятой (;)

    • блочная
      - устроена так же, как и простая директива,
        но ВМЕСТО ТОЧКИ С ЗАПЯТОЙ после имени и параметров следует НАБОР ДОПОЛНИТЕЛЬНЫХ ИНСТРУКЦИЙ,
          помещённых ВНУТРИ ФИГУРНЫХ СКОБОК ({ и }).

        Если у блочной директивы внутри фигурных скобок можно задавать другие директивы,
        то она называется контекстом
[примеры:]
  events (https://nginx.org/ru/docs/ngx_core_module.html#events),
  http (https://nginx.org/ru/docs/http/ngx_http_core_module.html#http),
  server (https://nginx.org/ru/docs/http/ngx_http_core_module.html#server) и
  location (https://nginx.org/ru/docs/http/ngx_http_core_module.html#location)


   Директивы, помещённые в конфигурационном файле вне любого контекста,
   считаются находящимися в контексте main.
# Директивы вне контекста == в контексте main;

### Часть строки после символа # считается комментарием.
  
  Расположение директив:
  ♦ events и http - в контексте main,
  ♦ server — в контексте http, 
  ♦ location — в контексте server.

---
main {              # корневая директива. Она не указывается явно
    events {
        # 
    }

    http {
        ##
        location {
            ##
        }
    }

}
---

location:
  = устанавливает конфигурацию в зависимости от URI запроса.
  Для сопоставления используется URI запроса В НОРМАЛИЗОВАННОМ ВИДЕ, после
    ✓ декодирования текста, заданного в виде “%XX”,
    ✓ преобразования относительных элементов пути "." и ".." в реальные
    ✓ и возможной замены двух и более подряд идущих слэшей на один.

  Синтаксис:
    location [ = | ~ | ~* | ^~ ] uri { ... }
    location @имя { ... }

  Контекст:	server, location


  location можно задать префиксной строкой или регулярным выражением.
  Регулярные выражения задаются
    - либо с модификатором “~*” (для поиска совпадения без учёта регистра символов)
    - либо с модификатором “~” (с учётом регистра).

************************************
* Раздача статического содержимого *
************************************

  Одна из важных задач конфигурации nginx — раздача файлов (изображения, HTML-страницы).
  
  Пример раздачи статических файлов
  - расположение HTML-страниц: /data/www
  - расположение файлов изображений: /data/images
  
  Что потребуется сделать:
  - отредактировать конфигурационный файл и настроить блок server внутри блока http с двумя блоками location.
  
  Конфигурационный файл по умолчанию уже включает в себя несколько примеров блока server, большей частью закомментированных.
  Создадим новый блок:
---
http {
    server {
    }
}
---

  В общем случае конфигурационный файл может содержать несколько блоков server {},
  различаемых
    -> по портам, на которых они слушают (= директива listen),
    -> и по имени сервера (= директива server_name).

# listen (https://nginx.org/ru/docs/http/ngx_http_core_module.html#listen)

Синтаксис: 
  listen <адрес[:порт]> [default_server]
					  [ssl]
					  [http2 | quic]
					  [proxy_protocol]
					  [setfib=число]
					  [fastopen=число]
					  [backlog=число]
					  [rcvbuf=размер]
					  [sndbuf=размер]
					  [accept_filter=фильтр]
					  [deferred]
					  [bind]
					  [ipv6only=on|off]
					  [reuseport]
					  [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];

  listen <порт> [default_server] [ssl] [http2 | quic] [proxy_protocol] [setfib=число] [fastopen=число] [backlog=число] [rcvbuf=размер] [sndbuf=размер] [accept_filter=фильтр] [deferred] [bind] [ipv6only=on|off] [reuseport] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];

  listen <unix:путь> [default_server] [ssl] [http2 | quic] [proxy_protocol] [backlog=число] [rcvbuf=размер] [sndbuf=размер] [accept_filter=фильтр] [deferred] [bind] [so_keepalive=on|off|[keepidle]:[keepintvl]:[keepcnt]];

Умолчание:
  listen *:80 | *:8000;

Контекст: 	server
---
## Имена сервера: https://nginx.org/ru/docs/http/server_names.html

  Определив, какой server будет обрабатывать запрос,
  nginx сравнивает URI, указанный в заголовке запроса, с параметрами директив location, определённых внутри блока server

##> Добавим в блок server блок location:
---
http {
    server {
        location / {
            root /data/www;
        }
    }
}
---
# Этот блок location задаёт "/" в качестве префикса, который сравнивается с URI из запроса.
  Путь к запрашиваемому файлу в локальной ФС (для подходящих запросов) = 
  = /data/www/ + URI
# добавление URI к пути, указанному в директиве root

**************************************************************
* RESPONSE = значение root + значение location + остаток URI *
**************************************************************
  
  Если есть совпадение с несколькими блоками location,
  nginx выбирает БЛОК С САМЫМ ДЛИННЫМ ПРЕФИКСОМ.

  location /
    = самый короткий префикс
    → этот блок будет использован, только если не будет совпадения ни с одним из остальных блоков location

###############################################################
# префикс `/` используется по остаточному принципу,           #
# если нет совпадений ни с одним из остальных блоков location #
###############################################################

##>  Добавим ещё один блок:
---
location /images/ {
    root /data;
}
---
# Он будет давать совпадение с запросами, начинающимися с /images/
# (`location /` для них тоже подходит, но указанный там префикс короче). 

# Итоговая конфигурация:
---
server {
    location / {
        root /data/www;
    }

    location /images/ {
        root /data;
    }
}
---

# Это уже работающая конфигурация сервера,
#  → слушающего на стандартном порту 80 и
#  → доступного на локальном компьютере по адресу http://localhost/
# В ответ на запросы, URI которых начинаются с /images/, сервер будет отправлять файлы из каталога /data/images.
# Например:
[REQUEST]:   http://localhost/images/example.png
[SERVER_PROCESSING]:  /data/images/example.png
  ! Если же этот файл не существует, nginx отправит ответ, указывающий на ошибку 404.
  
# Запросы, URI которых НЕ начинаются на /images/, будут отображены на каталог /data/www.
# Например:
[REQUEST]:  http://localhost/some/example.html
[SERVER_PROCESSING]: /data/www/some/example.html

[Troubleshooting:]
‼ В случае если что-то работает не как ожидалось, можно попытаться выяснить причину с помощью файлов
  ► access.log
    <и>
  ► error.log
  из каталога
  /usr/local/nginx/logs
    <или>
  /var/log/nginx


*************************************
* Настройка простого прокси-сервера *
*************************************

  Одним из частых применений nginx является использование его в качестве прокси-сервера.
  Прокси-сервер:
    1) принимает запросы,
    2) перенаправляет запросы на проксируемые сервера,
    3) получает ответы от них,
    4) отправляет ответы клиенту

[Пример на практике:]
"""
  Настроим базовый прокси-сервер, который будет
    → обслуживать запросы изображений из локального каталога   и
    → отправлять все остальные запросы на проксируемый сервер.
    
  Оба сервера будут работать в рамках одного экземпляра nginx.
"""
  1. Создадим проксируемый сервер, добавив ещё один блок server в конфигурационный файл nginx:

---<proxy-server.conf>---
server {
    listen 8080;
    root /data/up1;

    location / {
    }
}
---

# Это простой сервер
  - слушающий порт 8080;
  - отображающий все запросы на каталог /data/up1 в локальной ФС
[‼] Директива root помещена в контекст server
    Такая директива root будет использована,
    когда директива location, выбранная для выполнения запроса, не содержит собственной директивы root.

  2. Видоизменим конфигурацию сервера из прошлого примера,
     превратив тем самым в КОНФИГУРАЦИЮ ПРОКСИ-СЕРВЕРА
  # В первый блок location добавим директиву proxy_pass, указав
    ✓ протокол,
    ✓ имя,
    ✓ порт
    прокси-сервера в качестве параметра

---
server {
    location / {
        proxy_pass http://localhost:8080;
    }

    location /images/ {
        root /data;
    }
}
---

  3. Изменим второй блок location, который на данный момент отображает запросы с префиксом /images/
     на файлы из каталога /data/images так, чтобы он подходил для запросов изображений с типичными расширениями файлов.
  ---
  location ~ \.(gif|jpg|png)$ {
    root /data/images;
}
---

# регулярное выражение даёт совпадение со всеми URI, оканчивающимися на .gif, .jpg или .png.
# Регулярному выражению должен предшествовать символ ~ (|| ~*)
# Соответствующие запросы будут отображены на каталог /data/images (значение root)

Когда nginx выбирает блок location, который будет обслуживать запрос, то
  1. вначале он проверяет директивы location, задающие префиксы,
  2. запоминает location с самым длинным подходящим префиксом,
  3. затем проверяет регулярные выражения.
  
  -> if (есть совпадение с регулярным выражением):
  {if True}: nginx выбирает соответствующий location
  {if False}: берётся запомненный ранее location.

# Итоговая конфигурация прокси-сервера
server {
    location / {
        proxy_pass http://localhost:8080/;
    }

    location ~ \.(gif|jpg|png)$ {
        root /data/images;
    }
}

# Этот сервер:
#   - будет фильтровать запросы, оканчивающиеся на .gif, .jpg или .png, 
#   - и отображать их на каталог /data/images (добавлением URI к параметру директивы root)
#   - перенаправлять все остальные запросы на проксируемый сервер, сконфигурированный выше


***********************
* Расположение файлов *
***********************

1) конфигурационный файл nginx: (nginx.conf)
     /usr/local/nginx/conf
     /etc/nginx
     /usr/local/etc/nginx

2) файл nginx.pid (содержит ID главного процесса nginx)
     /usr/local/nginx/logs
     /var/run

3) Файлы журналов (access.log и error.log)
     /usr/local/nginx/logs
     /var/log/nginx

###########
# FastCGI #
###########

  Интерфейс FastCGI — клиент-серверный протокол взаимодействия веб-сервера и приложения, дальнейшее развитие технологии CGI.
  По сравнению с CGI является более производительным и безопасным.

  FastCGI снимает множество ограничений CGI-программ.
  
  Недостаток CGI-программ:
    - они должны быть перезапущены веб-сервером при каждом запросе → понижение производительности.
  
  FastCGI вместо того, чтобы создавать новые процессы для каждого нового запроса,
  использует постоянно запущенные процессы для обработки множества запросов → это позволяет экономить время.

  Взаимодействие с сервером:
    CGI-программы:
      - через STDIN и STDOUT запущенного CGI-процесса,
    
    FastCGI-процессы:
      - используют Unix Domain Sockets или TCP/IP для связи с сервером.
  
  Преимущество FCGI над обычными CGI-программами:
    + FastCGI-программы могут быть запущены не только на этом же сервере, но и где угодно в сети.
    + возможна обработка запросов несколькими FastCGI-процессами, работающими параллельно.

# Lighttpd ("lighty", "лайти") -  веб-сервер, разрабатываемый с расчётом на скорость и защищённость, а также соответствие стандартам.
# Это свободное ПО, распространяемое по лицензии BSD.

lighttpd включает в себя внутренний распределитель нагрузки FastCGI,
который может использоваться для распределения сразу на несколько FastCGI-серверов.
В отличие от иных решений, в кластере должен находиться только FastCGI-процесс, а не целый веб-сервер.
Это позволяет использовать FastCGI-процессу больше ресурсов, по сравнению, например, с load-balancer+apache+mod_php.

При сравнении php-FastCGI с apache+mod_php необходимо обращать внимание на следующее:
  * FastCGI обеспечивает дополнительную безопасность,
    (например, запуск FastCGI-процесса под учётной записью пользователя, отличного от пользователя веб-сервера);
  * может находиться в chroot'е, отличном от chroot'а веб-сервера.

При сравнении perl-FastCGI с apache+mod_perl(1,2), кроме вышеуказанного, заметно:
  → для разделяемого использования памяти между процессами, реализуемого в mod_perl через startup.pl,
    необходим FastCGI-менеджер процессов, реализованный на Perl.
    Это реализуется модулем FCGI::ProcManager и его надстройкой FCGI::Spawn. 

(см. также: https://lectureswww.readthedocs.io/5.web.server/fcgi.html)

---< Как nginx обрабатывает запросы >---
(https://nginx.org/ru/docs/http/request_processing.html)

---
Nginx
  - был создан в 2004 году российским разработчиком Игорем Сысоевым.
  - Игорь Сысоев был разочарован в Apache;
    он хотел создать замену, способную выдержать 10000 запросов одновременно
  - Фокус был сделан на:
    * высокую производительность,
    * большое количество соединений,
    * низкое потребление памяти.

  Nginx используется в качестве:
  → веб-сервера;
  → ‼ обратного прокси-сервера;
  → почтового прокси-сервера;
  → TCP/UDP прокси-сервера общего назначения.
  
  