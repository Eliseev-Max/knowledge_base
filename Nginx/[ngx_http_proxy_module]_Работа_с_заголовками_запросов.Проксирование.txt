Модуль ngx_http_proxy_module
  - позволяет передавать запросы другому серверу

пример конфигурации:
---
location / {
    proxy_pass       http://localhost:8000;
    proxy_set_header Host      $host;
    proxy_set_header X-Real-IP $remote_addr;
}
---

################################
# Передача заголовков запросов #
#       proxy_set_header       #
################################

Синтаксис: 	 proxy_set_header <поле> <значение>;
Умолчание:
  proxy_set_header Host $proxy_host;
  proxy_set_header Connection close;

Контекст: 	http, server, location

По умолчанию NGINX:
  ➜ ПЕРЕОПРЕДЕЛЯЕТ два поля заголовков в проксируемых запросах:
    1) "Host"
      # ("Host"  =[устанавливается в переменную]=>  $proxy_host)

    2) "Connection"
      # ("Connection"  =[устанавливается в значение]=>  close )

  ➜ УДАЛЯЕТ те поля заголовков, значения которых являются пустыми строками.

  ✓ Для изменения этих настроек (ДОБАВИТЬ || ИЗМЕНИТЬ || УДАЛИТЬ),
  ✓ а также для модификации других полей заголовков
    => используется директива proxy_set_header.

'''
В качестве значения proxy_set_header можно использовать
  • текст,
  • переменные 
  • их комбинации.
'''

  Эта директива может быть указана в контексте location или выше.
  Она также может быть указана
    - в контексте конкретного сервера (server)
    - или в блоке http.

(!) Директивы наследуются с предыдущего уровня конфигурации при условии,
    что на данном уровне не описаны свои директивы proxy_set_header.

Например:
---
location /some/path/ {
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_pass http://localhost:8000;
}
---
# В данной конфигурации поле "Host" установлено в переменную $host.

  Чтобы поле заголовка НЕ ПЕРЕДАВАЛОСЬ проксируемому серверу,
  установите для него значение пустой строки следующим образом:
---
location /some/path/ {
    proxy_set_header Accept-Encoding "";
    proxy_pass http://localhost:8000;
}
---

####  

Если включено кэширование, поля заголовка:
  - "If-Modified-Since",
  - "If-Unmodified-Since",
  - "If-None-Match",
  - "If-Match",
  - "Range"    и
  - "If-Range"
  исходного запроса не передаются на проксируемый сервер.

Неизменённое поле заголовка запроса "Host" можно передать так:

---
proxy_set_header Host       $http_host;
---

  Однако, если это поле отсутствует в заголовке запроса клиента, то ничего передаваться не будет.
  В этом случае лучше воспользоваться переменной $host
  -> её значение равно имени сервера в поле "Host" заголовка запроса, или же основному имени сервера, если поля нет:

---
proxy_set_header Host       $host;
---

  Кроме того, можно передать имя сервера вместе с портом проксируемого сервера:

---
proxy_set_header Host       $host:$proxy_port;
---

  Если значение поля заголовка — пустая строка, то поле вообще не будет передаваться проксируемому серверу:

---
proxy_set_header Accept-Encoding "";
---


##################################################
# ...поле X-Forwarded-For заголовка клиентского запроса с добавленной к нему переменной $remote_addr, разделенной запятой.
# Если поле X-Forwarded-For в заголовке клиентского запроса отсутствует, то переменная $proxy_add_x_forwarded_for равна переменной $remote_addr.
#  $proxy_add_x_forwarded_for = $remote_addr

---(Answer)---
-> Если входящий запрос уже содержит заголовок X-Forwarded-For, допустим:

  X-Forwarded-For: 203.0.113.195, 150.172.238.178

  и запрос поступает с IP 198.51.100.17, то новое значение заголовка X-Forwarded-For (которое будет передано в upstream)
  будет иметь вид: 

  X-Forwarded-For: 203.0.113.195, 150.172.238.178, 198.51.100.17

-> Если входящий запрос не содержит заголовка X-Forwarded-For, то этот заголовок будет передан в upstream в виде

  X-Forwarded-For: 198.51.100.17

  С другой стороны, заголовок X-Real-IP, установленный так, как показано в вашем вопросе,
(
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Real-IP       $remote_addr;
)
  всегда будет равен внутренней переменной $remote_addr nginx,
  в данном случае это будет:

  X-Real-IP: 198.51.100.17

# (если только не будет задействован модуль ngx_http_realip_module, который изменит значение этой переменной на что-то другое,
#  отличное от реального адреса удаленного пира;
#  для выяснения всех деталей читайте документацию модуля;
#  в этом вопросе SO также есть несколько полезных примеров/дополнений).

---
(?) Нужно ли использовать оба варианта:
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Real-IP       $remote_addr;
  одновременно?
---
(!)
Самый первый ваш вопрос должен звучать так:
- "Нужно ли мне вообще добавлять эти заголовки в запрос, идущий к моему бэкенду?".
Это зависит от того, какое приложение используется на бэкенде.
  • Рассчитывает ли оно на какие-либо из этих заголовков?
  • Имеют ли значения этих заголовков какое-либо значение для поведения приложения?
  • Как ваше внутреннее приложение относится к этим заголовкам?
Как видите, в качестве источника запроса принимается самый первый адрес из списка адресов X-Forwarded-For.
С другой стороны, этот заголовок может быть легко подделан,
поэтому некоторые серверы могут разрешать использовать этот заголовок только для доверенных источников, удаляя его в противном случае.
Если вы зададите заголовок X-Real-IP в настройках сервера, то он всегда будет содержать реальный адрес удаленного пира;
если вы этого не сделаете и получите поддельный запрос с уже присутствующим в нем заголовком X-Real-IP,
то он будет передан вашему бэкенду как есть, что может быть очень плохо, если ваше приложение предпочитает полагаться на этот заголовок,
а не на X-Forwarded-For.
Различные бэкенды могут вести себя по-разному;
# (чтобы получить представление об этом, можно ознакомиться с обсуждением проблемы на GitHub:
# https://github.com/akka/akka-http/issues/1670).

---< Резюмируя все вышесказанное >---

  Если вы точно знаете, какие заголовки и как может обрабатывать ваше внутреннее приложение:
    → устанавливать необходимые заголовки в соответствии с тем, как они будут обрабатываться,
    → необязательные заголовки - пропускать, чтобы минимизировать полезную нагрузку прокси-сервера.
  
  Если это не так:
    • мы не знаем, может ли ваше приложение быть подделано с помощью неправильного заголовка X-Forwarded-For;
    • у нас нет доверенного прокси-сервера (прокси-серверов) перед вашим экземпляром nginx,
  
  → то наиболее безопасным способом будет установка обоих заголовков в соответствии с реальным адресом удаленного пира:
  proxy_set_header X-Forwarded-For $remote_addr;
  proxy_set_header X-Real-IP       $remote_addr;

Если вы точно знаете, что ваше внутреннее приложение нельзя подделать с помощью неправильного HTTP-заголовка X-Forwarded-For,
и хотите предоставить ему всю информацию, полученную в исходном запросе, используйте пример, который вы привели в своем вопросе:

[Пример:]
---
proxy_set_header X-Forwarded-For $proxy_x_forwarded_for;
proxy_set_header X-Real-IP       $remote_addr;
---

Немного дополнительной технической информации:
  На самом деле, заголовки X-Forwarded-... HTTP-заголовки - это своего рода нестандартные заголовки.
  Согласно MDN предполагалось, что стандартными заголовками для передачи такой информации будут:
    → Via (описанный в RFC7230)
      <и>
    → Forwarded, описанный в RFC7239

  Однако вместо них альтернативным и де-факто стандартным вариантом стали:
    * X-Forwarded-For,
    * X-Forwarded-Host
    * и X-Forwarded-Proto.

  Вместо использования X-Forwarded-Host,
    (который может быть или не быть интерпретирован вашим внутренним приложением),
  более надежным подходом является явное задание HTTP-заголовка Host для проксируемого запроса с помощью следующих элементов:

    * proxy_set_header Host $host;
      <или>
    * proxy_set_header Host $http_host;
      <или даже>
    * proxy_set_header Host $server_name;


(Разницу между внутренними переменными $host, $http_host и $server_name nginx вы можете посмотреть здесь:).

---<>---
$host
  -> содержит "в таком порядке старшинства:
    * имя хоста из строки запроса,
    ** или имя хоста из поля заголовка запроса 'Host',
    *** или имя сервера, соответствующее запросу"

$http_host
  -> включает в себя содержимое поля заголовка HTTP "Host", если оно присутствовало в запросе;

$server_name
  -> содержит server_name виртуального хоста, обработавшего запрос, в том виде, в котором оно было определено в конфигурации nginx.
    Если server содержит несколько имен server_name, в этой переменной будет присутствовать ТОЛЬКО ПЕРВОЕ.

Поскольку для user-agents (пользовательских агентов) легально отправлять имя хоста в строке запроса, а не в заголовке Host:
(хотя это делается редко, за исключением подключения к прокси-серверам) вы должны это учитывать.

Вы также должны учесть случай, когда user-agent вообще не отправляет имя хоста,
например:
  - древние запросы HTTP/1.0;
  - современное плохо написанное программное обеспечение.

Если вы обслуживаете несколько веб-сайтов, вы можете перенаправить их на виртуальный хост, который ничего не обслуживает;
или, если на вашем сервере есть только один веб-сайт, вы можете обрабатывать все запросы через один виртуальный хост.
В последнем случае необходимо учитывать и это.

Только переменная $host учитывает все возможные действия, которые может совершить user-agent при формировании HTTP-запроса.
[!] Почти всегда следует использовать $host,
    поскольку только она гарантированно содержит что-то разумное, независимо от того, как ведет себя user-agent,
    (если только вам не нужна семантика одной из других переменных)
---

С другой стороны, X-Forwarded-Proto используется довольно часто, чтобы сообщить внутреннему приложению, был ли исходный запрос сделан по зашифрованному протоколу HTTPS или нет. Иногда вы даже можете увидеть заголовок X-Forwarded-Proxy, используемый в конфигурации; как по мне, он выглядит бессмысленным, поскольку внутреннее приложение не должно вести себя по-разному в зависимости от программного обеспечения обратного прокси, которое вы используете; однако я могу поверить, что существуют веб-приложения, которые действительно могут работать с этим заголовком каким-то полезным способом. В MDN вообще не упоминается заголовок X-Real-IP; однако определенно существует довольно много веб-приложений, которые должны быть обеспечены этим заголовком.


[Ещё одна техническая тонкость:]
  Like some other reverse proxy servers, nginx will "fold" multiple X-Forwarded-For headers into a single one, so the

proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;

and the

proxy_set_header X-Forwarded-For $http_x_forwarded_for;
proxy_set_header X-Forwarded-For $remote_addr;

configuration fragments will behave identically, passing the single X-Forwarded-For header to your backend app, equal no matter of what configuration will be used.